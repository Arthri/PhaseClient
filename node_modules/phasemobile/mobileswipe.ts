export enum Direction {
    LEFT,
    RIGHT,
    UP,
    DOWN,
    NONE
}

interface Point {
    x: number;
    y: number;
}

type SwipeHandler = (element: HTMLElement, direction: Direction) => void;

export class MobileSwipe {
    private swipeStart: Point;
    private swipeEnd: Point;
    private minimumSwipeDistance: Point;
    private maximumSwipeDistance: Point;
    private swipeDirection: Direction;
    private handlers: Array<SwipeHandler>;
    private element: HTMLElement;

    constructor(element: HTMLElement) {
        this.swipeStart = {
            x: 0,
            y: 0
        };
        this.swipeEnd = {
            x: 0,
            y: 0
        };
        this.minimumSwipeDistance = {
            x: 50,
            y: 50
        };
        this.maximumSwipeDistance = {
            x: 100,
            y: 100
        };
        this.swipeDirection = Direction.NONE;
        this.handlers = [];
        this.element = element;

        this.element.addEventListener('touchstart', (e) => {
            this.handleTouchStart(e);
        }, false);

        this.element.addEventListener('touchmove', (e) => {
            this.handleTouchMove(e);
        }, false);

        this.element.addEventListener('touchend', (e) => {
            this.handleTouchEnd(e);
        }, false);
    }

    public addHandler(handler: SwipeHandler) {
        this.handlers.push(handler);
    }

    private handleTouchStart(touchEvent: TouchEvent): void {
        let touch = touchEvent.touches[0];
        this.swipeStart.x = touch.screenX;
        this.swipeStart.y = touch.screenY;
    }

    private handleTouchMove(touchEvent: TouchEvent): void {
        let touch = touchEvent.touches[0];
        this.swipeEnd.x = touch.screenX;
        this.swipeEnd.y = touch.screenY;
    }

    private handleTouchEnd(touchEvent: TouchEvent): void {
        // Horizontal detection
        if ((Math.abs(this.swipeStart.x-this.swipeEnd.x) > this.minimumSwipeDistance.x)
                && (Math.abs(this.swipeStart.y-this.swipeEnd.y) < this.maximumSwipeDistance.y)
                && (this.swipeEnd.x > 0)) {
            if (this.swipeEnd.x > this.swipeStart.x) {
                this.swipeDirection = Direction.RIGHT;
            }
            else {
                this.swipeDirection = Direction.LEFT;
            }
            
                console.log("HORIZON"+Math.abs(this.swipeStart.x-this.swipeEnd.x));
        }
        else if ((Math.abs(this.swipeStart.y-this.swipeEnd.y) > this.minimumSwipeDistance.y)
                && (Math.abs(this.swipeStart.x-this.swipeEnd.x) < this.maximumSwipeDistance.x)
                && (this.swipeEnd.y > 0)) {
            if (this.swipeEnd.y > this.swipeStart.y) {
                this.swipeDirection = Direction.DOWN;
            }
            else {
                this.swipeDirection = Direction.UP;
            }
                console.log("VERTIC:"+Math.abs(this.swipeStart.y-this.swipeEnd.y));
        }

        if (this.swipeDirection != Direction.NONE) {
            this.emitSwipe();
        }
        this.reset();
    }

    private reset(): void {
        this.swipeDirection = Direction.NONE;
        this.swipeStart.x = 0;
        this.swipeStart.y = 0;
        this.swipeEnd.x = 0;
        this.swipeEnd.y = 0;
    }

    private emitSwipe(): void {
        for (let i = 0; i < this.handlers.length; i++) {
            this.handlers[i](this.element, this.swipeDirection);
        }
    }
}