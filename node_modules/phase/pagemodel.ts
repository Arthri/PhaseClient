import ElementIdentifiers from 'phase/elementidentifiers';
import Templates from 'phase/templates';
import * as $ from 'jquery';
import Client from 'phase/client';
import Discussion from 'phase/discussion';
import Message from 'phase/message';
import Cookie from 'phase/cookie';
import TextDifference from 'phase/textdifference';
import System from 'phase/system';

declare var Notification;

class PageModel {
    private client: Client;
    private loginLoadingTimeout: number;
    private windowHasFocus: boolean;
    private lastMessageInput: string;

    constructor(client: Client) {
        this.client = client;
        this.windowHasFocus = true;
        this.lastMessageInput = "";
        this.registerEvents();
    }

    public getWindowHasFocus(): boolean {
        return this.windowHasFocus;
    }

    // Checks to see if a session is available to skip login page
    public checkSession(): void {
        let session = Cookie.getCookie('_phasesession');
        if (session) {
            this.handleLoginSuccess(session);
        } else {
            $(ElementIdentifiers.Login.loading).hide();
            $(ElementIdentifiers.Login.container).removeClass("inactive");
        }

        let navigate = <any>navigator;
        navigate.serviceWorker.register('sw.js');
    }

    public showNotification(text: string): void {
        console.log("Attempting to show notification for "+text);
        Notification.requestPermission(function(result) {
        let navigate = <any>navigator;
            if (result === 'granted') {
                navigate.serviceWorker.getRegistration().then(function(registration) {
                    registration.showNotification('Phase', {
                        body: text,
                        icon: 'https://t.dark-gaming.com:3001/img/128.png',
                        vibrate: [200, 100, 200, 100, 200, 100, 200],
                        tag: 'vibration-sample'
                    });
                });
            }
        });
    }

    /* Updates the client username in the DOM */
    public updateUsername(username: string): void {
        $(ElementIdentifiers.clientUsername).text(username);
    }

    /* Updates the client avatar in the DOM */
    public updateAvatar(avatar: string): void {
        $(ElementIdentifiers.ChatInput.avatar).html(`<img src="${avatar}" />`);
    }

    /* Clears the existing displayed list and puts in an updated one */
    public refreshUsersOnlineList(): void {
        let sectionList = $(ElementIdentifiers.PeopleSection.main).children(ElementIdentifiers.PeopleSection.list).children('ul');
        sectionList.html('');

        let user;
        let onlineUsers = this.client.getOnlineUsers();
        for (let i = 0; i < onlineUsers.length; i++) {
            user = onlineUsers[i];
            sectionList.append(Templates.PeopleEntry(user));
        }
    }

    /***************************
     * Chat Section / Messages *
     ***************************/

    /* Update the displayed Title */
    public updateDisplayedTitle(name: string): void {
        $(ElementIdentifiers.ChatSection.title).text(name);
    }

    /* Clears the displayed messages */
    public clearMessages(): void {
        $(ElementIdentifiers.ChatSection.list).children().remove();
    }

    /* Displays 40 messages in the chat list from the specified discussion */
    public displayMessages(discussion: Discussion): void {
        let messages = discussion.getMessages();
        let minIndex = messages.length-41 < 0 ? 0 : messages.length-41;
        for (let i = minIndex; i < messages.length; i++) {
            // Do not display join/leave messages if configuration has it off
            if (!this.client.getConfiguration().useAndDisplayJoinLeaveMessages && messages[i].getUserId() == -2 && messages[i].getTag().length !== 0)
                continue;

            // If the config has it set that messages are to be combined then checks need to be done
            if (this.client.getConfiguration().combineMessages) {
                // If the first message or is a join/leave message (so it contains ip, origin, that must be kept in-tact etc)
                if (i == minIndex || messages[i].getUserId() == System.joinLeaveMessageUserId) {
                    $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this.client, messages[i]));
                } else {                
                    // Combine messages that were sent by the same user consecutively, under a minute in difference
                    if (messages[i-1].getUserId() === messages[i].getUserId()
                        && Math.abs(messages[i-1].getTimestamp()-messages[i].getTimestamp()) <= 60
                        && messages[i-1].getTag() == messages[i].getTag()) {
                        $(ElementIdentifiers.ChatSection.list).children('li').last().find('.chat-message-content').append("<br>"+messages[i].getContentStyled());
                    } else {
                        $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this.client, messages[i]));
                    }
                }
            // Otherwise just append the messaget to the list
            } else {
                $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this.client, messages[i]));
            }
        }

        // Scroll the chat to the bottom
        let chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        chatElement[0].scrollTop = chatElement[0].scrollHeight;
    }

    // Remove the oldest n messages from the discussion message list
    public removeOldestMessages(amount: number): void {
        if (amount < 0) {
            amount = 0;
        }
        $(ElementIdentifiers.ChatSection.list).children().slice(0, amount).remove();
    }

    // Add message to the end of the message list
    public appendMessage(lastMessage: Message | null, message: Message): void {
        // If join/leave message and config setting is not to display these, do not handle the message
        if (!this.client.getConfiguration().useAndDisplayJoinLeaveMessages && message.getUserId() == -2 && message.getTag().length !== 0) {
            return;
        }

        let scrollIsAtBottom = this.getScrollIsAtBottom();

        // If the config has it set that messages are to be combined then checks need to be done
        if (this.client.getConfiguration().combineMessages) {
            // If the first message or is a join/leave message (so it contains ip, origin, that must be kept in-tact etc)
            if (lastMessage == null || message.getUserId() == System.joinLeaveMessageUserId) {
                $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this.client, message));
            } else {                
                // Combine messages that were sent by the same user consecutively, under a minute in difference
                if (lastMessage.getUserId() === message.getUserId()
                    && Math.abs(lastMessage.getTimestamp()-message.getTimestamp()) <= 60
                    && lastMessage.getTag() == message.getTag()) {
                    $(ElementIdentifiers.ChatSection.list).children('li').last().find('.chat-message-content').append("<br>"+message.getContentStyled());
                } else {
                    $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this.client, message));
                }
            }
        // Otherwise just append the message to the list
        } else {
            $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this.client, message));
        }

        // Scroll the chat to the bottom if they were at the bottom before
        if (scrollIsAtBottom) {
            // Remove messages that go over max of 40 in display
            this.removeOldestMessages($(ElementIdentifiers.ChatSection.list).children().length-40);
            this.scrollToBottom();
        }
    }

    // Get whether scroll is at bottom
    public getScrollIsAtBottom(): boolean {
        let chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        let maximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
        let currentScroll = chatElement[0].scrollTop;
        let scrollIsAtBottom = currentScroll == maximumScroll;

        return scrollIsAtBottom;
    }

    // Scroll the message list to the bottom
    public scrollToBottom(): void {
        let chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        let maximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
        chatElement[0].scrollTop = maximumScroll;
    }
    
    // Creates a live typing element at the bottom of the message list
    public createLiveTyping(message: Message): void {
        let scrollIsAtBottom = this.getScrollIsAtBottom();
        $(ElementIdentifiers.ChatSection.liveTyping).append(Templates.LiveTypingMessage(this.client, message));
        
        // Scroll the chat to the bottom if they were at the bottom before
        if (scrollIsAtBottom) {
            this.scrollToBottom();
        }
    }
    
    // Updates the content of an existing live typing element
    public updateLiveTyping(message: Message): void {
        let scrollIsAtBottom = this.getScrollIsAtBottom();
        $(`#livetyping-user-${message.getUserId()}`).find('.chat-message-content').text(message.getContentStyled());

        // Scroll the chat to the bottom if they were at the bottom before
        if (scrollIsAtBottom) {
            this.scrollToBottom();
        }
    }
    
    // Removes an existing live typing element based on userId
    public removeLiveTyping(userId: number): void {
        $(`#livetyping-user-${userId}`).remove();
    }

    /*******************
     * Discussion List *
     *******************/

    /* Adds a discussion to the top of the discussions list */
    public prependDiscussionsList(discussion: Discussion): void {
        $(ElementIdentifiers.DiscussionSection.list).prepend(Templates.DiscussionListEntry(discussion));
    }

    /* Updates the selected class to the newly switched discussion */
    public switchSelectedDiscussion(elem: any): void {
        $('.selected').removeClass('selected');
        elem.addClass('selected');
    }

    // Remove unread style to discussion div
    public setDiscussionRead(discussion: Discussion): void {
        $(`#disc${discussion.getId()}`)
            .removeClass('unread');
    }

    // Apply unread style to discussion div
    public setDiscussionUnread(discussion: Discussion): void {
        $(`#disc${discussion.getId()}`)
            .addClass('unread');
    }

    // Update the preview of the discussion div in the discussion list
    public updateDiscussionEntryMessagePreview(discussion: Discussion): void {
        $(`#disc${discussion.getId()}`)
            .children(ElementIdentifiers.DiscussionSection.preview)
            .text(`${discussion.getRecentMessage().getDisplayName().asIs()}: ${discussion.getRecentMessage().getContent().withBbcodeStripped()}`);
    }

    /**********
     * EVENTS *
     **********/

    // Registers the necessary events for interactivity
    protected registerEvents(): void {
        this.registerDiscussionListClick();
        this.registerMessageSend();
        this.registerLogin();
        this.registerWindowFocus();
        this.registerTextInput();
    } 

    // Registers a click on a discussion list element for switching discussions
    private registerDiscussionListClick(): void {
        let self = this;
        $(ElementIdentifiers.DiscussionSection.list).on('mousedown', ElementIdentifiers.DiscussionSection.discussion, function() {
            self.client.switchDiscussion(+$(this).attr('id').substr(4), $(this));
        });
    }

    // Registers the submit event of the chat message form for sending a message
    private registerMessageSend(): void {
        let self = this;
        $(ElementIdentifiers.ChatInput.textInput).on('keydown', function(event) {
            if (event.keyCode == 13) {
                self.handleMessageSend(this);
            }
        });
    }

    // Tells the client to take the nessary steps to send the message
    private handleMessageSend(context: any): void {
        let chatText = $(context).val();
        this.client.sendChatMessage(chatText);
        $(context).val('');
    }

    // Sends an ajax request using the login details provided when the login form is submitted
    private registerLogin(): void {
        $('#login_form').submit((e) => {
            e.preventDefault();
            this.setLoadingTimeout();
            
            $.ajax({
                method: "POST",
                url: "https://t.dark-gaming.com:3001/login",
                data: {
                username: $('#username').val(),
                password: $('#password').val(),
                server: $('#servername').find(':selected').text()
                },
                success: (data, textStatus, request) => {
                    this.handleLoginResponse(data, textStatus, request);
                }
            });
            return false;
        });
    }

    // Sets a timeout to remove the loading icon
    private setLoadingTimeout(): void {
        this.loginLoadingTimeout = setTimeout(() => {
            $(ElementIdentifiers.Login.loading).show();
            $(ElementIdentifiers.Login.container).addClass('inactive');
        }, 300);
    }

    // Displays a message when there was an error or closes the login form if it was successful
    private handleLoginResponse(data: {state: string, session:string}, textStatus: string, request: any): void {
        switch (data.state) {
            case "success":
                this.handleLoginSuccess(data.session);
                break;
            case "failure":
                $(ElementIdentifiers.Login.information).html('<span style="color: Red;">Invalid User/Pass Combination.</span>');
                break;
            case "no-body":
                $(ElementIdentifiers.Login.information).html('<span style="color: Red;">This form is invalid. Refresh the page.</span>');
                break;
            case "timeout":
                $(ElementIdentifiers.Login.information).html('<span style="color: Red;">The server selected is currently unresponsive.</span>');
                break;
            default:
                $(ElementIdentifiers.Login.information).html('<span style="color: Red;">Unknown error.</span>');
                break;
        }

        if (data.state !== 'success') {
            clearTimeout(this.loginLoadingTimeout);
            $(ElementIdentifiers.Login.container).removeClass('inactive');
            $(ElementIdentifiers.Login.loading).hide();

            setTimeout(() => {
                $(ElementIdentifiers.Login.information).html('');
            }, 4000);
        }
    }

    // Hides the login form and sends off an information request through the websocket
    private handleLoginSuccess(session: string): void {
        $('#phase').css("display", "block");
        $(ElementIdentifiers.Login.main).css("display", "none");
        this.client.sendInformationRequest(session);
    }

    // Stores whether the window is in focus
    private registerWindowFocus(): void {
        $(window).focus(() => {
            this.windowHasFocus = true;
        }).blur(() => {
            this.windowHasFocus = false;
        });
    }

    private registerTextInput(): void {
        let self = this;
        $(ElementIdentifiers.ChatInput.textInput).on('input', function(event) {
            let currentMessage = $(this).val();
            let queue = TextDifference.getEditQueue(self.lastMessageInput, currentMessage);
            self.lastMessageInput = currentMessage;

            self.client.sendEditQueue(queue);
        });
    }
}

export default PageModel;