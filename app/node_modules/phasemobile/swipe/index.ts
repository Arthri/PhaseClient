import Point from 'phasemobile/swipe/point';
import SwipeDirection from 'phasemobile/swipe/direction';
import Handler from 'phasemobile/swipe/handler';

class Swipe {
    private swipeStart: Point;
    private swipeEnd: Point;
    private minimumSwipeDistance: Point;
    private maximumSwipeDistance: Point;
    private swipeDirection: SwipeDirection;
    private handlers: Array<Handler>;
    private element: HTMLElement;

    constructor(element: HTMLElement) {
        this.swipeStart = {
            x: 0,
            y: 0
        };
        this.swipeEnd = {
            x: 0,
            y: 0
        };
        this.minimumSwipeDistance = {
            x: 50,
            y: 50
        };
        this.maximumSwipeDistance = {
            x: 100,
            y: 100
        };
        this.swipeDirection = SwipeDirection.NONE;
        this.handlers = [];
        this.element = element;

        let passive: any = {
            passive: true
        };

        this.element.addEventListener('touchstart', (e) => {
            this.handleTouchStart(e);
        }, passive);

        this.element.addEventListener('touchmove', (e) => {
            this.handleTouchMove(e);
        }, passive);

        this.element.addEventListener('touchend', (e) => {
            this.handleTouchEnd(e);
        }, passive);
    }

    public addHandler(handler: Handler) {
        this.handlers.push(handler);
    }

    private handleTouchStart(touchEvent: TouchEvent): void {
        let touch = touchEvent.touches[0];
        this.swipeStart.x = touch.screenX;
        this.swipeStart.y = touch.screenY;
    }

    private handleTouchMove(touchEvent: TouchEvent): void {
        let touch = touchEvent.touches[0];
        this.swipeEnd.x = touch.screenX;
        this.swipeEnd.y = touch.screenY;
    }

    private handleTouchEnd(touchEvent: TouchEvent): void {
        // Horizontal detection
        if ((Math.abs(this.swipeStart.x-this.swipeEnd.x) > this.minimumSwipeDistance.x)
                && (Math.abs(this.swipeStart.y-this.swipeEnd.y) < this.maximumSwipeDistance.y)
                && (this.swipeEnd.x > 0)) {
            if (this.swipeEnd.x > this.swipeStart.x) {
                this.swipeDirection = SwipeDirection.RIGHT;
            }
            else {
                this.swipeDirection = SwipeDirection.LEFT;
            }
            
                console.log("HORIZON"+Math.abs(this.swipeStart.x-this.swipeEnd.x));
        }
        else if ((Math.abs(this.swipeStart.y-this.swipeEnd.y) > this.minimumSwipeDistance.y)
                && (Math.abs(this.swipeStart.x-this.swipeEnd.x) < this.maximumSwipeDistance.x)
                && (this.swipeEnd.y > 0)) {
            if (this.swipeEnd.y > this.swipeStart.y) {
                this.swipeDirection = SwipeDirection.DOWN;
            }
            else {
                this.swipeDirection = SwipeDirection.UP;
            }
                console.log("VERTIC:"+Math.abs(this.swipeStart.y-this.swipeEnd.y));
        }

        if (this.swipeDirection != SwipeDirection.NONE) {
            this.emitSwipe();
        }
        this.reset();
    }

    private reset(): void {
        this.swipeDirection = SwipeDirection.NONE;
        this.swipeStart.x = 0;
        this.swipeStart.y = 0;
        this.swipeEnd.x = 0;
        this.swipeEnd.y = 0;
    }

    private emitSwipe(): void {
        for (let i = 0; i < this.handlers.length; i++) {
            this.handlers[i](this.element, this.swipeDirection);
        }
    }
}

export default Swipe;