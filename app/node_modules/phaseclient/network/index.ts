import Client from "phaseclient/client";
import Discussion from "phaseclient/discussion";
import { BooleanHash, UserHash } from "phaseclient/hash";
import Message from "phaseclient/message";
import Channel from "phaseclient/network/channel";
import RawMessage from "phaseclient/network/rawmessage";
import Socket from "phaseclient/network/socket";
import User from "phaseclient/user";
import ChatEditQueue from "phasecore/editqueue";
import ChatMessage from "phasecore/messagetypes/chatmessage";
import ChatMessageDenied from "phasecore/messagetypes/chatmessagedenied";
import ChatMessageRevoked from "phasecore/messagetypes/chatmessagerevoked";
import DeepHistoryResults from "phasecore/messagetypes/deephistory";
import DeepHistoryNewerResults from "phasecore/messagetypes/deephistorynewer";
import DeepHistoryOlderResults from "phasecore/messagetypes/deephistoryolder";
import DiscussionAlertList from "phasecore/messagetypes/discussionalertlist";
import { DiscussionMessage, DiscussionMessages } from "phasecore/messagetypes/discussionmessages";
import { Discussion as ReceivedDiscussion, Discussions } from "phasecore/messagetypes/discussions";
import DiscussionUserAdd from "phasecore/messagetypes/discussionuseradd";
import DiscussionUserDemote from "phasecore/messagetypes/discussionuserdemote";
import DiscussionUserPromote from "phasecore/messagetypes/discussionuserpromote";
import DiscussionUserRemove from "phasecore/messagetypes/discussionuserremove";
import DiscussionUsers from "phasecore/messagetypes/discussionusers";
import EditQueue from "phasecore/messagetypes/editqueue";
import NewDiscussion from "phasecore/messagetypes/newdiscussion";
import NewDiscussionResponse from "phasecore/messagetypes/newdiscussionresponse";
import RemoveDiscussion from "phasecore/messagetypes/removediscussion";
import SearchResults from "phasecore/messagetypes/searchresults";
import SearchUserResults from "phasecore/messagetypes/searchuserresults";
import SetInformation from "phasecore/messagetypes/setinformation";
import TerrariaChangeName from "phasecore/messagetypes/terrariachangename";
import TerrariaJoinLeave from "phasecore/messagetypes/terrariajoinleave";
import TerrariaUsersOnline from "phasecore/messagetypes/terrariausersonline";
import UserAvatarUpdate from "phasecore/messagetypes/useravatarupdate";
import UserOffline from "phasecore/messagetypes/useroffline";
import UserOnline from "phasecore/messagetypes/useronline";
import UsersOnline from "phasecore/messagetypes/usersonline";
import System from "phasecore/system";
import UserStatus from "phasecore/userstatus";
import * as SocketCluster from "socketcluster-client";

class Network {
    private isGuest: boolean;
    private socket: Socket;
    private _client: Client;
    private userChannel: Channel;
    private systemChannel: Channel;
    private globalChannel: Channel;
    private firstConnectionMade: boolean;
    private wasReconnected: boolean;

    // Used to identify which message was rejected
    private chatSequenceId: number;

    constructor(client: Client, options: object) {
        this._client = client;
        this.firstConnectionMade = false;
        this.wasReconnected = false;

        this.socket = SocketCluster.connect(options);
        this.socket.on("connect", () => {
            this.handleConnect();
        });

        this.socket.on("error", (error) => {
            this.handleError(error);
        });

        this.socket.on("disconnect", () => {
            this.onDisconnect();
        });

        // Server Messages
        this.socket.on("set information", (info) => {
            this.handleSetInformation(info);
        });

        this.socket.on("discussions list", (discussions) => {
            if (this.isGuest) {
                this.systemChannel = this.socket.subscribe(`System:${this._client.systemName}`);
            }
            this.handleDiscussionsList(JSON.parse(discussions));
        });

        this.socket.on("discussion alert list", (discussionAlertList) => {
            this.handleDiscussionAlertList(discussionAlertList.list);
        });

        this.socket.on("discussion users", (discussionUsers) => {
            this.handleDiscussionUsers(discussionUsers);
        });

        this.socket.on("discussion messages", (discussionMessages) => {
            this.handleDiscussionMessages(discussionMessages);
        });

        this.socket.on("users online", (usersOnline) => {
            this.handleUsersOnline(JSON.parse(usersOnline));
        });

        this.socket.on("terraria users online", (terrariaUsersOnline) => {
            terrariaUsersOnline = JSON.parse(terrariaUsersOnline);
            this.handleTerrariaUsersOnline(terrariaUsersOnline);
        });

        this.socket.on("discussion messages history", (discussionMessagesHistory) => {
            this.handleDiscussionMessagesHistory(discussionMessagesHistory);
        });

        this.socket.on("chat message", (chatMessage) => {
            this.handleChatMessage(chatMessage);
        });

        this.socket.on("chat edit queue", (editQueue) => {
            this.handleChatEditQueue(editQueue);
        });

        this.socket.on("chat message denied", (chatMessageDenied) => {
            this.handleChatMessageDenied(chatMessageDenied);
        });

        this.socket.on("search results", (searchResults) => {
            this.handleSearchResults(JSON.parse(searchResults));
        });

        this.socket.on("discussion message surrounding history", (deepHistory) => {
            deepHistory.messages = JSON.parse(deepHistory.messages);
            this.handleDeepHistory(deepHistory);
        });

        this.socket.on("discussion messages deephistory", (deepHistoryOlder) => {
            deepHistoryOlder.messages = JSON.parse(deepHistoryOlder.messages);
            this.handleDeepHistoryOlder(deepHistoryOlder);
        });

        this.socket.on("discussion messages deephistory:after", (deepHistoryNewer) => {
            deepHistoryNewer.messages = JSON.parse(deepHistoryNewer.messages);
            this.handleDeepHistoryNewer(deepHistoryNewer);
        });

        this.socket.on("search results:names", (searchUserResults) => {
            this.handleSearchUserResults(JSON.parse(searchUserResults));
        });
    }

    private handleConnect(): void {
        if (!this.firstConnectionMade) {
            this.firstConnectionMade = true;
        } else {
            this.handleReconnect();
        }
    }

    private handleReconnect(): void {
        // Re-authenticate on reconnect
        if (this._client.session.length > 0) {
            this.sendInformationRequest(this._client.session);

            const currentDiscussion = this._client.currentDiscussion;
            if (typeof currentDiscussion !== "undefined") {
                this._client.switchDiscussionTo = currentDiscussion.id;
            }

            this.wasReconnected = true;
        }
    }

    private handleError(error: string): void {
        console.log(`Error with connection ${error}`);
    }

    private onDisconnect(): void {
        this.socket.unsubscribe(this._client.id);
        this.socket.unsubscribe(`System:${this._client.systemName}`);
        this.socket.unsubscribe(`global`);
    }

    public sendInformationRequest(session: string): void {
        this.socket.emit("session", session);
    }

    public sendGuestRequest(systemName: string): void {
        this.isGuest = true;
        this._client.systemName = systemName;
        this.socket.emit("guest", systemName);
    }

    private handleMessage(data: RawMessage | any): void {
        if (data.socketID && data.socketID === this.socket.id) {
            return;
        }

        switch (data.msgType) {
            /*// A list of usernames pertaining to an add-discussion-user input field (auto-complete)
            case 'search_results:names':
                handleSearchResults_names(JSON.parse(data));
                break;
            */

            // A list of messages pertaining to a search request
            case "search results":
                this.handleSearchResults(JSON.parse(data));
                break;

            // An addition to a discussions list of messages
            case "chat message":
                this.handleChatMessage(data);
                break;

            case "chat message revoked":
                this.handleChatMessageRevoked(data);
                break;

            // A queue of changes to an exising in-progress message
            case "chat edit queue":
                this.handleChatEditQueue(data);
                break;

            // An addition to the Phase Users online list
            case "user online":
                this.handleUserOnline(data);
                break;

            // A removal from the Phase Users online list
            case "user offline":
                this.handleUserOffline(data);
                break;

            // A response to a new discussion request
            case "new discussion:response":
                this.handleNewDiscussionResponse(data);
                break;

            // An addition of a discussions listing on the client
            case "new discussion":
                this.handleNewDiscussion(data);
                break;

            // A removal of a discussions listing on the client
            case "remove discussion":
                this.handleRemoveDiscussion(data);
                break;

            // An addition of a user to the list of users in
            // a discussion
            case "discussion user add":
                this.handleDiscussionUserAdd(data);
                break;

            // A removal of a user from the list of users
            // in a discussion
            case "discussion user remove":
                this.handleDiscussionUserRemove(data);
                break;

            // An addition of mod status to a user in
            // a discussion
            case "discussion user mod":
                this.handleDiscussionUserPromote(data);
                break;

            // A removal of mod status from a user in
            // a discussion
            case "discussion user demote":
                this.handleDiscussionUserDemote(data);
                break;

            /*// A rename to a discussion
            case "discussion rename":
                renameDiscussion(data);
                break; */

            case "terraria users online":
                this.handleTerrariaUsersOnline(data);
                break;

            // An addition of an item in the
            // Terraria Users List
            case "terraria join":
                this.handleTerrariaJoin(data);
                break;

            // A removal of an item in the
            // Terraria Users list
            case "terraria leave":
                this.handleTerrariaLeave(data);
                break;

            // A name change to a item in the
            // Terraria Users list
            case "terraria changename":
                this.handleTerrariaChangeName(data);
                break;

            // A user avatar update
            case "user avatar":
                this.userAvatarUpdate(data);
                break;

            /*
            // User has been requested to join
            // a call
            case "call join request":
                callJoinRequest(data);
                break;

            // Response to accept/denying call
            case "call join response":
                callJoinResponse(data);
                break;

            // User joined call group
            case "call group user add":
                callGroupUserAdd(data);
                break;

            // User left call group
            case "call group user remove":
                callGroupUserRemove(data);
                break;*/
        }
    }

    /* Message Handlers */

    private handleSetInformation(info: SetInformation) {
        this._client.id = info.userID;
        this._client.username = info.name;
        this._client.systemName = info.systemName;
        this._client.avatar = info.avatar;

        // Setup channels for listening now that we have auth'ed with Server
        this.userChannel = this.socket.subscribe(info.userID);
        this.systemChannel = this.socket.subscribe(`System:${info.systemName}`);
        this.globalChannel = this.socket.subscribe(`global`);

        if (!this.wasReconnected) {
            this.userChannel.watch((data) => {
                this.handleMessage(data);
            });

            this.systemChannel.watch((data) => {
                this.handleMessage(data);
            });

            this.globalChannel.watch((data) => {
                this.handleMessage(data);
            });
        }
    }

    private handleDiscussionsList(discussions: Discussions): void {
        this._client.handleDiscussionList(discussions);
    }

    private handleDiscussionAlertList(discussionAlertList: DiscussionAlertList): void {
        this._client.handleDiscussionAlertList(discussionAlertList);
    }

    private handleDiscussionUsers(discussionUsers: DiscussionUsers): void {
        const discussionID = discussionUsers.discID;
        const users = discussionUsers.users[1];
        const userList: User[] = [];
        const modList: BooleanHash = {};

        let user: User;
        for (const discussionUser of users) {
            if (this._client.phaseUsers[discussionUser.userID]) {
                user = this._client.phaseUsers[discussionUser.userID];
            } else {
                user = new User(discussionUser.userID,
                    discussionUser.name,
                    discussionUser.systemName,
                    discussionUser.avatar,
                    this._client.systemName,
                    UserStatus.Offline);
                this._client.addPhaseUser(user);
            }

            userList.push(user);

            if (discussionUser.mod) {
                modList[user.id.toString()] = true;
            }
        }

        const discussion = this._client.discussions[discussionID];
        this._client.handleDiscussionUsers(discussion, userList, modList);
    }

    private handleDiscussionMessages(discussionMessages: DiscussionMessages): void {
        const discussionID = discussionMessages.discID;
        const messages: DiscussionMessage[] = JSON.parse(discussionMessages.messages);
        const oldestId = discussionMessages.oldestID;
        const messageList: Message[] = [];
        const discussion = this._client.discussions[discussionID];

        if (!discussion) {
            return;
        }

        let user: User | null = null;
        let username: string;
        let guestname: string;
        for (const rawMessage of messages) {
            if (this._client.phaseUsers[rawMessage.userID]) {
                user = this._client.phaseUsers[rawMessage.userID];
            } else {
                if (!rawMessage.guest) {
                    user = new User(rawMessage.userID,
                        rawMessage.username,
                        rawMessage.systemName,
                        rawMessage.avatar,
                        this._client.systemName,
                        UserStatus.Offline);
                    this._client.addPhaseUser(user);
                }
            }

            // Server doesn't send message ID so for now it has to be set to a default
            if (rawMessage.guest) {
                username = "";
                guestname = rawMessage.username;
            } else {
                username = rawMessage.username;
                guestname = "";
            }

            if (this._client.configuration.useAndDisplayJoinLeaveMessages
                || rawMessage.userID !== System.joinLeaveMessageUserId
                || rawMessage.tag === null) {
                const message = new Message(rawMessage.ID,
                    rawMessage.userID,
                    rawMessage.avatar,
                    username, guestname,
                    rawMessage.content,
                    rawMessage.timestamp,
                    rawMessage.systemName,
                    rawMessage.tag || "",
                    rawMessage.tagcolour || "");
                messageList.push(message);
                if (typeof rawMessage.IP !== "undefined" && rawMessage.IP !== null) {
                    message.ip = rawMessage.IP;
                }
            }

            const oldestIdReceived = discussion.oldestMessageIdReceived;
            if (oldestIdReceived === -1 || rawMessage.ID < oldestIdReceived) {
                discussion.oldestMessageIdReceived = rawMessage.ID;
            }
            user = null;
        }

        discussion.messages = messageList;

        if (this._client.currentDiscussion === discussion) {
            this._client.completeDiscussionSwitch(discussion);
        }
    }

    private handleDiscussionMessagesHistory(discussionMessagesHistory: DiscussionMessages): void {
        const discussionID = discussionMessagesHistory.discID;
        const messages: DiscussionMessage[] = JSON.parse(discussionMessagesHistory.messages);
        const oldestId = discussionMessagesHistory.oldestID;
        const messageList: Message[] = [];
        const discussion = this._client.discussions[discussionID];

        if (!discussion) {
            return;
        }

        let user: User | null = null;
        let username: string;
        let guestname: string;
        for (const message of messages.reverse()) {
            if (this._client.phaseUsers[message.userID]) {
                user = this._client.phaseUsers[message.userID];
            } else {
                if (!message.guest) {
                    user = new User(message.userID,
                                    message.username,
                                    message.systemName,
                                    message.avatar,
                                    this._client.systemName,
                                    UserStatus.Offline);
                    this._client.addPhaseUser(user);
                }
            }

            // Server doesn't send message ID so for now it has to be set to a default
            if (message.guest) {
                username = "";
                guestname = message.username;
            } else {
                username = message.username;
                guestname = "";
            }

            if (this._client.configuration.useAndDisplayJoinLeaveMessages
                || message.userID !== System.joinLeaveMessageUserId
                || message.tag === null) {
                const newMessage = new Message(message.ID,
                    message.userID,
                    message.avatar,
                    username, guestname,
                    message.content,
                    message.timestamp,
                    message.systemName,
                    message.tag || "",
                    message.tagcolour || "");

                if (typeof message.IP !== "undefined" && message.IP !== null) {
                    newMessage.ip = message.IP;
                }
                messageList.unshift(newMessage);
                discussion.messages.unshift(newMessage);
            }

            const oldestIdReceived = discussion.oldestMessageIdReceived;
            if (oldestIdReceived === -1 || message.ID < oldestIdReceived) {
                discussion.oldestMessageIdReceived = message.ID;
            }
            user = null;
        }

        discussion.waitingForHistory = false;
        this._client.onHistoryReceived(discussion);
    }

    private handleChatMessage(message: ChatMessage): void {
        const discussionId = message.discID;
        let user: User | null = null;
        let username: string;
        let guestname: string;
        const discussion = this._client.discussions[discussionId];

        if (!discussion) {
            return;
        }

        if (this._client.phaseUsers[message.userID]) {
            user = this._client.phaseUsers[message.userID];
        } else {
            if (!message.guest) {
                user = new User(message.userID,
                    message.username,
                    message.systemName,
                    message.avatar,
                    this._client.systemName,
                    UserStatus.Offline);
                this._client.addPhaseUser(user);
            }
        }

        // Server doesn't send message ID so for now it has to be set to a default
        if (message.guest) {
            username = "";
            guestname = message.username;
        } else {
            username = message.username;
            guestname = "";
        }

        const chatMessage = new Message(this._client.getNewMessageId(),
            message.userID,
            message.avatar,
            username,
            guestname,
            message.msg,
            message.timestamp,
            message.systemName,
            message.tag || "",
            message.tagcolour || "");
        if (typeof message.IP !== "undefined" && message.IP !== null) {
            chatMessage.ip = message.IP;
        }
        this._client.handleChatMessage(discussion, chatMessage);
    }

    private handleChatMessageRevoked(chatMessageRevoked: ChatMessageRevoked): void {
        this._client.handleChatMessageRevoked(chatMessageRevoked);
    }

    private handleChatMessageDenied(chatMessageDenied: ChatMessageDenied): void {
        this._client.handleChatMessageDenied(chatMessageDenied);
    }

    private handleChatEditQueue(editQueue: EditQueue): void {
        const discussionId = editQueue.discID;
        const edits = editQueue.queue;
        const userId = editQueue.userID;
        const username = editQueue.username;
        const systemName = editQueue.systemName;
        const discussion = this._client.discussions[discussionId];

        if (!discussion) {
            return;
        }

        let messageContent = "";
        const chatUser: User | undefined = this._client.getPhaseUser(userId);

        if (typeof chatUser === "undefined") {
            return;
        }

        const storedLiveTyping = discussion.getLiveTypingMessage(userId);

        // If existing content stored, used that
        if (typeof storedLiveTyping !== "undefined") {
            messageContent = storedLiveTyping.content.asIs();
        }

        // Apply edits
        for (const item of edits) {
            if (item.t) {
                messageContent = messageContent.slice(0, item.pos) + item.text + messageContent.slice(item.pos);
            } else {
                messageContent = messageContent.slice(0, item.pos) + messageContent.slice(item.pos + item.len);
            }
        }

        // Create a new message if none stored, or update existing
        if (typeof storedLiveTyping === "undefined") {
            if (messageContent.trim().length > 0) {
                discussion.setLiveTypingMessages(userId, new Message(this._client.getNewMessageId(),
                    userId,
                    chatUser.avatar,
                    chatUser.name,
                    "",
                    messageContent,
                    Date.now() / 1000,
                    systemName,
                    "",
                    ""));
                this._client.handleNewLiveTyping(discussion, discussion.getLiveTypingMessage(userId) as Message);
            }
        } else {
            if (messageContent.trim().length > 0) {
                discussion.updateLiveTypingMessageContent(userId, messageContent);
                this._client.handleUpdateLiveTyping(discussion, discussion.getLiveTypingMessage(userId) as Message);
            } else {
                discussion.removeLiveTypingMessage(userId);
                this._client.handleRemoveLiveTyping(discussion, userId);
            }
        }
    }

    /**
     * Handles when a user comes online
     *
     * @param userOnline The user who has come online
     */
    private handleUserOnline(userOnline: UserOnline): void {
        let phaseUser = this._client.getPhaseUser(userOnline.userID);
        if (!phaseUser) {
            phaseUser = new User(userOnline.userID,
                userOnline.name,
                userOnline.systemName,
                userOnline.avatar,
                this._client.systemName,
                UserStatus.Online);
        } else if (phaseUser.avatar.length === 0) {
            phaseUser.avatar = userOnline.avatar;
        }

        this._client.handleUserOnline(phaseUser);
    }

    /**
     * Handles when a user goes offline
     *
     * @param userOffline The user who has gone offline
     */
    private handleUserOffline(userOffline: UserOffline): void {
        let phaseUser = this._client.getPhaseUser(userOffline.userID);
        if (!phaseUser) {
            phaseUser = new User(userOffline.userID, userOffline.name, userOffline.systemName, "", this._client.systemName, UserStatus.Online);
        }

        this._client.handleUserOffline(phaseUser);
    }

    /**
     * Handles when the discussion we created was successful
     *
     * @param newDiscussionResponse The info about the new discussion
     */
    private handleNewDiscussionResponse(newDiscussionResponse: NewDiscussionResponse): void {
        const recentMessage = new Message(this._client.getNewMessageId(), 0, "", "", "", newDiscussionResponse.lastMessage, 0, "", "", "");
        this._client.handleNewDiscussion(new Discussion(+newDiscussionResponse.discID, newDiscussionResponse.name, -1, [], recentMessage));
        this._client.switchDiscussion(+newDiscussionResponse.discID);
    }

    /**
     * Handles when this client is added to a new discussion
     *
     * @param newDiscussion The info about the new discussion
     */
    private handleNewDiscussion(newDiscussion: NewDiscussion): void {
        const recentMessage = new Message(this._client.getNewMessageId(), 0, "", "", "", newDiscussion.lastMessage, 0, "", "", "");
        this._client.handleNewDiscussion(new Discussion(+newDiscussion.discID, newDiscussion.discussionName, -1, [], recentMessage));
    }

    /**
     * Handles when this client is removed from a discussion
     *
     * @param removeDiscussion The info about what discussion they were removed from
     */
    private handleRemoveDiscussion(removeDiscussion: RemoveDiscussion): void {
        this._client.handleRemoveDiscussion(+removeDiscussion.discID);
    }

    /**
     * Handles when a user is added to a discussion we are a part of
     *
     * @param discussionUserAdd The info about who was added to what discussion
     */
    private handleDiscussionUserAdd(discussionUserAdd: DiscussionUserAdd): void {
        this._client.handleDiscussionUserAdd(discussionUserAdd);
    }

    /**
     * Handles when a user is removed from a discussion we are a part of
     *
     * @param discussionUserRemove The info about who was removed from what discussion
     */
    private handleDiscussionUserRemove(discussionUserRemove: DiscussionUserRemove): void {
        this._client.handleDiscussionUserRemove(discussionUserRemove);
    }

    /**
     * Handles when a user is promoted to moderator in a discussion
     *
     * @param discussionUserPromote The info about who was promoted
     */
    private handleDiscussionUserPromote(discussionUserPromote: DiscussionUserPromote): void {
        this._client.handleDiscussionUserPromote(discussionUserPromote);
    }

    /**
     * Handles when a user is demoted from moderator in a discussion
     *
     * @param discussionUserPromote The info about who was demoted
     */
    private handleDiscussionUserDemote(discussionUserDemote: DiscussionUserDemote): void {
        this._client.handleDiscussionUserDemote(discussionUserDemote);
    }

    /**
     * Puts the users online into the display list and adds them to the client list
     *
     * @param usersOnline The list of phase users online
     */
    private handleUsersOnline(usersOnline: UsersOnline): void {
        const users: User[] = [];
        for (const user of usersOnline) {
            users.push(new User(user.UserID, user.name, user.systemName, user.Avatar, this._client.systemName, UserStatus.Online));
        }

        this._client.handleUsersOnline(users);
    }

    /**
     * Handles when the list of terraria users is received
     *
     * @param terrariaUsersOnline The list of terraria users online
     */
    private handleTerrariaUsersOnline(terrariaUsersOnline: TerrariaUsersOnline): void {
        this._client.handleTerrariaUsers(terrariaUsersOnline);
    }

    /**
     * Handles when a terraria user joins a server
     *
     * @param joinInfo The information about who joined
     */
    private handleTerrariaJoin(joinInfo: TerrariaJoinLeave): void {
        this._client.handleTerrariaJoin(joinInfo.username, joinInfo.tagColour);
    }

    /**
     * Handles when a terraria user leaves a server
     *
     * @param leaveInfo The information about who left
     */
    private handleTerrariaLeave(leaveInfo: TerrariaJoinLeave): void {
        this._client.handleTerrariaLeave(leaveInfo.username);
    }

    /**
     * Handles when a terraria user changes their name
     *
     * @param changeNameInfo Information about who changed their username
     */
    private handleTerrariaChangeName(changeNameInfo: TerrariaChangeName): void {
        this._client.handleTerrariaChangeName(changeNameInfo.oldName, changeNameInfo.newName);
    }

    /**
     * Handles when a user updates their avatar
     *
     * @param userAvatarUpdate The update information
     */
    private userAvatarUpdate(userAvatarUpdate: UserAvatarUpdate): void {
        this._client.handleUserAvatarUpdate(userAvatarUpdate);
    }

    /**
     * Handles the search results of a search
     *
     * @param searchResults The search results
     */
    private handleSearchResults(searchResults: SearchResults): void {
        this._client.handleSearchResults(searchResults);
    }

    /**
     * Handles the surround history of a message
     *
     * @param deepHistory The surrounding history of a message
     */
    private handleDeepHistory(deepHistory: DeepHistoryResults): void {
        this._client.handleDeepHistory(deepHistory);
    }

    /**
     * Handles the older deep history of a message
     *
     * @param deepHistoryOlder The older deep history of a message
     */
    private handleDeepHistoryOlder(deepHistoryOlder: DeepHistoryOlderResults): void {
        this._client.handleDeepHistoryOlder(deepHistoryOlder);
    }

    /**
     * Handles the newer deep history of a message
     *
     * @param deepHistoryNewer The newer deep history of a message
     */
    private handleDeepHistoryNewer(deepHistoryNewer: DeepHistoryNewerResults): void {
        this._client.handleDeepHistoryNewer(deepHistoryNewer);
    }

    /**
     * Handles the search results for a user
     *
     * @param searchUserResults The results of the user search
     */
    private handleSearchUserResults(searchUserResults: SearchUserResults): void {
        this._client.handleSearchUserResults(searchUserResults);
    }

    /* Message Requests */

    public requestDiscussionDetails(discussionId: number, includeJoinLeave: boolean): void {
        this.socket.emit("discussion users", `${discussionId}`);
        this.socket.emit("discussion messages", {
            discID: discussionId,
            includeJoinLeave
        });
    }

    public sendChatMessage(discussionId: number, localMessageId: number, text: string): void {
        this.socket.emit("chat message", {
            ID: localMessageId,
            discID: discussionId,
            msg: text
        });
    }

    public sendEditQueue(discussionId: number, editQueue: ChatEditQueue): void {
        this.socket.emit("chat edit queue", {
            queue: editQueue,
            discID: discussionId
        });
    }

    public requestDiscussionHistory(discussion: Discussion): void {
        if (!discussion.waitingForHistory) {
            discussion.waitingForHistory = true;
            this.socket.emit("discussion messages history", {
                discID: discussion.id,
                oldestID: discussion.oldestMessageIdReceived
            });
        }
    }

    /**
     * Sends an update for whether alerts are enabled for a particular discussion
     */
    public sendAlertsEnabledUpdate(discussionId: number, enabled: boolean): void {
        this.socket.emit("setting-change_alert-discussion", {
            discID: discussionId,
            enabled
        });
    }

    /**
     * Sends a request for search results for the given terms
     *
     * @param discussionId The discussion id
     * @param terms The search terms
     */
    public requestSearchResults(discussionId: number, terms: string, oldestId?: number, username?: string, systemName?: string): void {
        this.socket.emit("search discussion messages", {
            discID: discussionId,
            terms,
            includeJoinLeaveMessages: this._client.configuration.useAndDisplayJoinLeaveMessages,
            username,
            highestID: oldestId,
            systemName
        });
    }

    /**
     * Requests the messages surrounding a given message (id) in a discussion
     *
     * @param discussionId The discussion id of the message
     * @param messageId The message id of the message
     */
    public requestSurroundingHistory(messageId: number): void {
        this.socket.emit("discussion message surrounding history", {
            messageID: messageId,
            includeJoinLeaveMessages: this._client.configuration.useAndDisplayJoinLeaveMessages
        });
    }

    /**
     * Requests the older messages than a given message (id) in a deep history list
     *
     * @param discussionId The discussion id of the message
     * @param oldestId The message id of the message
     */
    public requestDeepHistoryOlder(discussionId: number, oldestId: number): void {
        this.socket.emit("discussion messages deephistory", {
            discID: discussionId,
            oldestID: oldestId,
            includeJoinLeaveMessages: this._client.configuration.useAndDisplayJoinLeaveMessages
        });
    }

    /**
     * Requests the newer messages than a given message (id) in a deep history list
     *
     * @param discussionId The discussion id of the message
     * @param newestId The message id of the message
     */
    public requestDeepHistoryNewer(discussionId: number, newestId: number): void {
        this.socket.emit("discussion messages deephistory:after", {
            discID: discussionId,
            newestID: newestId,
            includeJoinLeaveMessages: this._client.configuration.useAndDisplayJoinLeaveMessages
        });
    }

    /**
     * Sends a rename update for a discussion
     *
     * @param discussionId The id of the discussion to rename
     * @param name The name to update to
     */
    public sendDiscussionRename(discussionId: number, name: string): void {
        this.socket.emit("discussion rename", {
            discID: discussionId,
            name
        });
    }

    /**
     * Requests the creation of a new discussion
     *
     * @param discussionName The name of the new discussion
     */
    public requestCreateDiscussion(discussionName: string): void {
        this.socket.emit("discussion add", discussionName);
    }

    /**
     * Requests the addition of a user to a discussion
     *
     * @param discussionId The id of the discussion to add the user to
     * @param username The username of the user to add
     * @param systemName The system name of the user to add
     */
    public requestAddDiscussionUser(discussionId: number, username: string, systemName: string): void {
        this.socket.emit("discussion user add", {
            discID: discussionId,
            username,
            systemName
        });
    }

    /**
     * Requests to leave a particular discussion
     *
     * @param discussionId The discussion id of the discussion to leave
     */
    public requestLeaveDiscussion(discussionId: number): void {
        this.socket.emit("discussion user leave", discussionId.toString());
    }

    /**
     * Requests a removal of a particular user from a discussion
     *
     * @param discussionId The discussion id of the discussion to remove the user from
     * @param username The username of the user to remove
     * @param systemName The system name of the user to remove
     */
    public requestRemoveDiscussionUser(discussionId: number, username: string, systemName: string): void {
        this.socket.emit("discussion user remove", {
            discID: discussionId,
            username,
            systemName
        });
    }

    /**
     * Requests a promotion of an unprivilged user in a discussion
     *
     * @param discussionId The discussion id of the user to promote
     * @param username The username of the user to promote
     * @param systemName The system name of the user to promote
     */
    public requestPromoteDiscussionUser(discussionId: number, username: string, systemName: string): void {
        this.socket.emit("discussion user mod", {
            discID: discussionId,
            username,
            systemName
        });
    }

    /**
     * Requests a demotion of a privilged user in a discussion
     *
     * @param discussionId The discussion id of the user to demote
     * @param username The username of the user to demote
     * @param systemName The system name of the user to demote
     */
    public requestDemoteDiscussionUser(discussionId: number, username: string, systemName: string): void {
        this.socket.emit("discussion user demote", {
            discID: discussionId,
            username,
            systemName
        });
    }

    /**
     * Requests an autocomplete list for an incomplete username
     *
     * @param terms The search terms for the username
     */
    public requestUsernameAutocomplete(terms: string): void {
        this.socket.emit("search autocomplete username", {
            terms
        });
    }
}

export default Network;
