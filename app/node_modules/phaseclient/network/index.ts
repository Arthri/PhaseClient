import Client from "phaseclient/client";
import Discussion from "phaseclient/discussion";
import { BooleanHash, UserHash } from "phaseclient/hash";
import Message from "phaseclient/message";
import Channel from "phaseclient/network/channel";
import RawMessage from "phaseclient/network/rawmessage";
import Socket from "phaseclient/network/socket";
import User from "phaseclient/user";
import ChatEditQueue from "phasecore/editqueue";
import ChatMessage from "phasecore/messagetypes/chatmessage";
import ChatMessageDenied from "phasecore/messagetypes/chatmessagedenied";
import ChatMessageRevoked from "phasecore/messagetypes/chatmessagerevoked";
import DiscussionAlertList from "phasecore/messagetypes/discussionalertlist";
import { DiscussionMessage, DiscussionMessages } from "phasecore/messagetypes/discussionmessages";
import { Discussion as ReceivedDiscussion, Discussions } from "phasecore/messagetypes/discussions";
import DiscussionUsers from "phasecore/messagetypes/discussionusers";
import EditQueue from "phasecore/messagetypes/editqueue";
import NewDiscussion from "phasecore/messagetypes/newdiscussion";
import RemoveDiscussion from "phasecore/messagetypes/removediscussion";
import SetInformation from "phasecore/messagetypes/setinformation";
import TerrariaChangeName from "phasecore/messagetypes/terrariachangename";
import TerrariaJoinLeave from "phasecore/messagetypes/terrariajoinleave";
import TerrariaUsersOnline from "phasecore/messagetypes/terrariausersonline";
import UserOffline from "phasecore/messagetypes/useroffline";
import UserOnline from "phasecore/messagetypes/useronline";
import UsersOnline from "phasecore/messagetypes/usersonline";
import System from "phasecore/system";
import UserStatus from "phasecore/userstatus";
import * as SocketCluster from "socketcluster-client";

class Network {
    private socket: Socket;
    private client: Client;
    private userChannel: Channel;
    private systemChannel: Channel;
    private globalChannel: Channel;
    private firstConnectionMade: boolean;
    private wasReconnected: boolean;

    // Used to identify which message was rejected
    private chatSequenceId: number;

    constructor(client: Client, options: object) {
        this.client = client;
        this.firstConnectionMade = false;
        this.wasReconnected = false;

        this.socket = SocketCluster.connect(options);
        this.socket.on("connect", () => {
            this.handleConnect();
        });

        this.socket.on("error", (error) => {
            this.handleError(error);
        });

        this.socket.on("disconnect", () => {
            this.onDisconnect();
        });

        // Server Messages
        this.socket.on("set information", (info) => {
            this.handleSetInformation(info);
        });

        this.socket.on("discussions list", (discussions) => {
            this.handleDiscussionsList(JSON.parse(discussions));
        });

        this.socket.on("discussion alert list", (discussionAlertList) => {
            this.handleDiscussionAlertList(discussionAlertList.list);
        });

        this.socket.on("discussion users", (discussionUsers) => {
            this.handleDiscussionUsers(discussionUsers);
        });

        this.socket.on("discussion messages", (discussionMessages) => {
            this.handleDiscussionMessages(discussionMessages);
        });

        this.socket.on("users online", (usersOnline) => {
            this.handleUsersOnline(JSON.parse(usersOnline));
        });

        this.socket.on("terraria users online", (terrariaUsersOnline) => {
            terrariaUsersOnline = JSON.parse(terrariaUsersOnline);
            this.handleTerrariaUsersOnline(terrariaUsersOnline);
        });

        this.socket.on("discussion messages history", (discussionMessagesHistory) => {
            this.handleDiscussionMessagesHistory(discussionMessagesHistory);
        });

        this.socket.on("chat message", (chatMessage) => {
            this.handleChatMessage(chatMessage);
        });

        this.socket.on("chat message denied", (chatMessageDenied) => {
            this.handleChatMessageDenied(chatMessageDenied);
        });
    }

    private handleConnect(): void {
        if (!this.firstConnectionMade) {
            this.firstConnectionMade = true;
        } else {
            this.handleReconnect();
        }
    }

    private handleReconnect(): void {
        // Re-authenticate on reconnect
        if (this.client.getSession().length > 0) {
            this.sendInformationRequest(this.client.getSession());

            const currentDiscussion = this.client.getCurrentDiscussion();
            if (typeof currentDiscussion !== "undefined") {
                this.client.switchDiscussionTo = currentDiscussion.getId();
            }

            this.wasReconnected = true;
        }
    }

    private handleError(error: string): void {
        console.log(`Error with connection ${error}`);
    }

    private onDisconnect(): void {
        this.socket.unsubscribe(this.client.getId());
        this.socket.unsubscribe(`System:${this.client.getSystemName()}`);
        this.socket.unsubscribe(`global`);
    }

    public sendInformationRequest(session: string): void {
        this.socket.emit("session", session);
    }

    private handleMessage(data: RawMessage | any): void {
        if (data.socketID && data.socketID === this.socket.id) {
            return;
        }

        switch (data.msgType) {
            /*// A list of usernames pertaining to an add-discussion-user input field (auto-complete)
            case 'search_results:names':
                handleSearchResults_names(JSON.parse(data));
                break;

            // A list of messages pertaining to a search request
            case 'search results':
                handleSearchResults(JSON.parse(data));
                break;
            */
            // An addition to a discussions list of messages
            case "chat message":
                this.handleChatMessage(data);
                break;

            case "chat message revoked":
                this.handleChatMessageRevoked(data);
                break;

             // A queue of changes to an exising in-progress message
            case "chat edit queue":
                this.handleChatEditQueue(data);
                break;

            // An addition to the Phase Users online list
            case "user online":
                this.handleUserOnline(data);
                break;

            // A removal from the Phase Users online list
            case "user offline":
                this.handleUserOffline(data);
                break;

            /*// A response to a new discussion request
            case "new discussion:response":
                newDiscussionResponse(data);
                break;*/

            // An addition of a discussions listing on the client
            case "new discussion":
                this.handleNewDiscussion(data);
                break;

            // A removal of a discussions listing on the client
            case "remove discussion":
                this.handleRemoveDiscussion(data);
                break;

            /*// An addition of a user to the list of users in
            // a discussion
            case "discussion user add":
                discussionUserAdd(data);
                break;

            // A removal of a user from the list of users
            // in a discussion
            case "discussion user remove":
                discussionUserRemove(data);
                break;

            // An addition of mod status to a user in
            // a discussion
            case "discussion user mod":
                discussionUserMod(data);
                break;

            // A removal of mod status from a user in
            // a discussion
            case "discussion user demote":
                discussionUserDemote(data);
                break;

            // A rename to a discussion
            case "discussion rename":
                renameDiscussion(data);
                break;*/

            case "terraria users online":
                this.handleTerrariaUsersOnline(data);
                break;

            // An addition of an item in the
            // Terraria Users List
            case "terraria join":
                this.handleTerrariaJoin(data);
                break;

            // A removal of an item in the
            // Terraria Users list
            case "terraria leave":
                this.handleTerrariaLeave(data);
                break;

            // A name change to a item in the
            // Terraria Users list
            case "terraria changename":
                this.handleTerrariaChangeName(data);
                break;

            /*// A user avatar update
            case "user avatar":
                userAvatar(data);
                break;

            // User has been requested to join
            // a call
            case "call join request":
                callJoinRequest(data);
                break;

            // Response to accept/denying call
            case "call join response":
                callJoinResponse(data);
                break;

            // User joined call group
            case "call group user add":
                callGroupUserAdd(data);
                break;

            // User left call group
            case "call group user remove":
                callGroupUserRemove(data);
                break;*/
        }
    }

    /* Message Handlers */

    private handleSetInformation(info: SetInformation) {
        this.client.setId(info.userID);
        this.client.setUsername(info.name);
        this.client.setSystemName(info.systemName);
        this.client.setAvatar(info.avatar);

        // Setup channels for listening now that we have auth'ed with Server
        this.userChannel = this.socket.subscribe(info.userID);
        this.systemChannel = this.socket.subscribe(`System:${info.systemName}`);
        this.globalChannel = this.socket.subscribe(`global`);

        if (!this.wasReconnected) {
            this.userChannel.watch((data) => {
                this.handleMessage(data);
            });

            this.systemChannel.watch((data) => {
                this.handleMessage(data);
            });

            this.globalChannel.watch((data) => {
                this.handleMessage(data);
            });
        }
    }

    private handleDiscussionsList(discussions: Discussions): void {
        this.client.handleDiscussionList(discussions);
    }

    private handleDiscussionAlertList(discussionAlertList: DiscussionAlertList): void {
        this.client.handleDiscussionAlertList(discussionAlertList);
    }

    private handleDiscussionUsers(discussionUsers: DiscussionUsers): void {
        const discussionID = discussionUsers.discID;
        const users = discussionUsers.users[1];
        const userList: User[] = [];
        const modList: BooleanHash = {};

        let user: User;
        for (const discussionUser of users) {
            if (this.client.getPhaseUsers()[discussionUser.userID]) {
                user = this.client.getPhaseUsers()[discussionUser.userID];
            } else {
                user = new User(discussionUser.userID,
                                discussionUser.name,
                                discussionUser.systemName,
                                discussionUser.avatar,
                                this.client.getSystemName(),
                                UserStatus.Offline);
                this.client.addPhaseUser(user);
            }

            userList.push(user);

            if (discussionUser.mod) {
                modList[user.getId()] = true;
            }
        }

        const discussion = this.client.getDiscussions()[discussionID];
        this.client.handleDiscussionUsers(discussion, userList, modList);
    }

    private handleDiscussionMessages(discussionMessages: DiscussionMessages): void {
        const discussionID = discussionMessages.discID;
        const messages: DiscussionMessage[] = JSON.parse(discussionMessages.messages);
        const oldestId = discussionMessages.oldestID;
        const messageList: Message[] = [];
        const discussion = this.client.getDiscussions()[discussionID];

        if (!discussion) {
            return;
        }

        let user: User | null = null;
        let username: string;
        let guestname: string;
        for (const message of messages) {
            if (this.client.getPhaseUsers()[message.userID]) {
                user = this.client.getPhaseUsers()[message.userID];
            } else {
                if (!message.guest) {
                    user = new User(message.userID,
                                    message.username,
                                    message.systemName,
                                    message.avatar,
                                    this.client.getSystemName(),
                                    UserStatus.Offline);
                    this.client.addPhaseUser(user);
                }
            }

            // Server doesn't send message ID so for now it has to be set to a default
            if (message.guest) {
                username = "";
                guestname = message.username;
            } else {
                username = message.username;
                guestname = "";
            }

            if (this.client.getConfiguration().useAndDisplayJoinLeaveMessages
                || message.userID !== System.joinLeaveMessageUserId
                || message.tag === null) {
                messageList.push(new Message(this.client.getNewMessageId(),
                        message.userID,
                        message.avatar,
                        username, guestname,
                        message.content,
                        message.timestamp,
                        message.systemName,
                        message.tag || "",
                        message.tagcolour || ""));
            }
            user = null;
        }

        discussion.setMessages(messageList);
        discussion.setOldestMessageIdReceived(oldestId);

        if (this.client.getCurrentDiscussion() === discussion) {
            this.client.completeDiscussionSwitch(discussion);
        }
    }

    private handleDiscussionMessagesHistory(discussionMessagesHistory: DiscussionMessages): void {
        const discussionID = discussionMessagesHistory.discID;
        const messages: DiscussionMessage[] = JSON.parse(discussionMessagesHistory.messages);
        const oldestId = discussionMessagesHistory.oldestID;
        const messageList: Message[] = [];
        const discussion = this.client.getDiscussions()[discussionID];

        if (!discussion) {
            return;
        }

        let user: User | null = null;
        let username: string;
        let guestname: string;
        for (const message of messages.reverse()) {
            if (this.client.getPhaseUsers()[message.userID]) {
                user = this.client.getPhaseUsers()[message.userID];
            } else {
                if (!message.guest) {
                    user = new User(message.userID,
                                    message.username,
                                    message.systemName,
                                    message.avatar,
                                    this.client.getSystemName(),
                                    UserStatus.Offline);
                    this.client.addPhaseUser(user);
                }
            }

            // Server doesn't send message ID so for now it has to be set to a default
            if (message.guest) {
                username = "";
                guestname = message.username;
            } else {
                username = message.username;
                guestname = "";
            }

            if (this.client.getConfiguration().useAndDisplayJoinLeaveMessages
                || message.userID !== System.joinLeaveMessageUserId
                || message.tag === null) {
                const newMessage = new Message(this.client.getNewMessageId(),
                    message.userID,
                    message.avatar,
                    username, guestname,
                    message.content,
                    message.timestamp,
                    message.systemName,
                    message.tag || "",
                    message.tagcolour || "");
                messageList.unshift(newMessage);
                discussion.getMessages().unshift(newMessage);
            }
            user = null;
        }

        discussion.setWaitingForHistory(false);
        discussion.setOldestMessageIdReceived(oldestId);
        this.client.onHistoryReceived(discussion);
    }

    private handleChatMessage(message: ChatMessage): void {
        const discussionId = message.discID;
        let user: User | null = null;
        let username: string;
        let guestname: string;
        const discussion = this.client.getDiscussions()[discussionId];

        if (!discussion) {
            return;
        }

        if (this.client.getPhaseUsers()[message.userID]) {
            user = this.client.getPhaseUsers()[message.userID];
        } else {
            if (!message.guest) {
                user = new User(message.userID,
                                message.username,
                                message.systemName,
                                message.avatar,
                                this.client.getSystemName(),
                                UserStatus.Offline);
                this.client.addPhaseUser(user);
            }
        }

        // Server doesn't send message ID so for now it has to be set to a default
        if (message.guest) {
            username = "";
            guestname = message.username;
        } else {
            username = message.username;
            guestname = "";
        }

        const chatMessage = new Message(this.client.getNewMessageId(),
            message.userID,
            message.avatar,
            username,
            guestname,
            message.msg,
            message.timestamp,
            message.systemName,
            message.tag || "",
            message.tagcolour || "");
        this.client.handleChatMessage(discussion, chatMessage);
    }

    private handleChatMessageRevoked(chatMessageRevoked: ChatMessageRevoked): void {
        this.client.handleChatMessageRevoked(chatMessageRevoked);
    }

    private handleChatMessageDenied(chatMessageDenied: ChatMessageDenied): void {
        this.client.handleChatMessageDenied(chatMessageDenied);
    }

    private handleChatEditQueue(editQueue: EditQueue): void {
        const discussionId = editQueue.discID;
        const edits = editQueue.queue;
        const userId = editQueue.userID;
        const username = editQueue.username;
        const systemName = editQueue.systemName;
        const discussion = this.client.getDiscussions()[discussionId];

        if (!discussion) {
            return;
        }

        let messageContent = "";
        const chatUser: User | undefined = this.client.getPhaseUser(userId);

        if (typeof chatUser === "undefined") {
            return;
        }

        const storedLiveTyping = discussion.getLiveTypingMessage(userId);

        // If existing content stored, used that
        if (typeof storedLiveTyping !== "undefined") {
            messageContent = storedLiveTyping.getContent().asIs();
        }

        // Apply edits
        for (const item of edits) {
            if (item.t) {
                messageContent = messageContent.slice(0, item.pos) + item.text + messageContent.slice(item.pos);
            } else {
                messageContent = messageContent.slice(0, item.pos) + messageContent.slice(item.pos + item.len);
            }
        }

        // Create a new message if none stored, or update existing
        if (typeof storedLiveTyping === "undefined") {
            if (messageContent.trim().length > 0) {
                discussion.setLiveTypingMessages(userId, new Message(this.client.getNewMessageId(),
                        userId,
                        chatUser.getAvatar(),
                        chatUser.getName(),
                        "",
                        messageContent,
                        Date.now() / 1000,
                        systemName,
                        "",
                        ""));
                this.client.handleNewLiveTyping(discussion, discussion.getLiveTypingMessage(userId) as Message);
            }
        } else {
            if (messageContent.trim().length > 0) {
                discussion.updateLiveTypingMessageContent(userId, messageContent);
                this.client.handleUpdateLiveTyping(discussion, discussion.getLiveTypingMessage(userId) as Message);
            } else {
                discussion.removeLiveTypingMessage(userId);
                this.client.handleRemoveLiveTyping(discussion, userId);
            }
        }
    }

    /**
     * Handles when a user comes online
     *
     * @param userOnline The user who has come online
     */
    private handleUserOnline(userOnline: UserOnline): void {
        let phaseUser = this.client.getPhaseUser(userOnline.userID);
        if (!phaseUser) {
            phaseUser = new User(userOnline.userID,
                userOnline.name,
                userOnline.systemName,
                userOnline.avatar,
                this.client.getSystemName(),
                UserStatus.Online);
        } else if (phaseUser.getAvatar().length === 0) {
            phaseUser.setAvatar(userOnline.avatar);
        }

        this.client.handleUserOnline(phaseUser);
    }

    /**
     * Handles when a user goes offline
     *
     * @param userOffline The user who has gone offline
     */
    private handleUserOffline(userOffline: UserOffline): void {
        let phaseUser = this.client.getPhaseUser(userOffline.userID);
        if (!phaseUser) {
            phaseUser = new User(userOffline.userID, userOffline.name, userOffline.systemName, "", this.client.getSystemName(), UserStatus.Online);
        }

        this.client.handleUserOffline(phaseUser);
    }

    /**
     * Handles when this client is added to a new discussion
     *
     * @param newDiscussion The info about the new discussion
     */
    private handleNewDiscussion(newDiscussion: NewDiscussion): void {
        const recentMessage = new Message(this.client.getNewMessageId(), 0, "", "", "", newDiscussion.lastMessage, 0, "", "", "");
        this.client.handleNewDiscussion(new Discussion(newDiscussion.discID, newDiscussion.discussionName, -1, [], recentMessage));
    }

    /**
     * Handles when this client is removed from a discussion
     *
     * @param removeDiscussion The info about what discussion they were removed from
     */
    private handleRemoveDiscussion(removeDiscussion: RemoveDiscussion): void {
        this.client.handleRemoveDiscussion(removeDiscussion.discID);
    }

    /**
     * Puts the users online into the display list and adds them to the client list
     *
     * @param usersOnline The list of phase users online
     */
    private handleUsersOnline(usersOnline: UsersOnline): void {
        const users: User[] = [];
        for (const user of usersOnline) {
            users.push(new User(user.UserID, user.name, user.systemName, user.Avatar, this.client.getSystemName(), UserStatus.Online));
        }

        this.client.handleUsersOnline(users);
    }

    /**
     * Handles when the list of terraria users is received
     *
     * @param terrariaUsersOnline The list of terraria users online
     */
    private handleTerrariaUsersOnline(terrariaUsersOnline: TerrariaUsersOnline): void {
        this.client.handleTerrariaUsers(terrariaUsersOnline);
    }

    /**
     * Handles when a terraria user joins a server
     *
     * @param joinInfo The information about who joined
     */
    private handleTerrariaJoin(joinInfo: TerrariaJoinLeave): void {
        this.client.handleTerrariaJoin(joinInfo.username, joinInfo.tagColour);
    }

    /**
     * Handles when a terraria user leaves a server
     *
     * @param leaveInfo The information about who left
     */
    private handleTerrariaLeave(leaveInfo: TerrariaJoinLeave): void {
        this.client.handleTerrariaLeave(leaveInfo.username);
    }

    /**
     * Handles when a terraria user changes their name
     *
     * @param changeNameInfo Information about who changed their username
     */
    private handleTerrariaChangeName(changeNameInfo: TerrariaChangeName): void {
        this.client.handleTerrariaChangeName(changeNameInfo.oldName, changeNameInfo.newName);
    }

    /* Message Requests */

    public requestDiscussionDetails(discussionId: number, includeJoinLeave: boolean): void {
        this.socket.emit("discussion users", `${discussionId}`);
        this.socket.emit("discussion messages", {
            discID: discussionId,
            includeJoinLeave
        });
    }

    public sendChatMessage(discussionId: number, localMessageId: number, text: string): void {
        this.socket.emit("chat message", {
            ID: localMessageId,
            discID: discussionId,
            msg: text
        });
    }

    public sendEditQueue(discussionId: number, editQueue: ChatEditQueue): void {
        this.socket.emit("chat edit queue", {
            queue: editQueue,
            discID: discussionId
        });
    }

    public requestDiscussionHistory(discussion: Discussion): void {
        if (!discussion.getWaitingForHistory()) {
            discussion.setWaitingForHistory(true);
            this.socket.emit("discussion messages history", {
                discID: discussion.getId(),
                oldestID: discussion.getOldestMessageIdReceived()
            });
        }
    }
}

export default Network;
