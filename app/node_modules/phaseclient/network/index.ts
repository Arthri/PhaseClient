import * as SocketCluster from 'socketcluster-client';
import Client from 'phaseclient/client';
import Socket from 'phaseclient/network/socket';
import Channel from 'phaseclient/network/channel';
import RawMessage from 'phaseclient/network/rawmessage';
import SetInformation from 'phasecore/messagetypes/setinformation';
import {Discussions, Discussion as ReceivedDiscussion} from 'phasecore/messagetypes/discussions';
import DiscussionUsers from 'phasecore/messagetypes/discussionusers';
import { DiscussionMessages, DiscussionMessage } from 'phasecore/messagetypes/discussionmessages';
import ChatMessage from 'phasecore/messagetypes/chatmessage';
import EditQueue from 'phasecore/messagetypes/editqueue';
import UsersOnline from 'phasecore/messagetypes/usersonline';
import UserOnline from 'phasecore/messagetypes/useronline';
import UserOffline from 'phasecore/messagetypes/useroffline';
import NewDiscussion from 'phasecore/messagetypes/newdiscussion';
import RemoveDiscussion from 'phasecore/messagetypes/removediscussion';
import TerrariaUsersOnline from 'phasecore/messagetypes/terrariausersonline';
import TerrariaJoinLeave from 'phasecore/messagetypes/terrariajoinleave';
import TerrariaChangeName from 'phasecore/messagetypes/terrariachangename';
import DiscussionAlertList from 'phasecore/messagetypes/discussionalertlist';
import Discussion from 'phaseclient/discussion';
import Message from 'phaseclient/message';
import User from 'phaseclient/user';
import { UserHash, BooleanHash } from 'phaseclient/hash';
import ChatEditQueue from 'phasecore/editqueue';
import System from 'phasecore/system';
import UserStatus from 'phasecore/userstatus';

class Network {
    private socket: Socket;
    private client: Client;
    private userChannel: Channel;
    private systemChannel: Channel;
    private globalChannel: Channel;
    private firstConnectionMade: boolean;
    private wasReconnected: boolean;

    // Used to identify which message was rejected
    private chatSequenceId: number;

    constructor(client: Client, options: Object) {
        this.client = client;
        this.firstConnectionMade = false;
        this.wasReconnected = false;

        this.socket = SocketCluster.connect(options);
        this.socket.on('connect', () => {
            this.handleConnect();
        });

        this.socket.on('error', (error) => {
            this.handleError(error);
        });

        this.socket.on('disconnect', () => {
            this.onDisconnect();
        });

        // Server Messages
        this.socket.on('set information', (info) => {
            this.handleSetInformation(info);
        });

        this.socket.on('discussions list', (discussions) => {
            this.handleDiscussionsList(JSON.parse(discussions));
        });

        this.socket.on('discussion alert list', (discussionAlertList) => {
            this.handleDiscussionAlertList(discussionAlertList.list);
        });

        this.socket.on('discussion users', (discussionUsers) => {
            this.handleDiscussionUsers(discussionUsers);
        })

        this.socket.on('discussion messages', (discussionMessages) => {
            this.handleDiscussionMessages(discussionMessages);
        });

        this.socket.on('users online', (usersOnline) => {
            this.handleUsersOnline(JSON.parse(usersOnline));
        });

        this.socket.on('terraria users online', (terrariaUsersOnline) => {
            terrariaUsersOnline = JSON.parse(terrariaUsersOnline);
            this.handleTerrariaUsersOnline(terrariaUsersOnline);
        });
    }

    private handleConnect(): void {
        if (!this.firstConnectionMade) {
            this.firstConnectionMade = true;
        } else {
            this.handleReconnect();
        }
    }

    private handleReconnect(): void {
        // Re-authenticate on reconnect
        if (this.client.getSession().length > 0) {
            this.sendInformationRequest(this.client.getSession());

            let currentDiscussion = this.client.getCurrentDiscussion();
            if (typeof currentDiscussion !== 'undefined') {
                this.client.switchDiscussionTo = currentDiscussion.getId();
            }

            this.wasReconnected = true;
        }
    }

    private handleError(error: string): void {
        console.log(`Error with connection ${error}`);
    }

    private onDisconnect(): void {
        this.socket.unsubscribe(this.client.getId());
        this.socket.unsubscribe(`System:${this.client.getSystemName()}`);
        this.socket.unsubscribe(`global`);
    }

    public sendInformationRequest(session: string): void {
        this.socket.emit('session', session);
    }

    private handleMessage(data: RawMessage | any): void {
        if (data.socketID && data.socketID == this.socket.id)
            return;

        switch (data.msgType) {
            /*// A list of usernames pertaining to an add-discussion-user input field (auto-complete)
            case 'search_results:names':
                handleSearchResults_names(JSON.parse(data));
                break;

            // A list of messages pertaining to a search request
            case 'search results':
                handleSearchResults(JSON.parse(data));
                break;
            */
            // An addition to a discussions list of messages
            case 'chat message':
                this.handleChatMessage(data);
                break;

            /*// A removal of a client-added message
            case 'chat message revoked':
                chatMessageRevoked(data);
                break;*/

             // A queue of changes to an exising in-progress message
            case 'chat edit queue':
                this.handleChatEditQueue(data);
                break;

            // An addition to the Phase Users online list
            case "user online":
                this.handleUserOnline(data);
                break;
            
            // A removal from the Phase Users online list
            case "user offline":
                this.handleUserOffline(data);
                break;

            /*// A response to a new discussion request
            case "new discussion:response":
                newDiscussionResponse(data);
                break;*/


            // An addition of a discussions listing on the client
            case "new discussion":
                this.handleNewDiscussion(data);
                break;

            // A removal of a discussions listing on the client
            case "remove discussion":
                this.handleRemoveDiscussion(data);
                break;

            /*// An addition of a user to the list of users in
            // a discussion
            case "discussion user add":
                discussionUserAdd(data);
                break;

            // A removal of a user from the list of users
            // in a discussion
            case "discussion user remove":
                discussionUserRemove(data);
                break;

            // An addition of mod status to a user in
            // a discussion
            case "discussion user mod":
                discussionUserMod(data);
                break;

            // A removal of mod status from a user in
            // a discussion
            case "discussion user demote":
                discussionUserDemote(data);
                break;

            // A rename to a discussion
            case "discussion rename":
                renameDiscussion(data);
                break;*/

            case "terraria users online":
                this.handleTerrariaUsersOnline(data);
                break;

            // An addition of an item in the
            // Terraria Users List
            case "terraria join":
                this.handleTerrariaJoin(data);
                break;

            // A removal of an item in the 
            // Terraria Users list
            case "terraria leave":
                this.handleTerrariaLeave(data);
                break;

            // A name change to a item in the
            // Terraria Users list
            case "terraria changename":
                this.handleTerrariaChangeName(data);
                break;

            /*// A user avatar update
            case "user avatar":
                userAvatar(data);
                break;

            // User has been requested to join
            // a call
            case "call join request":
                callJoinRequest(data);
                break;

            // Response to accept/denying call
            case "call join response":
                callJoinResponse(data);
                break;

            // User joined call group
            case "call group user add":
                callGroupUserAdd(data);
                break;

            // User left call group
            case "call group user remove":
                callGroupUserRemove(data);
                break;*/
        }
    }

    /* Message Handlers */

    private handleSetInformation(info: SetInformation) {
        this.client.setId(info.userID);
        this.client.setUsername(info.name);
        this.client.setSystemName(info.systemName);
        this.client.setAvatar(info.avatar);

        // Setup channels for listening now that we have auth'ed with Server
        this.userChannel = this.socket.subscribe(info.userID);
        this.systemChannel = this.socket.subscribe(`System:${info.systemName}`);
        this.globalChannel = this.socket.subscribe(`global`);

        if (!this.wasReconnected) {
            this.userChannel.watch((data) => {
                this.handleMessage(data); 
            });

            this.systemChannel.watch((data) => {
                this.handleMessage(data);
            });

            this.globalChannel.watch((data) => {
                this.handleMessage(data);
            });
        }
    }

    private handleDiscussionsList(discussions: Discussions): void {
        this.client.handleDiscussionList(discussions);
    }

    private handleDiscussionAlertList(discussionAlertList: DiscussionAlertList): void {
        this.client.handleDiscussionAlertList(discussionAlertList);
    }

    private handleDiscussionUsers(discussionUsers: DiscussionUsers): void {
        let discussionID = discussionUsers.discID;
        let users = discussionUsers.users[1];
        let userList: Array<User> = [];
        let modList: BooleanHash = {};
        
        let user: User;
        for (let i = 0; i < users.length; i++) {
            if (this.client.getPhaseUsers()[users[i].userID]) {
                user = this.client.getPhaseUsers()[users[i].userID];
            } else {
                user = new User(users[i].userID, users[i].name, users[i].systemName, users[i].avatar, this.client.getSystemName(), UserStatus.Offline);
                this.client.addPhaseUser(user);
            }
            
            userList.push(user);

            if (users[i].mod) {
                modList[user.getId()] = true;
            }
        }

        let discussion = this.client.getDiscussions()[discussionID];
        this.client.handleDiscussionUsers(discussion, userList, modList);
    }

    private handleDiscussionMessages(discussionMessages: DiscussionMessages): void {
        let discussionID = discussionMessages.discID;
        let messages: DiscussionMessage[] = JSON.parse(discussionMessages.messages);
        let oldestId = discussionMessages.oldestID;
        let messageList: Array<Message> = [];
        let discussion = this.client.getDiscussions()[discussionID];

        if (!discussion)
            return;

        let user: User | null = null;
        let username: string;
        let guestname: string;
        for (let i = 0; i < messages.length; i++) {
            if (this.client.getPhaseUsers()[messages[i].userID]) {
                user = this.client.getPhaseUsers()[messages[i].userID];
            } else {
                if (!messages[i].guest) {
                    user = new User(messages[i].userID, messages[i].username, messages[i].systemName, messages[i].avatar, this.client.getSystemName(), UserStatus.Offline);
                    this.client.addPhaseUser(user);
                }
            }

            // Server doesn't send message ID so for now it has to be set to a default
            if (messages[i].guest) {
                username = "";
                guestname = messages[i].username;
            } else {
                username = messages[i].username;
                guestname = "";
            }

            if (this.client.getConfiguration().useAndDisplayJoinLeaveMessages || messages[i].userID !== System.joinLeaveMessageUserId || messages[i].tag == null) {
                messageList.push(new Message(this.client.getNewMessageId(), messages[i].userID, messages[i].avatar, username, guestname, messages[i].content, messages[i].timestamp, messages[i].systemName, messages[i].tag || "", messages[i].tagcolour || ""));
            }
            user = null;
        }

        discussion.setMessages(messageList);

        if (this.client.getCurrentDiscussion() === discussion) {
            this.client.completeDiscussionSwitch(discussion);
        }
    }

    private handleChatMessage(message: ChatMessage): void {
        let discussionId = message.discID;
        let user: User | null = null;
        let username: string;
        let guestname: string;
        let discussion = this.client.getDiscussions()[discussionId];

        if (!discussion)
            return;

        if (this.client.getPhaseUsers()[message.userID]) {
            user = this.client.getPhaseUsers()[message.userID];
        } else {
            if (!message.guest) {
                user = new User(message.userID, message.username, message.systemName, message.avatar, this.client.getSystemName(), UserStatus.Offline);
                this.client.addPhaseUser(user);
            }
        }

        // Server doesn't send message ID so for now it has to be set to a default
        if (message.guest) {
            username = "";
            guestname = message.username;
        } else {
            username = message.username;
            guestname = "";
        }

        let chatMessage = new Message(this.client.getNewMessageId(), message.userID, message.avatar, username, guestname, message.msg, message.timestamp, message.systemName, message.tag || "", message.tagcolour || "");
        this.client.handleChatMessage(discussion, chatMessage);
    }

    private handleChatEditQueue(editQueue: EditQueue): void {
        let discussionId = editQueue.discID;
        let edits = editQueue.queue;
        let userId = editQueue.userID;
        let username = editQueue.username;
        let systemName = editQueue.systemName;
        let discussion = this.client.getDiscussions()[discussionId];

        if (!discussion) {
            return;
        }

        let messageContent = "";
        let chatUser: User | undefined = this.client.getPhaseUser(userId);

        if (typeof chatUser === 'undefined') {
            return;
        }

        let storedLiveTyping = discussion.getLiveTypingMessage(userId);
        
        // If existing content stored, used that
        if (typeof storedLiveTyping !== 'undefined') {
            messageContent = storedLiveTyping.getContent().asIs();
        }

        // Apply edits
        for (var i = 0; i < edits.length; i++) {
            let item = edits[i];
            if (item.t) {
                messageContent = messageContent.slice(0, item.pos) + item.text + messageContent.slice(item.pos);
            } else {
                messageContent = messageContent.slice(0, item.pos) + messageContent.slice(item.pos + item.len);
            }
        }

        // Create a new message if none stored, or update existing
        if (typeof storedLiveTyping === 'undefined') {
            if (messageContent.trim().length > 0) {
                discussion.setLiveTypingMessages(userId, new Message(this.client.getNewMessageId(), userId, chatUser.getAvatar(), chatUser.getName(), "", messageContent, Date.now()/1000, systemName, "", ""));
                this.client.handleNewLiveTyping(discussion, <Message>discussion.getLiveTypingMessage(userId));
            }
        } else {
            if (messageContent.trim().length > 0) {
                discussion.updateLiveTypingMessageContent(userId, messageContent);
                this.client.handleUpdateLiveTyping(discussion, <Message>discussion.getLiveTypingMessage(userId));
            } else {
                discussion.removeLiveTypingMessage(userId);
                this.client.handleRemoveLiveTyping(discussion, userId);
            }
        }
    }
  
    /**
     * Handles when a user comes online
     * 
     * @param userOnline The user who has come online
     */
    private handleUserOnline(userOnline: UserOnline): void {
        let phaseUser = this.client.getPhaseUser(userOnline.userID);
        if (!phaseUser) {
            phaseUser = new User(userOnline.userID, userOnline.name, userOnline.systemName, userOnline.avatar, this.client.getSystemName(), UserStatus.Online);
        } else if(phaseUser.getAvatar().length === 0) {
            phaseUser.setAvatar(userOnline.avatar);
        }

        this.client.handleUserOnline(phaseUser);
    }

    /**
     * Handles when a user goes offline
     * 
     * @param userOffline The user who has gone offline
     */
    private handleUserOffline(userOffline: UserOffline): void {
        let phaseUser = this.client.getPhaseUser(userOffline.userID);
        if (!phaseUser) {
            phaseUser = new User(userOffline.userID, userOffline.name, userOffline.systemName, "", this.client.getSystemName(), UserStatus.Online);
        }

        this.client.handleUserOffline(phaseUser);
    }

    /**
     * Handles when this client is added to a new discussion
     * 
     * @param newDiscussion The info about the new discussion
     */
    private handleNewDiscussion(newDiscussion: NewDiscussion): void {
        let recentMessage = new Message(this.client.getNewMessageId(), 0, "", "", "", newDiscussion.lastMessage, 0, "", "", "");
        this.client.handleNewDiscussion(new Discussion(newDiscussion.discID, newDiscussion.discussionName, -1, [], recentMessage));
    }

    /**
     * Handles when this client is removed from a discussion
     * 
     * @param removeDiscussion The info about what discussion they were removed from
     */
    private handleRemoveDiscussion(removeDiscussion: RemoveDiscussion): void {
        this.client.handleRemoveDiscussion(removeDiscussion.discID);
    }
    
    /**
     * Puts the users online into the display list and adds them to the client list
     * 
     * @param usersOnline The list of phase users online
     */
    private handleUsersOnline(usersOnline: UsersOnline): void {
        let users: User[] = [];
        for (let i = 0; i < usersOnline.length; i++) {
            let user = usersOnline[i];
            users.push(new User(user.UserID, user.name, user.systemName, user.Avatar, this.client.getSystemName(), UserStatus.Online));
        }

        this.client.handleUsersOnline(users);
    }

    /**
     * Handles when the list of terraria users is received
     * 
     * @param terrariaUsersOnline The list of terraria users online
     */
    private handleTerrariaUsersOnline(terrariaUsersOnline: TerrariaUsersOnline): void {
        this.client.handleTerrariaUsers(terrariaUsersOnline);
    }

    /**
     * Handles when a terraria user joins a server
     * 
     * @param joinInfo The information about who joined
     */
    private handleTerrariaJoin(joinInfo: TerrariaJoinLeave): void {
        this.client.handleTerrariaJoin(joinInfo.username, joinInfo.tagColour);
    }

    /**
     * Handles when a terraria user leaves a server
     * 
     * @param leaveInfo The information about who left
     */
    private handleTerrariaLeave(leaveInfo: TerrariaJoinLeave): void {
        this.client.handleTerrariaLeave(leaveInfo.username);
    }

    /**
     * Handles when a terraria user changes their name
     * 
     * @param changeNameInfo Information about who changed their username
     */
    private handleTerrariaChangeName(changeNameInfo: TerrariaChangeName): void {
        this.client.handleTerrariaChangeName(changeNameInfo.oldName, changeNameInfo.newName);
    }

    /* Message Requests */

    public requestDiscussionDetails(discussionId: number, includeJoinLeave: boolean): void {
        this.socket.emit('discussion users', `${discussionId}`);
        this.socket.emit('discussion messages', {
            discID: discussionId,
            includeJoinLeave: includeJoinLeave
        });
    }

    public sendChatMessage(discussionId: number, text: string): number {
        this.socket.emit('chat message', {
            ID: this.chatSequenceId,
            discID: discussionId,
            msg: text
        });

        return this.chatSequenceId++;
    }

    public sendEditQueue(discussionId: number, editQueue: ChatEditQueue): void {
        this.socket.emit('chat edit queue', {
            queue: editQueue,
            discID: discussionId
        });
    }
}

export default Network;