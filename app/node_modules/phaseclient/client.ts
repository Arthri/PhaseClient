import Network from 'phaseclient/network';
import User from 'phaseclient/user';
import Discussion from 'phaseclient/discussion';
import { TerrariaUserHash, DiscussionHash, UserHash, BooleanHash } from 'phaseclient/hash';
import Message from 'phaseclient/message';
import Cookie from 'phaseclient/cookie';
import EditQueue from 'phasecore/editqueue';
import Config from 'phaseclient/config';
import System from 'phasecore/system';
import UserStatus from 'phasecore/userstatus';
import TerrariaUsersOnline from 'phasecore/messagetypes/terrariausersonline';
import DiscussionAlertList from 'phasecore/messagetypes/discussionalertlist';
import TerrariaUser from 'phaseclient/terrariauser';
import {Discussions, Discussion as ReceivedDiscussion} from 'phasecore/messagetypes/discussions';

/**
 * The barebones client. It can be used to connect to the Phase server and has methods for interacting
 * but does not actually do anything useful on its own.
 */
class Client {
    protected id: number;
    protected username: string;
    protected systemName: string;
    protected onlineUsers: Array<User>;
    protected avatar: string;
    protected network: Network;
    protected discussions: DiscussionHash;
    protected phaseUsers: UserHash;
    protected terrariaUsers: TerrariaUserHash;
    protected currentDiscussion: Discussion | undefined;
    protected configuration: Config;
    protected session: string;
    private discussionAlertList: DiscussionAlertList;
    public switchDiscussionTo: number | null;

    constructor(configuration: Config) {
        this.discussions = {};
        this.onlineUsers = [];
        this.phaseUsers = {};
        this.terrariaUsers = {};
        this.configuration = configuration;
        this.session = "";
        this.switchDiscussionTo = null;
    }

    public setupNetwork(network: Network): void {
        if (!this.network) {
            this.network = network;
        }
    }

    public setId(id: number): void {
        this.id = id;
    }

    public getId(): number {
        return this.id;
    }

    public setUsername(username: string): void {
        this.username = username;
    }

    public getUsername(): string {
        return this.username;
    }

    public setSystemName(systemName: string): void {
        this.systemName = systemName;
    }

    public getSystemName(): string {
        return this.systemName;
    }

    public getOnlineUsers(): Array<User> {
        return this.onlineUsers;
    }

    public getAvatar(): string {
        return this.avatar;
    }
    
    public getDiscussions(): DiscussionHash {
        return this.discussions;
    }

    public getCurrentDiscussion(): Discussion | undefined {
        return this.currentDiscussion;
    }

    public getPhaseUsers(): UserHash {
        return this.phaseUsers;
    }

    public getPhaseUser(userId: number): User {
        return this.getPhaseUsers()[userId.toString()];
    }

    /**
     * Finds a phase user by their username in the list, or null
     * if they do not exist.
     * 
     * @param username The username of the Phase User to find
     */
    public getPhaseUserByName(username: string): User | null {
        let foundUser: User | null = null;
        let users = this.getPhaseUsers();
        for (let index in users) {
            if (users[index].getName() === username) {
                foundUser = users[index];
                break;
            }
        }

        return foundUser;
    }

    public getTerrariaUsers(): TerrariaUserHash {
        return this.terrariaUsers;
    }

    public getConfiguration(): Config {
        return this.configuration;
    }

    public getSession(): string {
        return this.session;
    }

    /* Updates the users avatar in the chat input area */
    public setAvatar(avatar: string): void {
        if (avatar.indexOf('/') === 0) {
            avatar = `https://t.dark-gaming.com:3001/${avatar}`;
        }
        this.avatar = avatar;
    }

    /* Adds a phase users information to the clients phase users object */
    public addPhaseUser(user: User): void {
        this.getPhaseUsers()[user.getId()] = user;
    }

    /* Appends a discussion to the clients list of discussions and updates page */
    public addDiscussion(discussion: Discussion): void {
        this.discussions[discussion.getId()] = discussion;
    }

    /**
     * Switches current discussion
     * @param discussionId The id of the discussion to switch to
     */
    public switchDiscussion(discussionId: number): void {
        let discussion = this.getDiscussions()[discussionId];

        if (!discussion)
            return;

        if (discussion.getMembers().length === 0) {
            this.network.requestDiscussionDetails(discussionId, this.getConfiguration().useAndDisplayJoinLeaveMessages);
        }

        if (this.currentDiscussion) {
            this.currentDiscussion.setIsBeingViewed(false);
        }

        discussion.setIsBeingViewed(true);
        discussion.setHasUnreadMessages(false);
        this.currentDiscussion = discussion;
    }

    /**
     * Clears the hash of discussions
     */
    public clearDiscussions(): void {
        this.discussions = {};
    }

    /**
     * Sends a queue of edits to the server
     * 
     * @param editQueue The queue of edits to send
     */
    public sendEditQueue(editQueue: EditQueue): void {
        if (this.currentDiscussion == null) {
            return;
        }

        this.network.sendEditQueue(this.currentDiscussion.getId(), editQueue);
    }

    /**
     * When a chat message is to be displayed it will go through this function.
     * It must be decided whether the message is allowed to be displayed according
     * to the configuration.
     * 
     * @param discussion The discussion the message was received for
     * @param message The message itself
     */
    public handleChatMessage(discussion: Discussion, message: Message): void {
        if (!this.getConfiguration().useAndDisplayJoinLeaveMessages && message.getUserId() == System.joinLeaveMessageUserId && message.getTag().length > 0) {
            return;
        }

        discussion.appendMessage(message);
        discussion.removeLiveTypingMessage(message.getUserId());
        discussion.setRecentMessage(message);

        if (!discussion.getIsBeingViewed()) {
            discussion.setHasUnreadMessages(true);
        }
    }

    /**
     * When the user sends a chat message, it is sent to the server, and a new one put into and is displayed
     * in the discussion list
     * 
     * @param text The content of the chat message to send
     */
    public sendChatMessage(text: string): void {
        if (this.currentDiscussion == null) {
            return;
        }

        let chatMessageId = this.network.sendChatMessage(this.currentDiscussion.getId(), text);
        let message = new Message(this.getId(), this.getAvatar(), this.getUsername(), "", text, Math.round(Date.now()/1000), this.getSystemName(), "", "");

        // Only process it as a chat message if it is not a command
        if (message.getContent().asIs().indexOf('/') !== 0) {
            this.handleChatMessage(this.currentDiscussion, message);
        }
    }

    /**
     * Use the session to get client information (userId, username etc) necessary
     * 
     * @param session The session token
     */
    public sendInformationRequest(session: string): void {
        Cookie.setCookie('_phasesession', session, 3);
        if (session) {
            this.session = session;
            this.network.sendInformationRequest(session);
        }
    }

    /**
     * Handles when the discussion messages requested were received or when the local messages were already there and need loading
     * 
     * @param discussion The discussion that the messages received are in or the discussion with the local messages already
     */
    public completeDiscussionSwitch(discussion: Discussion): void {}

    /**
     * Handles when a user comes online
     * 
     * @param user The user who has come online
     */
    public handleUserOnline(user: User): void {
        if (this.onlineUsers.indexOf(user) === -1) {
            this.onlineUsers.push(user);
        }

        user.setStatus(UserStatus.Online);
    }

    /**
     * Handles when a user goes offline
     * 
     * @param user The user who has gone offline
     */
    public handleUserOffline(user: User): void {
        let index = this.onlineUsers.indexOf(user);
        if (index > -1) {
            this.onlineUsers.splice(index, 1);
        }

        user.setStatus(UserStatus.Offline);
        user.setLastOnline(Date.now());
        
        for (let key in this.discussions) {
            if (typeof this.discussions[key] !== 'undefined') {
                this.discussions[key].removeLiveTypingMessage(user.getId());
            }
        }
    }

    /**
     * Handles when the list of users online are received
     * 
     * @param userList The users who are online
     */
    public handleUsersOnline(userList: User[]): void {
        this.onlineUsers = [];
        let phaseUsers = this.getPhaseUsers();
        for (let i = 0; i < userList.length; i++) {
            let user = userList[i];
            if (!phaseUsers[user.getId()]) {
                this.addPhaseUser(user);
            }
            this.onlineUsers.push(user);
        }
    }

    public handleDiscussionList(discussions: Discussions): void {
        let discussion: ReceivedDiscussion;
        let message: Message;
        for (let i = discussions.length-1; i >= 0; i--) {
            discussion = discussions[i];
            message = new Message(0, "", discussion.Username || "", discussion.GuestName || "", discussion.Message || "[No Content]", discussion.timestamp, this.getSystemName(), "", "");
            this.addDiscussion(new Discussion(discussion.ID, discussion.Name, discussion.Creator, [], message));
        }

        // If the client was reconnected and was previously on a discussion, it is reloaded
        if (this.switchDiscussionTo !== null) {
            this.switchDiscussion(this.switchDiscussionTo);
            this.switchDiscussionTo = null;
        }

        let discussionList = this.getDiscussions();
        for (let i = 0; i < this.discussionAlertList.length; i++) {
            if (discussionList[this.discussionAlertList[i].DiscussionID]) {
                discussionList[this.discussionAlertList[i].DiscussionID].setAlertsEnabled(this.discussionAlertList[i].Alert);
            }
        }
    }

    /**
     * Handles when the client receives a list of which discussions have alerts enabled
     * 
     * @param discussionAlertList The list of which discussions have alerts enabled
     */
    public handleDiscussionAlertList(discussionAlertList: DiscussionAlertList): void {
        this.discussionAlertList = discussionAlertList;
    }

    /**
     * Handles when the client becomes a part of a new discussion
     * 
     * @param discussion The new discussion
     */
    public handleNewDiscussion(discussion: Discussion): void {
        this.addDiscussion(discussion);
    }

    /**
     * Handles when the client is removed from a discussion
     * 
     * @param discussionId The id of the discussion to remove
     */
    public handleRemoveDiscussion(discussionId: number): void {
        delete this.getDiscussions()[discussionId]
    }

    /**
     * Handles when the discussion users list has been received
     * 
     * @param discussion The discussion that the users are from
     * @param userList The list of users in the discussion
     * @param modList The moderators of that discussion
     */
     public handleDiscussionUsers(discussion: Discussion, userList: User[], modList: BooleanHash): void {
         discussion.setMembers(userList);
         discussion.setModerators(modList);
     }

    /**
     * Handles when a new live typing message is received
     * 
     * @param message The live typing message
     */
    public handleNewLiveTyping(discussion: Discussion, message: Message): void {}

    /**
     * Handles when an update to an existing live typing message is received
     * 
     * @param message The live typing message
     */
    public handleUpdateLiveTyping(discussion: Discussion, message: Message): void {}

    /**
     * Handles when a removal of an existing live typing message is received
     * 
     * @param userId The user id of the live typing message to remove
     */
    public handleRemoveLiveTyping(discussion: Discussion, userId: number): void {}

    /**
     * Handles when the list of terraria users who are online is received
     * 
     * @param users The terraria users who are online
     */
    public handleTerrariaUsers(users: TerrariaUsersOnline): void {
        for (let i = 0; i < users.length; i++) {
            this.terrariaUsers[users[i].name] = new TerrariaUser(users[i].name, users[i].tagColour);
        }
    }

    /**
     * Handles when a user joins a terraria server
     * 
     * @param username The username of the person who joined a terraria server
     */
    public handleTerrariaJoin(username: string, tagColor: string): void {
        this.terrariaUsers[username] = new TerrariaUser(username, tagColor);
    }

    /**
     * Handles when a user leaves a terraria server
     * 
     * @param username The username of the person who left a terraria server
     */
    public handleTerrariaLeave(username: string): void {
        delete this.terrariaUsers[username];

        let user = this.getPhaseUserByName(username);
        if (user !== null) {
            user.setLastInGame(Date.now());
        }
    }

    /**
     * Handles when a user changes their name on a terraria server
     * 
     * @param oldUsername The old name of the user
     * @param newUsername The new name of the user
     */
    public handleTerrariaChangeName(oldUsername: string, newUsername: string): void {
        let color = "#000000";
        if (this.terrariaUsers[oldUsername]) {
            color = this.terrariaUsers[oldUsername].getTagColour();
        }

        this.handleTerrariaLeave(oldUsername);
        this.handleTerrariaJoin(newUsername, "#000000");
    }
}

export default Client;