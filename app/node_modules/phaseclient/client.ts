import Config from "phaseclient/config";
import Cookie from "phaseclient/cookie";
import DeepHistory from "phaseclient/deephistory";
import Discussion from "phaseclient/discussion";
import { BooleanHash, DiscussionHash, TerrariaUserHash, UserHash } from "phaseclient/hash";
import Message from "phaseclient/message";
import Network from "phaseclient/network";
import Search from "phaseclient/search";
import TerrariaUser from "phaseclient/terrariauser";
import User from "phaseclient/user";
import EditQueue from "phasecore/editqueue";
import ChatMessageRevoked from "phasecore/messagetypes/chatmessagerevoked";
import DeepHistoryResults from "phasecore/messagetypes/deephistory";
import DeepHistoryNewerResults from "phasecore/messagetypes/deephistorynewer";
import DeepHistoryOlderResults from "phasecore/messagetypes/deephistoryolder";
import DiscussionAlertList from "phasecore/messagetypes/discussionalertlist";
import {Discussion as ReceivedDiscussion, Discussions} from "phasecore/messagetypes/discussions";
import DiscussionUserAdd from "phasecore/messagetypes/discussionuseradd";
import DiscussionUserRemove from "phasecore/messagetypes/discussionuserremove";
import SearchResults from "phasecore/messagetypes/searchresults";
import TerrariaUsersOnline from "phasecore/messagetypes/terrariausersonline";
import System from "phasecore/system";
import UserStatus from "phasecore/userstatus";

declare var global: any;
/**
 * The barebones client. It can be used to connect to the Phase server and has methods for interacting
 * but does not actually do anything useful on its own.
 */
class Client {
    private _uniqueMessageId: number;
    protected _id: number;
    protected _username: string;
    protected _systemName: string;
    protected _onlineUsers: User[];
    protected _avatar: string;
    protected _network: Network;
    protected _discussions: DiscussionHash;
    protected _phaseUsers: UserHash;
    protected _terrariaUsers: TerrariaUserHash;
    protected _currentDiscussion: Discussion | undefined;
    protected _configuration: Config;
    protected _session: string;
    protected _search: Search | null = null;
    protected _deepHistory: DeepHistory | null = null;
    private _discussionAlertList: DiscussionAlertList | undefined;
    public switchDiscussionTo: number | null;

    constructor(configuration: Config) {
        this._uniqueMessageId = 0;
        this._id = -1;
        this._discussions = {};
        (window as any).tsystem = this;
        this._onlineUsers = [];
        this._phaseUsers = {};
        this._terrariaUsers = {};
        this._configuration = configuration;
        this._session = "";
        this.switchDiscussionTo = null;
    }

    public setupNetwork(network: Network): void {
        if (!this._network) {
            this._network = network;
        }
    }

    public getNewMessageId(): number {
        return this._uniqueMessageId++;
    }

    public set id(id: number) {
        this._id = id;
    }

    public get id() {
        return this._id;
    }

    public set username(username: string) {
        this._username = username;
    }

    public get username() {
        return this._username;
    }

    public set systemName(systemName: string) {
        this._systemName = systemName;
    }

    public get systemName() {
        return this._systemName;
    }

    public get onlineUsers() {
        return this._onlineUsers;
    }

    public get avatar() {
        return this._avatar;
    }

    public get discussions(): DiscussionHash {
        return this._discussions;
    }

    public get currentDiscussion(): Discussion | undefined {
        return this._currentDiscussion;
    }

    public get discussionSearch(): Search | null {
        return this._search;
    }

    public get deepHistory(): DeepHistory | null {
        return this._deepHistory;
    }

    public get phaseUsers(): UserHash {
        return this._phaseUsers;
    }

    public getPhaseUser(userId: number): User | undefined {
        return this.phaseUsers[userId.toString()];
    }

    /**
     * Finds a phase user by their username in the list, or null
     * if they do not exist.
     *
     * @param username The username of the Phase User to find
     */
    public getPhaseUserByName(username: string): User | null {
        let foundUser: User | null = null;
        const users = this.phaseUsers;
        for (const index in users) {
            if (users[index].name === username) {
                foundUser = users[index];
                break;
            }
        }

        return foundUser;
    }

    public get terrariaUsers(): TerrariaUserHash {
        return this._terrariaUsers;
    }

    public get configuration(): Config {
        return this._configuration;
    }

    public get session(): string {
        return this._session;
    }

    /* Updates the users avatar in the chat input area */
    public set avatar(avatar: string) {
        if (avatar.indexOf("/") === 0) {
            avatar = `https://t.dark-gaming.com:3001/${avatar}`;
        }
        this._avatar = avatar;
    }

    /* Adds a phase users information to the clients phase users object */
    public addPhaseUser(user: User): void {
        this.phaseUsers[user.id] = user;
    }

    /**
     * A hook for when the discussion list has been received
     */
    protected onDiscussionListReceived(discussions: Discussion[]): void {
        return;
    }

    /* Appends a discussion to the clients list of discussions and updates page */
    public addDiscussion(discussion: Discussion): void {
        this._discussions[discussion.id] = discussion;
    }

    /**
     * Switches current discussion
     * @param discussionId The id of the discussion to switch to
     */
    public switchDiscussion(discussionId: number): void {
        const discussion = this.discussions[discussionId];

        if (!discussion) {
            return;
        }

        if (discussion.members.length === 0) {
            this._network.requestDiscussionDetails(discussionId, this.configuration.useAndDisplayJoinLeaveMessages);
        }

        if (this._currentDiscussion) {
            this._currentDiscussion.isBeingViewed = false;
        }

        discussion.isBeingViewed = true;
        discussion.hasUnreadMessages = false;
        this._currentDiscussion = discussion;
        this._search = null;
    }

    /**
     * Clears the hash of discussions
     */
    public clearDiscussions(): void {
        this._discussions = {};
    }

    /**
     * Sends a queue of edits to the server
     *
     * @param editQueue The queue of edits to send
     */
    public sendEditQueue(editQueue: EditQueue): void {
        if (!this._currentDiscussion) {
            return;
        }

        this._network.sendEditQueue(this._currentDiscussion.id, editQueue);
    }

    /**
     * When a chat message is to be displayed it will go through this function.
     * It must be decided whether the message is allowed to be displayed according
     * to the configuration.
     *
     * @param discussion The discussion the message was received for
     * @param message The message itself
     */
    public handleChatMessage(discussion: Discussion, message: Message): void {
        if (!this.configuration.useAndDisplayJoinLeaveMessages
            && message.userId === System.joinLeaveMessageUserId
            && message.tag.length > 0) {
            return;
        }

        discussion.appendMessage(message);
        discussion.removeLiveTypingMessage(message.userId);
        discussion.recentMessage = message;

        if (!discussion.isBeingViewed) {
            discussion.hasUnreadMessages = true;
        }
    }

    /**
     * When the user sends a chat message, it is sent to the server, and a new one put into and is displayed
     * in the discussion list
     *
     * @param text The content of the chat message to send
     */
    public sendChatMessage(text: string): void {
        if (!this._currentDiscussion) {
            return;
        }

        const message = new Message(this.getNewMessageId(),
            this.id,
            this.avatar,
            this.username,
            "",
            text,
            Math.round(Date.now() / 1000),
            this.systemName,
            "",
            "");
        this._network.sendChatMessage(this._currentDiscussion.id, message.localMessageId, text);

        // Only process it as a chat message if it is not a command
        if (message.content.asIs().indexOf("/") !== 0) {
            this.handleChatMessage(this._currentDiscussion, message);
        }
    }

    /**
     * Use the session to get client information (userId, username etc) necessary
     *
     * @param session The session token
     */
    public sendInformationRequest(session: string): void {
        Cookie.setCookie("_phasesession", session, 3);
        if (session) {
            this._session = session;
            this._network.sendInformationRequest(session);
        }
    }

    /**
     * Request guest access for Phase
     *
     * @param systemName The name of the system to guest
     */
    public sendGuestRequest(systemName: string): void {
        this._network.sendGuestRequest(systemName);
    }

    /**
     * Handles when the discussion messages requested were received or when the local messages were already there and need loading
     *
     * @param discussion The discussion that the messages received are in or the discussion with the local messages already
     */
    public completeDiscussionSwitch(discussion: Discussion): void {
        return;
    }

    /**
     * Handles when a user comes online
     *
     * @param user The user who has come online
     */
    public handleUserOnline(user: User): void {
        if (this._onlineUsers.indexOf(user) === -1) {
            this._onlineUsers.push(user);
        }

        user.status = UserStatus.Online;
    }

    /**
     * Handles when a user goes offline
     *
     * @param user The user who has gone offline
     */
    public handleUserOffline(user: User): void {
        const index = this._onlineUsers.indexOf(user);
        if (index > -1) {
            this._onlineUsers.splice(index, 1);
        }

        user.status = UserStatus.Offline;
        user.lastOnline = Date.now();

        for (const key in this._discussions) {
            if (typeof this._discussions[key] !== "undefined") {
                this._discussions[key].removeLiveTypingMessage(user.id);
            }
        }
    }

    /**
     * Handles when the list of users online are received
     *
     * @param userList The users who are online
     */
    public handleUsersOnline(userList: User[]): void {
        this._onlineUsers = [];
        const phaseUsers = this.phaseUsers;
        for (const user of userList) {
            if (!phaseUsers[user.id]) {
                this.addPhaseUser(user);
            }

            this._onlineUsers.push(user);
        }
    }

    public handleDiscussionList(receivedDiscussions: Discussions): void {
        let discussionInfo: ReceivedDiscussion;
        let message: Message;
        let discussion: Discussion;
        let lastDiscussion: Discussion | null = null;
        const discussions: Discussion[] = [];
        for (let i = receivedDiscussions.length - 1; i >= 0; i--) {
            discussionInfo = receivedDiscussions[i];
            message = new Message(this.getNewMessageId(),
                0,
                "",
                discussionInfo.Username || "",
                discussionInfo.GuestName || "",
                discussionInfo.Message || "[No Content]",
                discussionInfo.timestamp,
                this.systemName,
                "",
                "");
            discussion = new Discussion(discussionInfo.ID, discussionInfo.Name, discussionInfo.Creator, [], message);
            this.addDiscussion(discussion);
            discussions.push(discussion);
            lastDiscussion = discussion;
        }

        this.onDiscussionListReceived(discussions);

        // If the client was reconnected and was previously on a discussion, it is reloaded
        if (this.switchDiscussionTo !== null) {
            this.switchDiscussion(this.switchDiscussionTo);
            this.switchDiscussionTo = null;
        } else {
            if (lastDiscussion) {
                this.switchDiscussion(lastDiscussion.id);
            }
        }

        const discussionList = this.discussions;
        if (this._discussionAlertList) {
            for (const alert of this._discussionAlertList) {
                if (discussionList[alert.DiscussionID]) {
                    discussionList[alert.DiscussionID].alertsEnabled = alert.Alert;
                }
            }
        }
    }

    /**
     * Handles when the client receives a list of which discussions have alerts enabled
     *
     * @param discussionAlertList The list of which discussions have alerts enabled
     */
    public handleDiscussionAlertList(discussionAlertList: DiscussionAlertList): void {
        this._discussionAlertList = discussionAlertList;
    }

    /**
     * Handles when the client becomes a part of a new discussion
     *
     * @param discussion The new discussion
     */
    public handleNewDiscussion(discussion: Discussion): void {
        this.addDiscussion(discussion);
    }

    /**
     * Handles when the client is removed from a discussion
     *
     * @param discussionId The id of the discussion to remove
     */
    public handleRemoveDiscussion(discussionId: number): void {
        delete this.discussions[discussionId];
    }

    /**
     * Handles when the discussion users list has been received
     *
     * @param discussion The discussion that the users are from
     * @param userList The list of users in the discussion
     * @param modList The moderators of that discussion
     */
     public handleDiscussionUsers(discussion: Discussion, userList: User[], modList: BooleanHash): void {
         discussion.members = userList;
         discussion.moderators = modList;
     }

    /**
     * Handles when a new live typing message is received
     *
     * @param message The live typing message
     */
    public handleNewLiveTyping(discussion: Discussion, message: Message): void {
        return;
    }

    /**
     * Handles when an update to an existing live typing message is received
     *
     * @param message The live typing message
     */
    public handleUpdateLiveTyping(discussion: Discussion, message: Message): void {
        return;
    }

    /**
     * Handles when a removal of an existing live typing message is received
     *
     * @param userId The user id of the live typing message to remove
     */
    public handleRemoveLiveTyping(discussion: Discussion, userId: number): void {
        return;
    }

    /**
     * Handles when the list of terraria users who are online is received
     *
     * @param users The terraria users who are online
     */
    public handleTerrariaUsers(users: TerrariaUsersOnline): void {
        for (const user of users) {
            this._terrariaUsers[user.name] = new TerrariaUser(user.name, user.tagColour);
        }
    }

    /**
     * Handles when a user joins a terraria server
     *
     * @param username The username of the person who joined a terraria server
     */
    public handleTerrariaJoin(username: string, tagColor: string): void {
        this._terrariaUsers[username] = new TerrariaUser(username, tagColor);
    }

    /**
     * Handles when a user leaves a terraria server
     *
     * @param username The username of the person who left a terraria server
     */
    public handleTerrariaLeave(username: string): void {
        delete this._terrariaUsers[username];

        const user = this.getPhaseUserByName(username);
        if (user !== null) {
            user.lastInGame = Date.now();
        }
    }

    /**
     * Handles when a user changes their name on a terraria server
     *
     * @param oldUsername The old name of the user
     * @param newUsername The new name of the user
     */
    public handleTerrariaChangeName(oldUsername: string, newUsername: string): void {
        let color = "#000000";
        if (this._terrariaUsers[oldUsername]) {
            color = this._terrariaUsers[oldUsername].tagColour;
        }

        this.handleTerrariaLeave(oldUsername);
        this.handleTerrariaJoin(newUsername, "#000000");
    }

    /**
     * Loads more messages from the server for the given discussion
     *
     * @param discussion The discussion to get message history for
     */
    public requestDiscussionHistory(discussion: Discussion): void {
        this._network.requestDiscussionHistory(discussion);
    }

    /**
     * Handles when message history is received for a discussion
     *
     * @param discussion The discussion that history has been received for
     */
    public onHistoryReceived(discussion: Discussion): void {

    }

    /**
     * Handles when a chat message got revoked. This enables our client to remove the
     * live typing message.
     *
     * @param revokedInformation The discussionId and userId involved in the revokation
     */
    public handleChatMessageRevoked(revokedInformation: ChatMessageRevoked): void {
        if (revokedInformation.discID > 0) {
            const discussion = this._discussions[revokedInformation.discID.toString()];
            if (discussion !== null) {
                delete discussion.liveTypingMessages[revokedInformation.userID.toString()];
            }
        }
    }

    /**
     * Handles when one of our chat messages was denied. This removes the message from
     * our client.
     *
     * @param localMessageId The message id our client assigned to the local message
     */
    public handleChatMessageDenied(localMessageId: number): void {
        if (typeof this._currentDiscussion !== "undefined") {
            const messages = this._currentDiscussion.messages as Message[];
            let foundMessage: Message | null = null;
            for (const message of messages) {
                if (message.localMessageId === localMessageId) {
                    foundMessage = message;
                    break;
                }
            }

            if (foundMessage !== null) {
                messages.splice(messages.indexOf(foundMessage), 1);
            }
        }
    }

    /**
     * Handles when a user is added to a discussion we are a part of
     *
     * @param discussionUserAdd The info about who was added to what discussion
     */
    public handleDiscussionUserAdd(discussionUserAdd: DiscussionUserAdd): void {
        const discussion = this.discussions[discussionUserAdd.discID.toString()];
        let user = this.getPhaseUser(discussionUserAdd.userID);
        if (typeof discussion !== "undefined") {
            if (typeof user === "undefined") {
                user = new User(discussionUserAdd.userID, discussionUserAdd.username,
                    discussionUserAdd.systemName, discussionUserAdd.avatar,
                    this.systemName, UserStatus.Offline);
                this.addPhaseUser(user);
            }

            discussion.members.push(user);
        }
    }

    /**
     * Handles when a user is removed from a discussion we are a part of
     *
     * @param discussionUserRemove The info about who was removed from what discussion
     */
    public handleDiscussionUserRemove(discussionUserRemove: DiscussionUserRemove): void {
        const discussion = this.discussions[discussionUserRemove.discID.toString()];
        const user = this.getPhaseUserByName(discussionUserRemove.username);
        if (typeof discussion !== "undefined") {
            if (user !== null) {
                const members = discussion.members;
                members.splice(members.indexOf(user), 1);
            }
        }
    }

    /**
     * Toggles whether alerts are enabled for a discussion
     *
     * @param discussion The discussion to toggle alerts for
     */
    public toggleAlertsEnabled(discussion: Discussion): void {
        discussion.alertsEnabled = !discussion.alertsEnabled;
        this._network.sendAlertsEnabledUpdate(discussion.id, discussion.alertsEnabled);
    }

    /**
     * Requests a message search from the server
     *
     * @param terms The search terms
     */
    public requestMessageSearch(terms: string, oldestId?: number, username?: string, systemName?: string): boolean {
        const search = this.discussionSearch;
        const searchDiscussion = search !== null ? search.discussion : undefined;
        const currentDiscussion = this.currentDiscussion || searchDiscussion;
        if (search !== null && search.oldestId === null) {
            return false;
        }

        if (typeof currentDiscussion !== "undefined") {
            this._network.requestSearchResults(currentDiscussion.id, terms, oldestId, username, systemName);

            if (this._search === null || this._search.terms !== terms
                || this._search.discussion !== currentDiscussion
                || this._search.username !== username
                || this._search.systemName !== systemName) {
                this._search = new Search(terms, currentDiscussion, oldestId, username, systemName);
            }

            currentDiscussion.isBeingViewed = false;
            this._currentDiscussion = undefined;
            this._search.inProgress = true;

            return true;
        }

        return false;
    }

    public handleSearchResults(searchResults: SearchResults): void {
        const search = this.discussionSearch;
        if (search !== null) {
            if (searchResults.results.length !== 0) {
                search.oldestId = +searchResults.smallestResultID;
                const messages: Message[] = [];
                for (const message of searchResults.results) {
                    messages.push(new Message(
                        message.messageID,
                        message.userID,
                        message.avatar,
                        message.guest ? "" : message.username,
                        message.guest ? message.username : "",
                        message.content,
                        message.timestamp,
                        message.systemName,
                        message.tag || "",
                        message.tagcolour || ""
                    ));
                }

                search.prependMessages(messages);
            } else {
                search.oldestId = null;
            }

            search.inProgress = false;
        }
    }

    /**
     * Updates the name of a discussion
     *
     * @param discussion The discussion to update the name for
     * @param name The name to set
     */
    public updateDiscussionName(discussion: Discussion, name: string): void {
        discussion.name = name;
        this._network.sendDiscussionRename(discussion.id, name);
    }

    /**
     * Requests the deep history of a message
     */
    public requestDiscussionDeepHistory(discussion: Discussion, message: Message): void {
        this._deepHistory = new DeepHistory(discussion, message);
        this._search = null;
        this._currentDiscussion = undefined;
        this._network.requestSurroundingHistory(discussion.id, message.id);
    }

    /**
     * Handles when the client receives the surrounding history of a message
     *
     * @param deepHistoryResults The surround history
     */
    public handleDeepHistory(deepHistoryResults: DeepHistoryResults): void {
        if (this._deepHistory === null || deepHistoryResults.discID !== this._deepHistory.discussion.id) {
            return;
        }

        const messages: Message[] = [];
        for (const message of deepHistoryResults.messages) {
            messages.push(new Message(
                message.messageID,
                message.userID,
                message.avatar,
                message.guest ? "" : message.username,
                message.guest ? message.username : "",
                message.content,
                message.timestamp,
                message.systemName,
                message.tag || "",
                message.tagcolour || ""
            ));
        }

        this._deepHistory.addMessages(messages);
        this._deepHistory.oldestId = deepHistoryResults.oldestID;
        this._deepHistory.newestId = deepHistoryResults.newestID;
    }

    /**
     * Handles when the client receives older deep history messages
     * @param deepHistoryOlderResults The results of the deep history
     */
    public handleDeepHistoryOlder(deepHistoryOlderResults: DeepHistoryOlderResults): void {
        if (this._deepHistory === null || deepHistoryOlderResults.discID !== this._deepHistory.discussion.id) {
            return;
        }

        const messages: Message[] = [];
        for (const message of deepHistoryOlderResults.messages) {
            messages.push(new Message(
                message.messageID,
                message.userID,
                message.avatar,
                message.guest ? "" : message.username,
                message.guest ? message.username : "",
                message.content,
                message.timestamp,
                message.systemName,
                message.tag || "",
                message.tagcolour || ""
            ));
        }

        this._deepHistory.prependMessages(messages);
        this._deepHistory.oldestId = deepHistoryOlderResults.oldestID;
    }

    /**
     * Handles when the client receives newer deep history messages
     * @param deepHistoryOlderResults The results of the deep history
     */
    public handleDeepHistoryNewer(deepHistoryNewerResults: DeepHistoryNewerResults): void {
        if (this._deepHistory === null || deepHistoryNewerResults.discID !== this._deepHistory.discussion.id) {
            return;
        }

        const messages: Message[] = [];
        for (const message of deepHistoryNewerResults.messages) {
            messages.push(new Message(
                message.messageID,
                message.userID,
                message.avatar,
                message.guest ? "" : message.username,
                message.guest ? message.username : "",
                message.content,
                message.timestamp,
                message.systemName,
                message.tag || "",
                message.tagcolour || ""
            ));
        }

        this._deepHistory.addMessages(messages);
        this._deepHistory.newestId = deepHistoryNewerResults.newestID;
    }
}

export default Client;
