import Network from 'phase/network';
import User from 'phase/user';
import ElementIdentifiers from 'phaseweb/elementidentifiers';
import PageModel from 'phaseweb/pagemodel';
import Discussion from 'phase/discussion';
import { DiscussionHash, UserHash } from 'phase/hash';
import Message from 'phase/message';
import Cookie from 'phase/cookie';
import EditQueue from 'phase/editqueue';
import Config from 'phase/config';
import System from 'phase/system';
import Client from 'phase/client';

class WebClient extends Client {
    protected pageModel: PageModel;

    constructor(configuration: Config) {
        super(configuration);
    }

    public setupPageModel(pageModel: PageModel): void {
        if (!this.pageModel) {
            this.pageModel = pageModel;
            this.pageModel.checkSession();
        }
    }

    public setUsername(username: string): void {
        super.setUsername(username);
        this.pageModel.updateUsername(username);
    }

    public getPageModel(): PageModel {
        return this.pageModel;
    }

    /* Updates the users avatar in the chat input area */
    public setAvatar(avatar: string): void {
        super.setAvatar(avatar);
        this.pageModel.updateAvatar(avatar);
        this.pageModel.refreshUsersOnlineList();
    }

    /* Appends a discussion to the clients list of discussions and updates page */
    public addDiscussion(discussion: Discussion): void {
        super.addDiscussion(discussion);
        this.pageModel.prependDiscussionsList(discussion);
    }
    
    /**
     * Switches the current discussion
     * 
     * @param discussionId The id of the discussion to switch to
     * @param eventElem The element that was clicked to cause this switch
     * @override
     */
    public switchDiscussion(discussionId: number, eventElem?: any): void {
        let discussion = this.getDiscussions()[discussionId];

        if (!discussion) {
            return;
        }

        super.switchDiscussion(discussionId);

        if (discussion.getMembers().length > 0) {
            this.getPageModel().clearMessages();
            this.getPageModel().displayMessages(discussion);
        }

        if (eventElem) {
            this.getPageModel().switchSelectedDiscussion(eventElem);
        }
        
        this.getPageModel().setDiscussionRead(discussion);
        this.getPageModel().updateDisplayedTitle(discussion.getName());
    }

    /**
     * When a chat message is to be displayed it will go through this function.
     * It must be decided whether the message is allowed to be displayed according
     * to the configuration.
     * 
     * @param discussion The discussion the chat message has come from
     * @param message The message itself
     */
    public handleChatMessage(discussion: Discussion, message: Message): void {
        if (!this.getConfiguration().useAndDisplayJoinLeaveMessages && message.getUserId() == System.joinLeaveMessageUserId && message.getTag().length > 0) {
            return;
        }

        super.handleChatMessage(discussion, message);

        if (discussion.getIsBeingViewed()) {
            let lastMessage: Message | null = discussion.getMessages().length > 1 ? discussion.getMessages()[discussion.getMessages().length-2] : null;
            this.getPageModel().appendMessage(lastMessage, message);
            this.getPageModel().removeLiveTyping(message.getUserId());
        } else {
            this.getPageModel().setDiscussionUnread(discussion);

            // Doesn't work for mobile
            if (!this.getPageModel().getWindowHasFocus() && message.getContent().withBbcodeStripped().indexOf(this.getUsername()) > -1) {
                this.getPageModel().showNotification(message.getContent().withBbcodeStripped());
            }
        }

        this.getPageModel().updateDiscussionEntryMessagePreview(discussion);
    }

    /**
     * Handles when the discussion messages requested were received
     * 
     * @param discussion The discussion that the messages received are in
     */
    public handleDiscussionMessagesReceived(discussion: Discussion): void {
        this.getPageModel().clearMessages();
        this.getPageModel().displayMessages(discussion);
    }

    
    /**
     * Handles when a new live typing message is received
     * 
     * @param message The live typing message
     */
    public handleNewLiveTyping(message: Message): void {
        this.getPageModel().createLiveTyping(message);
    }

    /**
     * Handles when an update to an existing live typing message is received
     * 
     * @param message The live typing message
     */
    public handleUpdateLiveTyping(message: Message): void {
        this.getPageModel().updateLiveTyping(message);
    }

    /**
     * Handles when a removal of an existing live typing message is received
     * 
     * @param userId The user id of the live typing message to remove
     */
    public handleRemoveLiveTyping(userId: number): void {
        this.getPageModel().removeLiveTyping(userId);
    }
}

export default WebClient;