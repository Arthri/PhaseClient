import Network from 'phaseclient/network';
import User from 'phaseclient/user';
import ElementIdentifiers from 'phaseweb/elementidentifiers';
import PageModel from 'phaseweb/pagemodel';
import Discussion from 'phaseclient/discussion';
import { DiscussionHash, UserHash, BooleanHash } from 'phaseclient/hash';
import Message from 'phaseclient/message';
import Cookie from 'phaseclient/cookie';
import EditQueue from 'phasecore/editqueue';
import Config from 'phaseclient/config';
import System from 'phasecore/system';
import Client from 'phaseclient/client';
import SafeString from 'phaseclient/safestring';

class WebClient extends Client {
    protected pageModel: PageModel;

    constructor(configuration: Config) {
        super(configuration);
    }

    public setupPageModel(pageModel: PageModel): void {
        if (!this.pageModel) {
            this.pageModel = pageModel;
            this.pageModel.checkSession();
        }
    }

    public setUsername(username: string): void {
        super.setUsername(username);
        this.pageModel.updateUsername(username);
    }

    public getPageModel(): PageModel {
        return this.pageModel;
    }

    /* Updates the users avatar in the chat input area */
    public setAvatar(avatar: string): void {
        super.setAvatar(avatar);
        this.pageModel.updateAvatar(this.getAvatar());
        this.pageModel.refreshUsersOnlineList();
    }

    /* Appends a discussion to the clients list of discussions and updates page */
    public addDiscussion(discussion: Discussion): void {
        super.addDiscussion(discussion);
        this.pageModel.prependDiscussionsList(discussion);
    }
    
    /**
     * Switches the current discussion
     * 
     * @param discussionId The id of the discussion to switch to
     * @param eventElem The element that was clicked to cause this switch
     * @override
     */
    public switchDiscussion(discussionId: number): void {
        let discussion = this.getDiscussions()[discussionId];

        if (!discussion) {
            return;
        }
        
        if (typeof this.currentDiscussion !== 'undefined') {
            this.currentDiscussion.setOurLiveTypingMessage(this.getPageModel().getLastMessageInput());
        }

        super.switchDiscussion(discussionId);

        // If discussion has members, then the info for the discussion has been obtained already
        if (discussion.getMembers().length > 0) {
            this.getPageModel().fadeOutMessages();
            this.completeDiscussionSwitch(discussion);
            this.getPageModel().fadeInMessages();
        } else {
            this.getPageModel().showMessageLoading();
        }

        this.getPageModel().switchSelectedDiscussion(discussionId); 
        this.getPageModel().setDiscussionRead(discussion);
        this.getPageModel().updateDisplayedTitle(discussion.getName());
    }

    /**
     * When a chat message is to be displayed it will go through this function.
     * It must be decided whether the message is allowed to be displayed according
     * to the configuration.
     * 
     * @param discussion The discussion the chat message has come from
     * @param message The message itself
     */
    public handleChatMessage(discussion: Discussion, message: Message): void {
        if (!this.getConfiguration().useAndDisplayJoinLeaveMessages && message.getUserId() == System.joinLeaveMessageUserId && message.getTag().length > 0) {
            return;
        }

        let liveTypingExists = Object.keys(discussion.getLiveTypingMessages()).length > 0;
        super.handleChatMessage(discussion, message);

        if (discussion.getIsBeingViewed()) {
            let lastMessage: Message | null = discussion.getMessages().length > 1 ? <Message>discussion.getMessages()[discussion.getMessages().length-2] : null;
            this.getPageModel().displayMessage(lastMessage, message);
            this.getPageModel().removeLiveTyping(message.getUserId());
        } else {
            this.getPageModel().setDiscussionUnread(discussion);

            let content = <SafeString> message.getContent();
            if (!this.getPageModel().getWindowHasFocus() && (content.withBbcodeStripped().indexOf(this.getUsername()) > -1 || discussion.getHasAlertsEnabled())) {
                this.getPageModel().showNotification(discussion, `${message.getUsername().asIs()}: ${content.withBbcodeStripped()}`);
            }
        }

        this.getPageModel().updateDiscussionEntryMessagePreview(discussion);

        if (liveTypingExists && Object.keys(discussion.getLiveTypingMessages()).length === 0) {
            this.getPageModel().removeDiscussionLiveTypingBar(discussion);
        }

        this.getPageModel().moveDiscussionToTopOfList(discussion);
    }

    /**
     * Handles when the discussion messages requested were received or when the local messages were already there and need loading
     * 
     * @param discussion The discussion that the messages received are in or the discussion with the local messages already
     */
    public completeDiscussionSwitch(discussion: Discussion): void {
        this.getPageModel().clearMessages();
        this.getPageModel().clearLiveTyping();
        this.getPageModel().displayMessages(discussion);
        this.getPageModel().displayLiveTyping(discussion);
        this.getPageModel().updateDiscussionUsersList(true);
        this.getPageModel().updateOurLiveTyping(discussion);
        this.getPageModel().hideMessageLoading();
        this.getPageModel().updateOurChatColor();
    }
  
    /**
     * Handles when a user comes online
     * 
     * @param user The user who has come online
     */
    public handleUserOnline(user: User): void {
        super.handleUserOnline(user);
        this.getPageModel().refreshUsersOnlineList();
        this.getPageModel().updateDiscussionUsersList(false);
    }

    /**
     * Handles when a user goes offline
     * 
     * @param user The user who has gone offline
     */
    public handleUserOffline(user: User): void {
        super.handleUserOffline(user);
        this.getPageModel().refreshUsersOnlineList();
        this.getPageModel().updateDiscussionUsersList(false);
        this.getPageModel().removeLiveTyping(user.getId());
    }

    /**
     * Handles when the list of users online are received
     * 
     * @param userList The users who are online
     */
    public handleUsersOnline(userList: User[]): void {
        super.handleUsersOnline(userList);
        this.getPageModel().refreshUsersOnlineList();
    }

    /**
     * Handles when the discussion users list has been received
     * 
     * @param discussion The discussion that the users are from
     * @param userList The list of users in the discussion
     * @param modList The moderators of that discussion
     */
    public handleDiscussionUsers(discussion: Discussion, userList: User[], modList: BooleanHash): void {
        super.handleDiscussionUsers(discussion, userList, modList);

        if (this.currentDiscussion === discussion) {
            this.getPageModel().updateDiscussionUsersList();
        }
    }

    
    /**
     * Handles when a new live typing message is received
     * 
     * @param message The live typing message
     */
    public handleNewLiveTyping(discussion: Discussion, message: Message): void {
        if (discussion.getIsBeingViewed()) {
            this.getPageModel().createLiveTyping(message);
        } else {
            this.getPageModel().updateDiscussionLiveTypingBar(discussion);
        }
    }

    /**
     * Handles when an update to an existing live typing message is received
     * 
     * @param message The live typing message
     */
    public handleUpdateLiveTyping(discussion: Discussion, message: Message): void {
        if (discussion.getIsBeingViewed()) {
            this.getPageModel().updateLiveTyping(message);
        } else {
            this.getPageModel().updateDiscussionLiveTypingBar(discussion);
        }
    }

    /**
     * Handles when a removal of an existing live typing message is received
     * 
     * @param userId The user id of the live typing message to remove
     */
    public handleRemoveLiveTyping(discussion: Discussion, userId: number): void {
        if (discussion.getIsBeingViewed()) {
            this.getPageModel().removeLiveTyping(userId);
        } else if(Object.keys(discussion.getLiveTypingMessages()).length === 0) {
            this.getPageModel().removeDiscussionLiveTypingBar(discussion);
        }
    }

    /**
     * Handles when a user joins a terraria server
     * 
     * @param username The username of the person who joined a terraria server
     */
    public handleTerrariaJoin(username: string, tagColor: string): void {
        super.handleTerrariaJoin(username, tagColor);
        this.getPageModel().updateTerrariaUserStatus(username, true, tagColor);
    }

    /**
     * Handles when a user leaves a terraria server
     * 
     * @param username The username of the person who left a terraria server
     */
    public handleTerrariaLeave(username: string): void {
        super.handleTerrariaLeave(username);
        this.getPageModel().updateTerrariaUserStatus(username, false);
    }

    /**
     * Handles when a user changes their name on a terraria server
     * 
     * @param oldUsername The old name of the user
     * @param newUsername The new name of the user
     */
    public handleTerrariaChangeName(oldUsername: string, newUsername: string): void {
        super.handleTerrariaChangeName(oldUsername, newUsername);
    }
}

export default WebClient;