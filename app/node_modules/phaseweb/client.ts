import Client from "phaseclient/client";
import Config from "phaseclient/config";
import Discussion from "phaseclient/discussion";
import { BooleanHash } from "phaseclient/hash";
import Message from "phaseclient/message";
import SafeString from "phaseclient/safestring";
import User from "phaseclient/user";
import ChatMessageRevoked from "phasecore/messagetypes/chatmessagerevoked";
import DeepHistoryResults from "phasecore/messagetypes/deephistory";
import DeepHistoryNewerResults from "phasecore/messagetypes/deephistorynewer";
import DeepHistoryOlderResults from "phasecore/messagetypes/deephistoryolder";
import DiscussionUserAdd from "phasecore/messagetypes/discussionuseradd";
import DiscussionUserDemote from "phasecore/messagetypes/discussionuserdemote";
import DiscussionUserPromote from "phasecore/messagetypes/discussionuserpromote";
import DiscussionUserRemove from "phasecore/messagetypes/discussionuserremove";
import SearchResults from "phasecore/messagetypes/searchresults";
import SearchUserResults from "phasecore/messagetypes/searchuserresults";
import TerrariaJoinLeave from "phasecore/messagetypes/terrariajoinleave";
import TerrariaUsersOnline from "phasecore/messagetypes/terrariausersonline";
import UserAvatarUpdate from "phasecore/messagetypes/useravatarupdate";
import System from "phasecore/system";
import PageModel from "phaseweb/pagemodel";
import VWatcher from "vwatcher/watcher";
import RacialWatcher from "vwatcher/racial";
import ProfanityWatcher from "vwatcher/profanity";

class WebClient extends Client {
    protected _pageModel: PageModel;
    protected _initialDiscussionsReceived: boolean = false;
    private _addingNewDiscussion: boolean = false;
    protected vwatchers: VWatcher[];

    constructor(configuration: Config) {
        super(configuration);
        this.vwatchers = [
            new RacialWatcher(),
            new ProfanityWatcher(),
        ];
    }

    public setupPageModel(pageModel: PageModel): void {
        if (!this._pageModel) {
            this._pageModel = pageModel;
            this._pageModel.checkSession();
        }
    }

    public get avatar(): string {
        return this._avatar;
    }

    public get pageModel(): PageModel {
        return this._pageModel;
    }

    public get username(): string {
        return this._username;
    }

    public get creatingNewDiscussion(): boolean {
        return this._addingNewDiscussion;
    }

    public set username(username: string) {
        this._username = username;
        this._pageModel.updateUsername(username);
    }

    public set creatingNewDiscussion(addingNewDiscussion: boolean) {
        this._addingNewDiscussion = addingNewDiscussion;
    }

    /* Updates the users avatar in the chat input area */
    public set avatar(avatar: string) {
        if (avatar.indexOf("/") === 0) {
            avatar = `https://t.dark-gaming.com:3001${avatar}`;
        }

        this._avatar = avatar;
        this.pageModel.updateAvatar(this.avatar);
        this.pageModel.peopleSection.refreshUsersOnlineList();
    }

    /* Adds a phase users information to the clients phase users object */
    public addPhaseUser(user: User): void {
        super.addPhaseUser(user);
        this.pageModel.updateUserAvatar(user);
    }

    protected onDiscussionListReceived(discussions: Discussion[]): void {
        this._initialDiscussionsReceived = true;
        this.pageModel.discussionSection.setDiscussionsList(discussions);
    }

    /* Appends a discussion to the clients list of discussions and updates page */
    public addDiscussion(discussion: Discussion): void {
        super.addDiscussion(discussion);

        if (this._initialDiscussionsReceived) {
            this.pageModel.discussionSection.prependDiscussionsList(discussion);
        }
    }

    /**
     * Switches the current discussion
     *
     * @param discussionId The id of the discussion to switch to
     * @param eventElem The element that was clicked to cause this switch
     * @override
     */
    public switchDiscussion(discussionId: string): void {
        const discussion = this.discussions[discussionId];

        if (!discussion) {
            return;
        }

        if (typeof this._currentDiscussion !== "undefined") {
            this._currentDiscussion.ourLiveTypingMessage = this.pageModel.messageSection.getLastMessageInput();
        }

        super.switchDiscussion(discussionId);

        // If discussion has members, then the info for the discussion has been obtained already
        if (discussion.members.length > 0) {
            this.pageModel.messageSection.fadeOutMessages();
            this.completeDiscussionSwitch(discussion);
            this.pageModel.messageSection.fadeInMessages();
        } else {
            this.pageModel.messageSection.showMessageLoading();
        }

        this.pageModel.discussionSection.switchSelectedDiscussion(discussionId);
        this.pageModel.discussionSection.setDiscussionRead(discussion);
        this.pageModel.messageSection.updateDisplayedTitle(discussion.name);
        this.pageModel.messageSection.updateAlertBellStatus(discussion.alertsEnabled);
    }

    /**
     * When a chat message is to be displayed it will go through this function.
     * It must be decided whether the message is allowed to be displayed according
     * to the configuration.
     *
     * @param discussion The discussion the chat message has come from
     * @param message The message itself
     */
    public handleChatMessage(discussion: Discussion, message: Message): void {
        if (!this.configuration.useAndDisplayJoinLeaveMessages
            && message.userId === System.joinLeaveMessageUserId
            && message.tag.length > 0) {
            return;
        }

        const liveTypingExists = Object.keys(discussion.liveTypingMessages).length > 0;
        super.handleChatMessage(discussion, message);

        // Force update the terraria status if it is set to offline for a user that just sent a message
        if (message.tag.length > 0 && typeof this._terrariaUsers[message.username.asIs() || message.guestName.asIs()] === "undefined") {
            super.handleTerrariaJoin({
                username: message.username.asIs() || message.guestName.asIs(),
                tagName: message.tag,
                tagColour: message.tagColour
            });
            this.pageModel.messageSection.updateTerrariaUserStatus(
                message.username.asIs() || message.guestName.asIs(), true, message.tagColour);
        }

        if (liveTypingExists && Object.keys(discussion.liveTypingMessages).length === 0) {
            this.pageModel.discussionSection.removeDiscussionLiveTypingBar(discussion);
        }

        this.pageModel.discussionSection.moveDiscussionToTopOfList(discussion);
        this.pageModel.discussionSection.updateDiscussionEntryMessagePreview(discussion);
        this.decideDisplayMessage(discussion, message);

        if (this.vwatchers.some(w => w.IsViolating(message)))
        {
            this.pageModel.showNotification(discussion, "ALERT: Violating message");
        }
    }

    /**
     * Puts the message in the message section if the current discussion is the same as the message's
     *
     * @param discussion The discussion the message is a part of
     * @param message The message to display
     */
    private decideDisplayMessage(discussion: Discussion, message: Message): void {
        if (discussion.isBeingViewed) {
            this.pageModel.messageSection.displayMessage(message);
            this.pageModel.messageSection.removeLiveTyping(message.userId);
        } else {
            this.pageModel.discussionSection.setDiscussionUnread(discussion);

            const content = message.content as SafeString;
            if (!this.pageModel.windowHasFocus
                && (content.withBbcodeStripped().indexOf("@" + this.username) > -1 || discussion.alertsEnabled)) {
                this.pageModel.showNotification(discussion, `${message.username.asIs()}: ${content.withBbcodeStripped()}`);
            }
        }
    }

    /**
     * Handles when the discussion messages requested were received or when the local messages were already there and need loading
     *
     * @param discussion The discussion that the messages received are in or the discussion with the local messages already
     */
    public completeDiscussionSwitch(discussion: Discussion): void {
        this.pageModel.messageSection.clearMessages();
        this.pageModel.messageSection.clearLiveTyping();
        this.pageModel.messageSection.displayMessages(discussion);
        this.pageModel.messageSection.displayLiveTyping(discussion);
        this.pageModel.peopleSection.updateDiscussionUsersList(true);
        this.pageModel.messageSection.updateOurLiveTyping(discussion);
        this.pageModel.messageSection.hideMessageLoading();
        this.pageModel.messageSection.updateOurChatColor();
    }

    /**
     * Handles when a user comes online
     *
     * @param user The user who has comes online
     */
    public handleUserOnline(user: User): void {
        super.handleUserOnline(user);
        this.pageModel.peopleSection.refreshUsersOnlineList();
        this.pageModel.peopleSection.updateDiscussionUsersList(false);
    }

    /**
     * Handles when a user goes busy
     *
     * @param user The user who has goes busy
     */
    public handleUserBusy(user: User): void {
        super.handleUserBusy(user);
        this.pageModel.peopleSection.refreshUsersOnlineList();
        this.pageModel.peopleSection.updateDiscussionUsersList(false);
    }

    /**
     * Handles when a user goes offline
     *
     * @param user The user who has gone offline
     */
    public handleUserOffline(user: User): void {
        super.handleUserOffline(user);
        this.pageModel.peopleSection.refreshUsersOnlineList();
        this.pageModel.peopleSection.updateDiscussionUsersList(false);
        this.pageModel.messageSection.removeLiveTyping(user.id.toString());
    }

    /**
     * Handles when the list of users online are received
     *
     * @param userList The users who are online
     */
    public handleUsersOnline(userList: User[]): void {
        super.handleUsersOnline(userList);
        this.pageModel.peopleSection.refreshUsersOnlineList();
    }

    /**
     * Handles when the client is removed from a discussion
     *
     * @param discussionId The id of the discussion to remove
     */
    public handleRemoveDiscussion(discussionId: string): void {
        if (typeof this.currentDiscussion !== "undefined" && discussionId === this.currentDiscussion.id) {
            this.pageModel.messageSection.clearMessages();
            this.pageModel.messageSection.updateDisplayedTitle("- You were removed from the Discussion -");
            this._currentDiscussion = undefined;
        }
        super.handleRemoveDiscussion(discussionId);
    }

    /**
     * Handles when the discussion users list has been received
     *
     * @param discussion The discussion that the users are from
     * @param userList The list of users in the discussion
     * @param modList The moderators of that discussion
     */
    public handleDiscussionUsers(discussion: Discussion, userList: User[], modList: BooleanHash): void {
        super.handleDiscussionUsers(discussion, userList, modList);

        if (this._currentDiscussion === discussion) {
            this.pageModel.peopleSection.updateDiscussionUsersList();
        }
    }

    /**
     * Handles when a new live typing message is received
     *
     * @param message The live typing message
     */
    public handleNewLiveTyping(discussion: Discussion, message: Message): void {
        if (discussion.isBeingViewed) {
            this.pageModel.messageSection.createLiveTyping(message);
        } else {
            this.pageModel.discussionSection.updateDiscussionLiveTypingBar(discussion);
        }
    }

    /**
     * Handles when an update to an existing live typing message is received
     *
     * @param message The live typing message
     */
    public handleUpdateLiveTyping(discussion: Discussion, message: Message): void {
        if (discussion.isBeingViewed) {
            this.pageModel.messageSection.updateLiveTyping(message);
        } else {
            this.pageModel.discussionSection.updateDiscussionLiveTypingBar(discussion);
        }
    }

    /**
     * Handles when a removal of an existing live typing message is received
     *
     * @param userId The user id of the live typing message to remove
     */
    public handleRemoveLiveTyping(discussion: Discussion, userId: string): void {
        if (discussion.isBeingViewed) {
            this.pageModel.messageSection.removeLiveTyping(userId);
        } else if (Object.keys(discussion.liveTypingMessages).length === 0) {
            this.pageModel.discussionSection.removeDiscussionLiveTypingBar(discussion);
        }
    }

    /**
     * Handles when the list of terraria users who are online is received
     *
     * @param users The terraria users who are online
     */
    public handleTerrariaUsers(users: TerrariaUsersOnline): void {
        super.handleTerrariaUsers(users);
        for (const user of users) {
            this.pageModel.messageSection.updateTerrariaUserStatus(user.name, true, user.tagColour);
        }

        this.pageModel.peopleSection.setInGameUsersList(users);
    }

    /**
     * Handles when a user joins a terraria server
     *
     * @param username The username of the person who joined a terraria server
     */
    public handleTerrariaJoin(info: TerrariaJoinLeave): void {
        super.handleTerrariaJoin(info);
        this.pageModel.messageSection.updateTerrariaUserStatus(info.username, true, info.tagColour);
        this.pageModel.peopleSection.addUserToInGameList({
            name: info.username,
            tagColour: info.tagColour,
            tagName: info.tagName
        });
    }

    /**
     * Handles when a user leaves a terraria server
     *
     * @param username The username of the person who left a terraria server
     */
    public handleTerrariaLeave(info: TerrariaJoinLeave): void {
        super.handleTerrariaLeave(info);
        this.pageModel.messageSection.updateTerrariaUserStatus(info.username, false);
        this.pageModel.peopleSection.removeUserFromInGameList({
            name: info.username,
            tagColour: info.tagColour,
            tagName: info.tagName
        });
    }

    /**
     * Handles when a user changes their name on a terraria server
     *
     * @param oldUsername The old name of the user
     * @param newUsername The new name of the user
     */
    public handleTerrariaChangeName(oldUsername: string, newUsername: string): void {
        let info = this._terrariaUsers[oldUsername];
        if (!info) {
            return;
        }
        this.pageModel.peopleSection.removeUserFromInGameList({
            name: info.displayName,
            tagColour: info.tagColour,
            tagName: info.tagName
        });
        super.handleTerrariaChangeName(oldUsername, newUsername);
        info = this._terrariaUsers[oldUsername];
        this.pageModel.peopleSection.addUserToInGameList({
            name: info.displayName,
            tagColour: info.tagColour,
            tagName: info.tagName
        });
    }

    /**
     * Handles when message history is received for a discussion
     *
     * @param discussion The discussion that history has been received for
     */
    public onHistoryReceived(discussion: Discussion): void {
        this._pageModel.messageSection.onHistoryReceived(discussion);
    }

    /**
     * Handles when a chat message got revoked. This enables our client to remove the
     * live typing message.
     *
     * @param revokedInformation The discussionId and userId involved in the revokation
     */
    public handleChatMessageRevoked(revokedInformation: ChatMessageRevoked): void {
        super.handleChatMessageRevoked(revokedInformation);

        if (this._currentDiscussion !== undefined && this._currentDiscussion.id === revokedInformation.discID.toString()) {
            this._pageModel.messageSection.removeLiveTyping(revokedInformation.userID.toString());
        }
    }

    /**
     * Handles when one of our chat messages was denied. This removes the message from
     * our client.
     *
     * @param localMessageId The message id our client assigned to the local message
     */
    public handleChatMessageDenied(localMessageId: string): void {
        super.handleChatMessageDenied(localMessageId);
        this._pageModel.messageSection.removeLocalMessage(localMessageId);
    }

    /**
     * Handles when a user is added to a discussion we are a part of
     *
     * @param discussionUserAdd The info about who was added to what discussion
     */
    public handleDiscussionUserAdd(discussionUserAdd: DiscussionUserAdd): void {
        super.handleDiscussionUserAdd(discussionUserAdd);
        this.pageModel.peopleSection.updateDiscussionUsersList();
    }

    /**
     * Handles when a user is removed from a discussion we are a part of
     *
     * @param discussionUserRemove The info about who was removed from what discussion
     */
    public handleDiscussionUserRemove(discussionUserRemove: DiscussionUserRemove): void {
        super.handleDiscussionUserRemove(discussionUserRemove);
        this.pageModel.peopleSection.updateDiscussionUsersList();
    }

    /**
     * Handles when a discussion user gets promoted to moderator
     *
     * @param discussionUserPromote The information on who to promote from what discussion
     */
    public handleDiscussionUserPromote(discussionUserPromote: DiscussionUserPromote): void {
        super.handleDiscussionUserPromote(discussionUserPromote);
        this.pageModel.peopleSection.updateDiscussionUsersList();
    }

    /**
     * Handles when a discussion user gets demoted from moderator
     *
     * @param discussionUserPromote The information on who to demote from what discussion
     */
    public handleDiscussionUserDemote(discussionUserDemote: DiscussionUserDemote): void {
        super.handleDiscussionUserDemote(discussionUserDemote);
        this.pageModel.peopleSection.updateDiscussionUsersList();
    }

    /**
     * Toggles whether alerts are enabled for a discussion
     *
     * @param discussion The discussion to toggle alerts for
     */
    public toggleAlertsEnabled(discussion: Discussion): void {
        super.toggleAlertsEnabled(discussion);
        this.pageModel.messageSection.updateAlertBellStatus(discussion.alertsEnabled);
    }

    /**
     * Requests a message search from the server
     *
     * @param terms The search terms
     */
    public requestMessageSearch(terms: string, oldestId?: string, username?: string, systemName?: string): boolean {
        const currentDiscussion = this.currentDiscussion;
        if (typeof currentDiscussion !== "undefined") {
            currentDiscussion.ourLiveTypingMessage = this.pageModel.messageSection.getLastMessageInput();
            this.pageModel.discussionSection.switchSelectedDiscussion("-1");
        }

        if (super.requestMessageSearch(terms, oldestId, username, systemName)) {
            this.pageModel.messageSection.showMessageLoading();
            return true;
        }

        return false;
    }

    /**
     * Handles when the search results are received
     *
     * @param searchResults The list of messages pertaining to the search
     */
    public handleSearchResults(searchResults: SearchResults): void {
        const search = this.discussionSearch;
        if (search !== null) {
            const existingSearchMessagesCount = search.messages.length;
            super.handleSearchResults(searchResults);

            // Clear messages if they are not from this search
            if (existingSearchMessagesCount === 0) {
                this.pageModel.messageSection.clearMessages();
            }

            const messagesLength = search.messages.length - existingSearchMessagesCount;
            this.pageModel.messageSection.displaySearchResults(searchResults.terms, search.messages.slice(0, messagesLength));
            this.pageModel.messageSection.hideMessageLoading();
        }
    }

    /**
     * Handles the results of a user search
     *
     * @param searchUserResults The search results of the user search
     */
    public handleSearchUserResults(searchUserResults: SearchUserResults): void {
        this.pageModel.peopleSection.handleSearchUserResults(searchUserResults);
    }

    /**
     * Updates the name of a discussion
     *
     * @param discussion The discussion to update the name for
     * @param name The name to set
     */
    public updateDiscussionName(discussion: Discussion, name: string): void {
        super.updateDiscussionName(discussion, name);
        this.pageModel.discussionSection.updateDiscussionName(discussion);
    }

    /**
     * Requests the deep history of a message
     */
    public requestDiscussionDeepHistory(discussion: Discussion, message: Message): void {
        if (typeof this.currentDiscussion !== "undefined") {
            this.currentDiscussion.ourLiveTypingMessage = this.pageModel.messageSection.getLastMessageInput();
        }
        super.requestDiscussionDeepHistory(discussion, message);
        this.pageModel.discussionSection.switchSelectedDiscussion("-1");
        this.pageModel.messageSection.showMessageLoading();
    }

    /**
     * Requests the deep history a message from an unknown discussion
     *
     * @param messageId The message id to get the history for
     */
    public requestMessageDeepHistory(messageId: string): void {
        if (typeof this.currentDiscussion !== "undefined") {
            this.currentDiscussion.ourLiveTypingMessage = this.pageModel.messageSection.getLastMessageInput();
        }

        super.requestMessageDeepHistory(messageId);
        this.pageModel.discussionSection.switchSelectedDiscussion("-1");
        this.pageModel.messageSection.showMessageLoading();
    }

    /**
     * Requests older message for the deep history
     */
    public requestDiscussionDeepHistoryOlder(): void {
        const deepHistory = this.deepHistory;
        if (deepHistory !== null) {
            super.requestDiscussionDeepHistoryOlder();
            this.pageModel.messageSection.showMessageLoading();
        }
    }

    /**
     * Requests newer message for the deep history
     */
    public requestDiscussionDeepHistoryNewer(): void {
        const deepHistory = this.deepHistory;
        if (deepHistory !== null) {
            super.requestDiscussionDeepHistoryNewer();
            this.pageModel.messageSection.showMessageLoading();
        }
    }

    /**
     * Handles when the client receives the surrounding history of a message
     *
     * @param deepHistoryResults The surround history
     */
    public handleDeepHistory(deepHistoryResults: DeepHistoryResults): void {
        if (this.deepHistory === null || (this.deepHistory.discussion !== null && deepHistoryResults.discID.toString() !== this.deepHistory.discussion.id)) {
            return;
        }

        super.handleDeepHistory(deepHistoryResults);
        this.pageModel.messageSection.clearMessages();
        this.pageModel.messageSection.displayDeepHistory();
        this.pageModel.messageSection.hideMessageLoading();
    }

    /**
     * Handles when the client receives older deep history messages
     * @param deepHistoryOlderResults
     */
    public handleDeepHistoryOlder(deepHistoryOlderResults: DeepHistoryOlderResults): void {
        if (this.deepHistory === null || this.deepHistory.discussion === null || deepHistoryOlderResults.discID.toString() !== this.deepHistory.discussion.id) {
            return;
        }

        super.handleDeepHistoryOlder(deepHistoryOlderResults);
        if (deepHistoryOlderResults.messages.length === 0) {
            this.pageModel.messageSection.hideMessageLoading();
            return;
        }
        this.pageModel.messageSection.displayDeepHistoryOlder(this.deepHistory.messages.slice(0, deepHistoryOlderResults.messages.length));
        this.pageModel.messageSection.hideMessageLoading();
    }

    /**
     * Handles when the client receives newer deep history messages
     * @param deepHistoryOlderResults The results of the deep history
     */
    public handleDeepHistoryNewer(deepHistoryNewerResults: DeepHistoryNewerResults): void {
        if (this.deepHistory === null || this.deepHistory.discussion === null || deepHistoryNewerResults.discID.toString() !== this.deepHistory.discussion.id) {
            return;
        }

        super.handleDeepHistoryNewer(deepHistoryNewerResults);

        if (deepHistoryNewerResults.messages.length === 0) {
            this.switchDiscussion(this.deepHistory.discussion.id);
            return;
        }

        const startIndex = this.deepHistory.messages.length - deepHistoryNewerResults.messages.length;
        this.pageModel.messageSection.displayDeepHistoryNewer(this.deepHistory.messages.slice(startIndex));
        this.pageModel.messageSection.hideMessageLoading();
    }

    /**
     * Clears the state and starts the editing of the new discussion title
     */
    public startCreateNewDiscussion(): void {
        this._search = null;
        this._deepHistory = null;
        this._currentDiscussion = undefined;
        this.pageModel.messageSection.clearMessages();
        this.pageModel.messageSection.enableDiscussionTitleEditMode(true);
        this.creatingNewDiscussion = true;
    }

    /**
     * Creates a new discussion
     *
     * @param discussionName The name of the new discussion
     */
    public createDiscussion(discussionName: string): void {
        if (this.creatingNewDiscussion) {
            this.creatingNewDiscussion = false;
            super.createDiscussion(discussionName);
        }
    }

    /**
     * Handles when a user updates their avatar
     *
     * @param userAvatarUpdate The update information
     */
    public handleUserAvatarUpdate(userAvatarUpdate: UserAvatarUpdate): void {
        super.handleUserAvatarUpdate(userAvatarUpdate);
        const user = this.phaseUsers[userAvatarUpdate.userID.toString()];
        if (typeof user !== "undefined") {
            this.pageModel.updateUserAvatar(user);
            if (user.id.toString() === this.id) {
                this.pageModel.updateAvatar(user.avatar);
            }
        }
    }

    /**
     * Re-displays login page on failed session authentication
     */
    public handleLoginFailed() {
        this.pageModel.displayLoginPage();
    }
}

export default WebClient;
