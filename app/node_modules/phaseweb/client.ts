import Client from "phaseclient/client";
import Config from "phaseclient/config";
import Cookie from "phaseclient/cookie";
import Discussion from "phaseclient/discussion";
import { BooleanHash, DiscussionHash, UserHash } from "phaseclient/hash";
import Message from "phaseclient/message";
import Network from "phaseclient/network";
import SafeString from "phaseclient/safestring";
import User from "phaseclient/user";
import EditQueue from "phasecore/editqueue";
import ChatMessageRevoked from "phasecore/messagetypes/chatmessagerevoked";
import { Discussion as ReceivedDiscussion, Discussions } from "phasecore/messagetypes/discussions";
import DiscussionUserAdd from "phasecore/messagetypes/discussionuseradd";
import DiscussionUserRemove from "phasecore/messagetypes/discussionuserremove";
import SearchResults from "phasecore/messagetypes/searchresults";
import System from "phasecore/system";
import ElementIdentifiers from "phaseweb/elementidentifiers";
import PageModel from "phaseweb/pagemodel";

class WebClient extends Client {
    protected pageModel: PageModel;
    protected initialDiscussionsReceived: boolean = false;

    constructor(configuration: Config) {
        super(configuration);
    }

    public setupPageModel(pageModel: PageModel): void {
        if (!this.pageModel) {
            this.pageModel = pageModel;
            this.pageModel.checkSession();
        }
    }

    public setUsername(username: string): void {
        super.setUsername(username);
        this.pageModel.updateUsername(username);
    }

    public getPageModel(): PageModel {
        return this.pageModel;
    }

    /* Updates the users avatar in the chat input area */
    public setAvatar(avatar: string): void {
        super.setAvatar(avatar);
        this.getPageModel().updateAvatar(this.getAvatar());
        this.getPageModel().peopleSection.refreshUsersOnlineList();
    }

    /* Adds a phase users information to the clients phase users object */
    public addPhaseUser(user: User): void {
        super.addPhaseUser(user);
        this.getPageModel().updateUserAvatar(user);
    }

    protected onDiscussionListReceived(discussions: Discussion[]): void {
        this.initialDiscussionsReceived = true;
        this.getPageModel().discussionSection.setDiscussionsList(discussions);
    }

    /* Appends a discussion to the clients list of discussions and updates page */
    public addDiscussion(discussion: Discussion): void {
        super.addDiscussion(discussion);

        if (this.initialDiscussionsReceived) {
            this.getPageModel().discussionSection.prependDiscussionsList(discussion);
        }
    }

    /**
     * Switches the current discussion
     *
     * @param discussionId The id of the discussion to switch to
     * @param eventElem The element that was clicked to cause this switch
     * @override
     */
    public switchDiscussion(discussionId: number): void {
        const discussion = this.getDiscussions()[discussionId];

        if (!discussion) {
            return;
        }

        if (typeof this.currentDiscussion !== "undefined") {
            this.currentDiscussion.setOurLiveTypingMessage(this.getPageModel().messageSection.getLastMessageInput());
        }

        super.switchDiscussion(discussionId);

        // If discussion has members, then the info for the discussion has been obtained already
        if (discussion.getMembers().length > 0) {
            this.getPageModel().messageSection.fadeOutMessages();
            this.completeDiscussionSwitch(discussion);
            this.getPageModel().messageSection.fadeInMessages();
        } else {
            this.getPageModel().messageSection.showMessageLoading();
        }

        this.getPageModel().discussionSection.switchSelectedDiscussion(discussionId);
        this.getPageModel().discussionSection.setDiscussionRead(discussion);
        this.getPageModel().messageSection.updateDisplayedTitle(discussion.getName());
        this.getPageModel().messageSection.updateAlertBellStatus(discussion.getHasAlertsEnabled());
    }

    /**
     * When a chat message is to be displayed it will go through this function.
     * It must be decided whether the message is allowed to be displayed according
     * to the configuration.
     *
     * @param discussion The discussion the chat message has come from
     * @param message The message itself
     */
    public handleChatMessage(discussion: Discussion, message: Message): void {
        if (!this.getConfiguration().useAndDisplayJoinLeaveMessages
            && message.getUserId() === System.joinLeaveMessageUserId
            && message.getTag().length > 0) {
            return;
        }

        const liveTypingExists = Object.keys(discussion.getLiveTypingMessages()).length > 0;
        super.handleChatMessage(discussion, message);

        // Force update the terraria status if it is set to offline for a user that just sent a message
        if (message.getTag().length > 0 && typeof this.terrariaUsers[message.getUsername().asIs() || message.getGuestname().asIs()] === "undefined") {
            super.handleTerrariaJoin(message.getUsername().asIs() || message.getGuestname().asIs(), message.getTagColour());
            this.getPageModel().messageSection.updateTerrariaUserStatus(message.getUsername().asIs() || message.getGuestname().asIs(), true, message.getTagColour());
        }

        if (liveTypingExists && Object.keys(discussion.getLiveTypingMessages()).length === 0) {
            this.getPageModel().discussionSection.removeDiscussionLiveTypingBar(discussion);
        }

        this.getPageModel().discussionSection.moveDiscussionToTopOfList(discussion);
        this.getPageModel().discussionSection.updateDiscussionEntryMessagePreview(discussion);
        this.decideDisplayMessage(discussion, message);
    }

    /**
     * Puts the message in the message section if the current discussion is the same as the message's
     *
     * @param discussion The discussion the message is a part of
     * @param message The message to display
     */
    private decideDisplayMessage(discussion: Discussion, message: Message): void {
        if (discussion.getIsBeingViewed()) {
            const lastMessage: Message | undefined = discussion.getMessages().length > 1
                ? discussion.getMessages()[discussion.getMessages().length - 2] as Message
                : undefined;
            this.getPageModel().messageSection.displayMessage(lastMessage, message);
            this.getPageModel().messageSection.removeLiveTyping(message.getUserId());
        } else {
            this.getPageModel().discussionSection.setDiscussionUnread(discussion);

            const content = message.getContent() as SafeString;
            if (!this.getPageModel().getWindowHasFocus()
                && (content.withBbcodeStripped().indexOf(this.getUsername()) > -1 || discussion.getHasAlertsEnabled())) {
                this.getPageModel().showNotification(discussion, `${message.getUsername().asIs()}: ${content.withBbcodeStripped()}`);
            }
        }
    }

    /**
     * Handles when the discussion messages requested were received or when the local messages were already there and need loading
     *
     * @param discussion The discussion that the messages received are in or the discussion with the local messages already
     */
    public completeDiscussionSwitch(discussion: Discussion): void {
        this.getPageModel().messageSection.clearMessages();
        this.getPageModel().messageSection.clearLiveTyping();
        this.getPageModel().messageSection.displayMessages(discussion);
        this.getPageModel().messageSection.displayLiveTyping(discussion);
        this.getPageModel().peopleSection.updateDiscussionUsersList(true);
        this.getPageModel().messageSection.updateOurLiveTyping(discussion);
        this.getPageModel().messageSection.hideMessageLoading();
        this.getPageModel().messageSection.updateOurChatColor();
    }

    /**
     * Handles when a user comes online
     *
     * @param user The user who has come online
     */
    public handleUserOnline(user: User): void {
        super.handleUserOnline(user);
        this.getPageModel().peopleSection.refreshUsersOnlineList();
        this.getPageModel().peopleSection.updateDiscussionUsersList(false);
    }

    /**
     * Handles when a user goes offline
     *
     * @param user The user who has gone offline
     */
    public handleUserOffline(user: User): void {
        super.handleUserOffline(user);
        this.getPageModel().peopleSection.refreshUsersOnlineList();
        this.getPageModel().peopleSection.updateDiscussionUsersList(false);
        this.getPageModel().messageSection.removeLiveTyping(user.getId());
    }

    /**
     * Handles when the list of users online are received
     *
     * @param userList The users who are online
     */
    public handleUsersOnline(userList: User[]): void {
        super.handleUsersOnline(userList);
        this.getPageModel().peopleSection.refreshUsersOnlineList();
    }

    /**
     * Handles when the discussion users list has been received
     *
     * @param discussion The discussion that the users are from
     * @param userList The list of users in the discussion
     * @param modList The moderators of that discussion
     */
    public handleDiscussionUsers(discussion: Discussion, userList: User[], modList: BooleanHash): void {
        super.handleDiscussionUsers(discussion, userList, modList);

        if (this.currentDiscussion === discussion) {
            this.getPageModel().peopleSection.updateDiscussionUsersList();
        }
    }

    /**
     * Handles when a new live typing message is received
     *
     * @param message The live typing message
     */
    public handleNewLiveTyping(discussion: Discussion, message: Message): void {
        if (discussion.getIsBeingViewed()) {
            this.getPageModel().messageSection.createLiveTyping(message);
        } else {
            this.getPageModel().discussionSection.updateDiscussionLiveTypingBar(discussion);
        }
    }

    /**
     * Handles when an update to an existing live typing message is received
     *
     * @param message The live typing message
     */
    public handleUpdateLiveTyping(discussion: Discussion, message: Message): void {
        if (discussion.getIsBeingViewed()) {
            this.getPageModel().messageSection.updateLiveTyping(message);
        } else {
            this.getPageModel().discussionSection.updateDiscussionLiveTypingBar(discussion);
        }
    }

    /**
     * Handles when a removal of an existing live typing message is received
     *
     * @param userId The user id of the live typing message to remove
     */
    public handleRemoveLiveTyping(discussion: Discussion, userId: number): void {
        if (discussion.getIsBeingViewed()) {
            this.getPageModel().messageSection.removeLiveTyping(userId);
        } else if (Object.keys(discussion.getLiveTypingMessages()).length === 0) {
            this.getPageModel().discussionSection.removeDiscussionLiveTypingBar(discussion);
        }
    }

    /**
     * Handles when a user joins a terraria server
     *
     * @param username The username of the person who joined a terraria server
     */
    public handleTerrariaJoin(username: string, tagColor: string): void {
        super.handleTerrariaJoin(username, tagColor);
        this.getPageModel().messageSection.updateTerrariaUserStatus(username, true, tagColor);
    }

    /**
     * Handles when a user leaves a terraria server
     *
     * @param username The username of the person who left a terraria server
     */
    public handleTerrariaLeave(username: string): void {
        super.handleTerrariaLeave(username);
        this.getPageModel().messageSection.updateTerrariaUserStatus(username, false);
    }

    /**
     * Handles when a user changes their name on a terraria server
     *
     * @param oldUsername The old name of the user
     * @param newUsername The new name of the user
     */
    public handleTerrariaChangeName(oldUsername: string, newUsername: string): void {
        super.handleTerrariaChangeName(oldUsername, newUsername);
    }

    /**
     * Handles when message history is received for a discussion
     *
     * @param discussion The discussion that history has been received for
     */
    public onHistoryReceived(discussion: Discussion): void {
        this.pageModel.messageSection.onHistoryReceived(discussion);
    }

    /**
     * Handles when a chat message got revoked. This enables our client to remove the
     * live typing message.
     *
     * @param revokedInformation The discussionId and userId involved in the revokation
     */
    public handleChatMessageRevoked(revokedInformation: ChatMessageRevoked): void {
        super.handleChatMessageRevoked(revokedInformation);

        if (this.currentDiscussion !== undefined && this.currentDiscussion.getId() === revokedInformation.discID) {
            this.pageModel.messageSection.removeLiveTyping(revokedInformation.userID);
        }
    }

    /**
     * Handles when one of our chat messages was denied. This removes the message from
     * our client.
     *
     * @param localMessageId The message id our client assigned to the local message
     */
    public handleChatMessageDenied(localMessageId: number): void {
        super.handleChatMessageDenied(localMessageId);
        this.pageModel.messageSection.removeLocalMessage(localMessageId);
    }

    /**
     * Handles when a user is added to a discussion we are a part of
     *
     * @param discussionUserAdd The info about who was added to what discussion
     */
    public handleDiscussionUserAdd(discussionUserAdd: DiscussionUserAdd): void {
        super.handleDiscussionUserAdd(discussionUserAdd);
        this.getPageModel().peopleSection.updateDiscussionUsersList();
    }

    /**
     * Handles when a user is removed from a discussion we are a part of
     *
     * @param discussionUserRemove The info about who was removed from what discussion
     */
    public handleDiscussionUserRemove(discussionUserRemove: DiscussionUserRemove): void {
        super.handleDiscussionUserRemove(discussionUserRemove);
        this.getPageModel().peopleSection.updateDiscussionUsersList();
    }

    /**
     * Toggles whether alerts are enabled for a discussion
     *
     * @param discussion The discussion to toggle alerts for
     */
    public toggleAlertsEnabled(discussion: Discussion): void {
        super.toggleAlertsEnabled(discussion);
        this.getPageModel().messageSection.updateAlertBellStatus(discussion.getHasAlertsEnabled());
    }

    /**
     * Requests a message search from the server
     *
     * @param terms The search terms
     */
    public requestMessageSearch(terms: string): void {
        super.requestMessageSearch(terms);
        this.getPageModel().messageSection.showMessageLoading();
    }

    /**
     * Handles when the search results are received
     *
     * @param searchResults The list of messages pertaining to the search
     */
    public handleSearchResults(searchResults: SearchResults): void {
        if (typeof this.getCurrentDiscussion() === "undefined") {
            const messages: Message[] = [];
            for (const message of searchResults.results) {
                messages.push(new Message(
                    message.messageID,
                    message.userID,
                    message.avatar,
                    message.guest ? "" : message.username,
                    message.guest ? message.username : "",
                    message.content,
                    message.timestamp,
                    message.systemName,
                    message.tag || "",
                    message.tagcolour || ""
                ));
            }
            this.getPageModel().messageSection.clearMessages();
            this.getPageModel().messageSection.displaySearchResults(messages);
            this.getPageModel().messageSection.hideMessageLoading();
        }
    }

    /**
     * Updates the name of a discussion
     *
     * @param discussion The discussion to update the name for
     * @param name The name to set
     */
    public updateDiscussionName(discussion: Discussion, name: string): void {
        super.updateDiscussionName(discussion, name);
        this.getPageModel().discussionSection.updateDiscussionName(discussion);
    }
}

export default WebClient;
