import * as $ from "jquery";
import Discussion from "phaseclient/discussion";
import Message from "phaseclient/message";
import TextDifference from "phaseclient/textdifference";
import { EditQueueEntry } from "phasecore/editqueue";
import System from "phasecore/system";
import Client from "phaseweb/client";
import ElementIdentifiers from "phaseweb/elementidentifiers";
import Hash from "phaseweb/hash";
import Templates from "phaseweb/templates";
import Translator from "phaseweb/translator";

// Padding used to get around anomolies with scroll not being exactly at the bottom
const SCROLL_DETECTION_PADDING = 10;

class MessageSection {
    private _client: Client;
    private lastMessageInput: string;
    private _messageInputHadCommandPrefix: boolean;
    private _contextMenuMessageId: number;
    private _translator: Translator;
    private _displayedMessagesCount: number = 0;

    constructor(client: Client) {
        this._client = client;
        this._translator = new Translator();
        this.lastMessageInput = "";
        this._messageInputHadCommandPrefix = false;
        this.hideMessageLoading();
        this.hideContextMenu();
    }

    public getLastMessageInput(): string {
        return this.lastMessageInput;
    }

    /**
     * Updates the title displayed in the GUI
     *
     * @param name The title of the messages (such as discussion name)
     */
    public updateDisplayedTitle(name: string): void {
        $(ElementIdentifiers.ChatSection.title).text(name);
    }

    /**
     * Clears the messages diplayed in the message list
     */
    public clearMessages(): void {
        $(ElementIdentifiers.ChatSection.list).empty();
        this.hideContextMenu();
        this._displayedMessagesCount = 0;
    }

    /**
     * Displays 40 messages in the chat list from the specified discussion
     *
     * @param discussion The discussion to display messages for
     */
    public displayMessages(discussion: Discussion): void {
        const messages = discussion.getMessages();
        const minIndex = messages.length - 41 < 0 ? 0 : messages.length - 41;
        for (let i = minIndex; i < messages.length; i++) {
            this.appendMessage(i >= 0 ? messages[i - 1] as Message : undefined, messages[i] as Message);
        }

        this.scrollToBottom();
    }

    /**
     * Gets whether a message should be combined with the last message
     *
     * @param message The message
     * @param lastMessage The last message
     */
    private messageShouldBeCombined(message: Message, lastMessage: Message): boolean {
        return lastMessage.getUserId() === message.getUserId()
                    && Math.abs(lastMessage.getTimestamp() - message.getTimestamp()) <= 60
                    && lastMessage.getTag() === message.getTag()
                    && ((lastMessage.getUsername().asIs().length > 0 && lastMessage.getUsername().asIs() === message.getUsername().asIs())
                        || (lastMessage.getGuestname().asIs().length > 0 && lastMessage.getGuestname().asIs() === message.getGuestname().asIs()));
    }

    /**
     * Adds a message to the message display at the end (bottom)
     *
     * @param lastMessage The last message displayed
     * @param message The message to add to the message display
     */
    private appendMessage(lastMessage: Message | undefined, message: Message) {
        const discussion = this._client.getCurrentDiscussion();

        // If join/leave message and config setting is not to display these, do not handle the message
        if (!this._client.getConfiguration().useAndDisplayJoinLeaveMessages && message.getUserId() === -2 && message.getTag().length !== 0) {
            return;
        } else if (typeof discussion === "undefined") {
            return;
        }

        let addedMessage: JQuery | null = null;

        // If the config has it set that messages are to be combined then checks need to be done
        if (this._client.getConfiguration().combineMessages) {
            // If the first message or is a join/leave message (so it contains ip, origin, that must be kept in-tact etc)
            if (!lastMessage || message.getUserId() === System.joinLeaveMessageUserId) {
                addedMessage = $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this._client, discussion, message));
            } else {
                // Combine messages that were sent by the same user consecutively, under a minute in difference
                if (this.messageShouldBeCombined(message, lastMessage)) {
                    addedMessage = this.combineMessage(message);
                } else {
                    const existingLiveTyping = $(ElementIdentifiers.LiveMessage.identifier(message.getUserId()));
                    if (existingLiveTyping.length && this._client.getConfiguration().mergeLiveTypingWithCompleteChatArea) {
                        addedMessage = existingLiveTyping.before(Templates.ChatMessage(this._client, discussion, message));
                    } else {
                        addedMessage = $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this._client, discussion, message));
                    }
                }
            }
        // Otherwise just append the message to the list
        } else {
            addedMessage = $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this._client, discussion, message));
        }

        if (addedMessage !== null) {
            this.scrollAfterImagesLoad(addedMessage);
        }
        this._displayedMessagesCount++;
    }

    /**
     * Combines a message with the last message in the list
     *
     * @param message The message to get new content from
     */
    private combineMessage(message: Message): JQuery {
        return $(`${ElementIdentifiers.ChatSection.list} li:not('.in-progress'):last`)
            .find(".chat-message-content")
            .append(`<div class="chat-line">${message.getContentStyled()}</div>`);
    }

    /**
     * Fixes the scroll position when an image loaded that caused it to change
     *
     * @param element The element with images that are loading
     */
    private scrollAfterImagesLoad(element: any): void {
        const _this = this;
        element.find(".autoLinkedImage").each(function() {
            _this.onImageLoad($(this), (width: number, height: number) => {
                _this.scrollBy(height);
            });
        });
    }

    /**
     * Adds a message to the message display at the beginning (top)
     *
     * @param message The message to add to the message display
     */
    private prependMessage(message: Message): void {
        const discussion = this._client.getCurrentDiscussion();

        // If join/leave message and config setting is not to display these, do not handle the message
        if (!this._client.getConfiguration().useAndDisplayJoinLeaveMessages && message.getUserId() === -2 && message.getTag().length !== 0) {
            return;
        } else if (typeof discussion === "undefined") {
            return;
        }

        let addedMessage: JQuery | null = null;

        // If the config has it set that messages are to be combined then checks need to be done
        // TODO: Fix this
        /*if (this._client.getConfiguration().combineMessages) {
            // If the first message or is a join/leave message (so it contains ip, origin, that must be kept in-tact etc)
            if (!lastMessage || message.getUserId() === System.joinLeaveMessageUserId) {
                addedMessage = $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this._client, discussion, message));
            } else {
                // Combine messages that were sent by the same user consecutively, under a minute in difference
                if (this.messageShouldBeCombined(message, lastMessage)) {
                    addedMessage = this.combineMessage(message);
                } else {
                    const existingLiveTyping = $(ElementIdentifiers.LiveMessage.identifier(message.getUserId()));
                    if (existingLiveTyping.length && this._client.getConfiguration().mergeLiveTypingWithCompleteChatArea) {
                        addedMessage = existingLiveTyping.before(Templates.ChatMessage(this._client, discussion, message));
                    } else {
                        addedMessage = $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this._client, discussion, message));
                    }
                }
            }
        // Otherwise just append the message to the list
        } else {*/
        addedMessage = $(ElementIdentifiers.ChatSection.list).prepend(Templates.ChatMessage(this._client, discussion, message));
        this._displayedMessagesCount++;
        // }
    }

    /**
     * Displays a message in the message list by appending it
     *
     * @param lastMessage The last message displayed
     * @param message The message to add to the message display
     */
    public displayMessage(lastMessage: Message | undefined, message: Message): void {
        if (message.getUserId() === this._client.getId() && this._client.getConfiguration().mergeLiveTypingWithCompleteChatArea) {
            if (message.getContent().asIs() === $(ElementIdentifiers.ChatInput.textInput).val()) {
                const discussion = this._client.getCurrentDiscussion();
                if (discussion) {
                    if (this._client.getConfiguration().mergeLiveTypingWithCompleteChatArea) {
                        $(ElementIdentifiers.ChatInput.main).after(Templates.ChatMessage(this._client, discussion, message));
                    }
                }
                return;
            }
        }

        const scrollIsAtBottom = this.getScrollIsAtBottom();
        this.appendMessage(lastMessage, message);

        // Scroll the chat to the bottom if they were at the bottom before
        if (scrollIsAtBottom) {
            // Remove messages that go over max of 40 in display
            if (this._displayedMessagesCount > 40) {
                this.removeOldestMessages(this._displayedMessagesCount - 40);
            }
            this.scrollToBottom();
        }
    }

    /**
     * Remove the oldest n messages from the discussion message list
     */
    public removeOldestMessages(amount: number): void {
        if (amount < 0) {
            amount = 0;
        }

        $(ElementIdentifiers.ChatSection.list).children().each((index, elem) => {
            if (index <= amount - 1) {
                $(elem).remove();
                this._displayedMessagesCount -= $(elem).find(".chat-message-right").find(".chat-message-content").children().length + 1;
            }
        });
        // .slice(0, amount).remove();
    }

    /**
     * Returns the width and height of an image after it loads
     *
     * @param image The image to track for loading
     * @param callback The function to call when the image has loaded
     */
    private onImageLoad(image: any, callback: (width: number, height: number) => void): void {
        let isDone = false;
        const onLoad = () => {
            done(image.width(), image.height());
        };
        image.on("load", onLoad);

        function done(width: number, height: number) {
            if (isDone) {
                return;
            }

            isDone = true;
            image.off("load", onLoad);

            callback(width, height);
        }
    }

    /**
     * Get whether scroll is at bottom
     */
    public getScrollIsAtBottom(): boolean {
        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        const maximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
        const currentScroll = chatElement[0].scrollTop;
        const scrollIsAtBottom = currentScroll >= Math.ceil(maximumScroll) - SCROLL_DETECTION_PADDING;

        return scrollIsAtBottom;
    }

    /**
     * Scroll the message list by the specified amount
     */
    public scrollBy(amount: number): void {
        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        chatElement[0].scrollTop += amount;
    }

    /**
     * Scrolls to the given height from the top
     *
     * @param height The height to set scroll top to
     */
    public scrollTo(height: number): void {
        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        chatElement[0].scrollTop = height;
    }

    /**
     * Scroll the message list to the bottom
     */
    public scrollToBottom(): void {
        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        const maximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
        chatElement[0].scrollTop = maximumScroll;
    }

    /**
     * Displays live typing messages for the specified discussion
     *
     * @param discussion The discussion to display live typing messages for
     */
    public displayLiveTyping(discussion: Discussion): void {
        const liveTypingMessages = discussion.getLiveTypingMessages();

        let message: Message;
        for (const key in liveTypingMessages) {
            if (liveTypingMessages.hasOwnProperty(key)) {
                message = liveTypingMessages[key] as Message;
                if (this._client.getConfiguration().mergeLiveTypingWithCompleteChatArea) {
                    $(ElementIdentifiers.ChatSection.list).append(Templates.LiveTypingMessage(this._client, discussion, message));
                } else {
                    $(ElementIdentifiers.ChatSection.liveTyping).append(Templates.LiveTypingMessage(this._client, discussion, message));
                }
            }
        }

        this.scrollToBottom();
    }

    /**
     * Changes last message and current input field message to the last stored
     *
     * @param discussion The discussion to get our live typing message from
     */
    public updateOurLiveTyping(discussion: Discussion): void {
        const message = discussion.getOurLiveTypingMessage();
        this.lastMessageInput = message || "";

        $(ElementIdentifiers.ChatInput.textInput).val(message || "");
    }

    /**
     * Creates a live typing element at the bottom of the message list
     *
     * @param message The message to put in the live typing preview list
     */
    public createLiveTyping(message: Message): void {
        const discussion = this._client.getCurrentDiscussion();

        if (typeof discussion !== "undefined") {
            this.removeLiveTyping(message.getUserId());
            const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
            const maximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
            const currentScroll = chatElement[0].scrollTop;

            const scrollWasAtBottom = this.getScrollIsAtBottom();
            if (this._client.getConfiguration().mergeLiveTypingWithCompleteChatArea) {
                $(ElementIdentifiers.ChatSection.list).append(Templates.LiveTypingMessage(this._client, discussion, message));
            } else {
                $(ElementIdentifiers.ChatSection.liveTyping).append(Templates.LiveTypingMessage(this._client, discussion, message));
            }

            // Scroll the chat to the bottom if they were at the bottom before
            if (scrollWasAtBottom) {
                this.scrollToBottom();
            }
        }
    }

    /**
     * Updates the content of an existing live typing element
     */
    public updateLiveTyping(message: Message): void {
        const scrollWasAtBottom = this.getScrollIsAtBottom();
        $(ElementIdentifiers.LiveMessage.identifier(message.getUserId()))
            .find(ElementIdentifiers.LiveMessage.content)
            .html(message.getContentStyled());

        // Scroll the chat to the bottom if they were at the bottom before
        if (scrollWasAtBottom) {
            this.scrollToBottom();
        }
    }

    /**
     * Removes an existing live typing element based on userId
     *
     * @param userId The user id of the user to remove live typing preview for
     */
    public removeLiveTyping(userId: number): void {
        $(ElementIdentifiers.LiveMessage.identifier(userId)).remove();
    }

    /**
     * Removes all currently displayed live typing elements
     */
    public clearLiveTyping(): void {
        $(ElementIdentifiers.ChatSection.liveTyping).children().remove();
    }

    /**
     * Updates the displayed status of chat from an in-game user
     */
    public updateTerrariaUserStatus(name: string, online: boolean, tagColor?: string): void {
        if (online && tagColor) {
            $(`.chat-terraria-${Hash(name)}`)
                .removeClass(ElementIdentifiers.Message.terrariaOffline.substr(1))
                .addClass(ElementIdentifiers.Message.terrariaOnline.substr(1))
                .css("background", tagColor);
        } else {
            $(`.chat-terraria-${Hash(name)}`)
                .removeClass(ElementIdentifiers.Message.terrariaOnline.substr(1))
                .addClass(ElementIdentifiers.Message.terrariaOffline.substr(1))
                .css("background", "");
        }
    }

    /**
     * Updates the chat input username color to match their rank
     */
    public updateOurChatColor(): void {
        const currentDiscussion = this._client.getCurrentDiscussion();

        if (currentDiscussion) {
            const isCreator = this._client.getId() === currentDiscussion.getCreator();
            const isMod = currentDiscussion.getModerators()[this._client.getId()];
            const creatorClass = ElementIdentifiers.Message.creator.substr(1);
            const modClass = ElementIdentifiers.Message.moderator.substr(1);

            const nameElement = $(ElementIdentifiers.ChatInput.main).find(ElementIdentifiers.ChatInput.username);
            if (isCreator) {
                nameElement.addClass(creatorClass).removeClass(modClass);
            } else if (isMod) {
                nameElement.removeClass(creatorClass).addClass(modClass);
            } else {
                nameElement.removeClass(creatorClass).removeClass(modClass);
            }
        }
    }

    /**
     * Updates the displayed username in the chat input section
     *
     * @param name The name to display ours as
     */
    public updateOurDisplayedName(name: string): void {
        $(ElementIdentifiers.ChatInput.main).find(ElementIdentifiers.ChatInput.username).text(name);
    }

    /**
     * Changes the thumbnail image of a video into the youtube video player
     */
    private displayYoutubeVideo(elem: any): void {
      const videoID = elem.attr("data-id");
      elem.empty();
      elem.append(`<iframe class="youtube-iframe"
                           src="https://www.youtube.com/embed/${videoID}?modestbranding=1&rel=0&autoplay=1&wmode=transparent&theme=light&color=white"
                           frameborder="0" allowfullscreen></iframe>`);
    }

    /**
     * Shows the loading icon in the messages section
     */
    public showMessageLoading(): void {
        $(ElementIdentifiers.ChatSection.loading).show();
        $(ElementIdentifiers.ChatSection.scrollSection).fadeTo(300, 0.3);
    }

    /**
     * Hides the loading icon in the messages section
     */
    public hideMessageLoading(): void {
        $(ElementIdentifiers.ChatSection.loading).hide();
        $(ElementIdentifiers.ChatSection.scrollSection).fadeTo(300, 1);
    }

    /**
     * Fades the messages section from 0.3 to 1
     */
    public fadeInMessages(): void {
        $(ElementIdentifiers.ChatSection.scrollSection)
            .stop(true)
            .fadeTo(100, 1);
    }

    /**
     * Fades the messages section from 1 to 0.6
     */
    public fadeOutMessages(): void {
        $(ElementIdentifiers.ChatSection.scrollSection)
            .stop(true)
            .fadeTo(0, 0.6);
    }

    /**
     * Moves the chat input back to the bottom of the chat area
     */
    private moveChatInputToBottom(): void {
        $(ElementIdentifiers.ChatInput.main).detach().appendTo($(ElementIdentifiers.ChatSection.main));
        $(ElementIdentifiers.ChatInput.textInput).focus();
        $(ElementIdentifiers.ChatInput.main).css("padding-left", "5px");
    }

    /**
     * Moves the chat input into the message list with the other messages
     */
    private moveChatInputToMessageList(): void {
        $(ElementIdentifiers.ChatInput.main).detach().appendTo($(ElementIdentifiers.ChatSection.list));
        $(ElementIdentifiers.ChatInput.textInput).focus();
        $(ElementIdentifiers.ChatInput.main).css("padding-left", "15px");
    }

    private hideContextMenu(): void {
        $(ElementIdentifiers.ChatSection.contextMenu).offset({
            left: -500,
            top: -500
        });
    }

    public onHistoryReceived(discussion: Discussion): void {
        if (discussion === this._client.getCurrentDiscussion()) {
            this.displayOlderMessages();
        }
    }

    private displayOlderMessages(): void {
        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        const discussion = this._client.getCurrentDiscussion() as Discussion;
        const messages = discussion.getMessages();
        const oldMaximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;

        // If there are more messages available to display, then they will be prepended
        if (messages.length > 40 && this._displayedMessagesCount !== messages.length) {
            const startIndex = messages.length - this._displayedMessagesCount - 1;
            let minIndex = startIndex - 40;
            if (minIndex < 0) {
                minIndex = 0;
            }

            for (let i = startIndex; i >= minIndex; i--) {
                this.prependMessage(messages[i] as Message);
            }

            // If scroll top is 0 this means the elements caused the other messages to go further down the screen
            if (chatElement[0].scrollTop === 0) {
                const newMaximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
                this.scrollTo(newMaximumScroll - oldMaximumScroll);
            }
        }
    }

    /**
     * Removes a message that exists only locally identified by a local id
     *
     * @param localMessageId The local message id of the message
     */
    public removeLocalMessage(localMessageId: number): void {
        $(ElementIdentifiers.Message.local(localMessageId)).remove();
    }

    /**********
     * EVENTS *
     **********/

    public registerEvents(): void {
        this.registerPageClick();
        this.registerMessageSend();
        this.registerTextInput();
        this.registerVideoThumbnailClick();
        this.registerMessageContextMenu();
        this.registerContextMenuItemClick();
        this.registerScroll();
    }

    /**
     * Clears the context menu when the page is clicked
     */
    private registerPageClick(): void {
        $("body").on("click", () => {
            this.hideContextMenu();
        });
    }

    /**
     * Tells the client to take the necessary steps to send the message
     */
    private handleMessageSend(context: any): void {
        const chatText = $(context).val();
        this._client.sendChatMessage(chatText);
        $(context).val("");
        this.lastMessageInput = "";
    }

    /**
     * Registers the submit event of the chat message form for sending a message
     */
    private registerMessageSend(): void {
        const self = this;
        $(ElementIdentifiers.ChatInput.textInput).on("keydown", function(event) {
            if (event.keyCode === 13 && !event.shiftKey) {
                if ($(this).val().length > 0) {
                    const scrollIsAtBottom = self.getScrollIsAtBottom();
                    self.handleMessageSend(this);
                    $(this).text("");
                    this.style.height = "0px";
                    this.style.height = (this.scrollHeight) + "px";
                    self.moveChatInputToBottom();
                    event.preventDefault();

                    if (scrollIsAtBottom) {
                        self.scrollToBottom();
                    }
                }
            }
        });
    }

    private registerTextInput(): void {
        const self = this;
        $(ElementIdentifiers.ChatInput.textInput).on("input", function(event) {
            const scrollIsAtBottom = self.getScrollIsAtBottom();
            const currentMessage = $(this).val();

            if (currentMessage.length === 0) {
                self.moveChatInputToBottom();
            } else if (self.lastMessageInput.length === 0) {
                if (self._client.getConfiguration().mergeLiveTypingWithCompleteChatArea) {
                    self.moveChatInputToMessageList();
                }
            }

            let queue: EditQueueEntry[] | null = null;
            if (currentMessage.indexOf("/") === 0) {
                if (!self._messageInputHadCommandPrefix) {
                    queue = TextDifference.getEditQueue(self.lastMessageInput, "");
                }
            } else {
                if (self._messageInputHadCommandPrefix) {
                    self._messageInputHadCommandPrefix = false;
                    self.lastMessageInput = "";
                }

                queue = TextDifference.getEditQueue(self.lastMessageInput, currentMessage);
            }

            self.lastMessageInput = currentMessage;

            if (queue !== null) {
                self._client.sendEditQueue(queue);
            }
            this.style.height = "0px";
            this.style.height = (this.scrollHeight) + "px";

            if (scrollIsAtBottom) {
                self.scrollToBottom();
            }
        });
    }

    private registerVideoThumbnailClick(): void {
        const self = this;
        $(ElementIdentifiers.ChatSection.list).on("click", ElementIdentifiers.ChatSection.youtubePlayer, function() {
            self.displayYoutubeVideo($(this));
        });
    }

    /**
     * Binds the context menu appearing to right clicking a message entry
     */
    private registerMessageContextMenu(): void {
        const self = this;

        $(`${ElementIdentifiers.ChatSection.list}`).on("contextmenu", "li", function(e) {
            const selection = window.getSelection().toString();
            if (!$(this).hasClass("in-progress") && selection.length === 0) {
                e.preventDefault();
                $(ElementIdentifiers.ChatSection.contextMenu)
                    .offset({
                        left: e.pageX,
                        top: e.pageY
                    });

                self._contextMenuMessageId = parseInt($(this).attr("id"));
            }
        });
    }

    /**
     * Translates text when the context menu is clicked
     */
    private registerContextMenuItemClick(): void {
        $("body").on("click", ElementIdentifiers.ChatSection.contextMenu, (event) => {
            const element = $(`#${this._contextMenuMessageId}`).find(ElementIdentifiers.Message.content);
            const firstLine = element.contents().first().text();
            const otherLines = $.map(element.children(), function(elem) {
                return $(elem).text();
            }).join("\n");

            const messageId = this._contextMenuMessageId;
            this._translator.translate(firstLine + "\n" + otherLines, "en")
                .then((translatedMessage: string) => {
                    $(`#${messageId}`).find(ElementIdentifiers.Message.content).text(translatedMessage);
                })
                .catch((e: Error) => {
                    console.log(e);
                });
        });
    }

    private registerScroll(): void {
        $(ElementIdentifiers.ChatSection.scrollSection).on("scroll", (e) => {
            const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
            const currentScroll = chatElement[0].scrollTop;

            if (currentScroll <= 400) {
                const discussion = this._client.getCurrentDiscussion() as Discussion;
                const messages = discussion.getMessages();
                if (messages.length > 40 && this._displayedMessagesCount !== messages.length) {
                    this.displayOlderMessages();
                } else if (messages.length >= 40) {
                    this._client.requestDiscussionHistory(discussion);
                }
            }
        });
    }
}

export default MessageSection;
