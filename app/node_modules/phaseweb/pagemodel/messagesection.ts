import * as $ from 'jquery';
import Templates from 'phaseweb/templates';
import ElementIdentifiers from 'phaseweb/elementidentifiers';
import Client from 'phaseweb/client';
import Discussion from 'phaseclient/discussion';
import Message from 'phaseclient/message';
import System from 'phasecore/system';
import Hash from 'phaseweb/hash';
import TextDifference from 'phaseclient/textdifference';
import { EditQueueEntry } from 'phasecore/editqueue';
import Translator from 'phaseweb/translator';

class MessageSection {
    private _client: Client;
    private lastMessageInput: string;
    private _messageInputHadCommandPrefix: boolean;
    private _contextMenuMessageId: number;
    private _translator: Translator;

    constructor(client: Client) {
        this._client = client;
        this._translator = new Translator();
        this.lastMessageInput = "";
        this._messageInputHadCommandPrefix = false;
        this.hideMessageLoading();
        this.hideContextMenu();
    }

    public getLastMessageInput(): string {
        return this.lastMessageInput;
    }

    /**
     * Updates the title displayed in the GUI
     * 
     * @param name The title of the messages (such as discussion name)
     */
    public updateDisplayedTitle(name: string): void {
        $(ElementIdentifiers.ChatSection.title).text(name);
    }

    /**
     * Clears the messages diplayed in the message list
     */
    public clearMessages(): void {
        $(ElementIdentifiers.ChatSection.list).empty();
        this.hideContextMenu();
    }

    /**
     * Displays 40 messages in the chat list from the specified discussion
     * 
     * @param discussion The discussion to display messages for
     */
    public displayMessages(discussion: Discussion): void {
        let messages = discussion.getMessages();
        let minIndex = messages.length-41 < 0 ? 0 : messages.length-41;
        for (let i = minIndex; i < messages.length; i++) {
            this.appendMessage(i >= 0 ? <Message>messages[i-1] : null, <Message>messages[i]);
        }
        
        this.scrollToBottom();
    }

    /**
     * Adds a message to the message display at the end (bottom)
     * 
     * @param lastMessage The last message displayed
     * @param message The message to add to the message display
     */
    private appendMessage(lastMessage: Message | null, message: Message) {
        let discussion = this._client.getCurrentDiscussion();

        // If join/leave message and config setting is not to display these, do not handle the message
        if (!this._client.getConfiguration().useAndDisplayJoinLeaveMessages && message.getUserId() == -2 && message.getTag().length !== 0) {
            return;
        } else if (typeof discussion === 'undefined') {
            return;
        }

        let addedMessage: any | null = null;

        // If the config has it set that messages are to be combined then checks need to be done
        if (this._client.getConfiguration().combineMessages) {
            // If the first message or is a join/leave message (so it contains ip, origin, that must be kept in-tact etc)
            if (lastMessage == null || message.getUserId() == System.joinLeaveMessageUserId) {
                addedMessage = $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this._client, discussion, message));
            } else {                
                // Combine messages that were sent by the same user consecutively, under a minute in difference
                if (lastMessage.getUserId() === message.getUserId()
                    && Math.abs(lastMessage.getTimestamp()-message.getTimestamp()) <= 60
                    && lastMessage.getTag() === message.getTag()
                    && ((lastMessage.getUsername().asIs().length > 0 && lastMessage.getUsername().asIs() === message.getUsername().asIs())
                        || (lastMessage.getGuestname().asIs().length > 0 && lastMessage.getGuestname().asIs() === message.getGuestname().asIs()))) {
                    addedMessage = $(`${ElementIdentifiers.ChatSection.list} li:not('.in-progress'):last`).find('.chat-message-content').append(`<div class="chat-line">${message.getContentStyled()}</div>`);
                } else {
                    let existingLiveTyping = $(ElementIdentifiers.LiveMessage.identifier(message.getUserId()));
                    if (existingLiveTyping.length) {
                        addedMessage = existingLiveTyping.before(Templates.ChatMessage(this._client, discussion, message));
                    } else {
                        addedMessage = $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this._client, discussion, message));
                    }
                }
            }
        // Otherwise just append the message to the list
        } else {
            addedMessage = $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this._client, discussion, message));
        }

        if (addedMessage !== null) {
            this.scrollAfterImagesLoad(addedMessage);
        }
    }

    /**
     * Fixes the scroll position when an image loaded that caused it to change
     * 
     * @param element The element with images that are loading
     */
    private scrollAfterImagesLoad(element: any): void {
        let _this = this;
        element.find('.autoLinkedImage').each(function() {
            _this.onImageLoad($(this), (width: number, height: number) => {
                _this.scrollBy(height);
            });
        });
    }

    /**
     * Displays a message in the message list by appending it
     * 
     * @param lastMessage The last message displayed
     * @param message The message to add to the message display
     */
    public displayMessage(lastMessage: Message | null, message: Message): void {
        if (message.getUserId() === this._client.getId()) {
            if (message.getContent().asIs() === $(ElementIdentifiers.ChatInput.textInput).val()) {
                let discussion = this._client.getCurrentDiscussion();
                if (discussion) {
                    $(ElementIdentifiers.ChatInput.main).after(Templates.ChatMessage(this._client, discussion, message));
                }
                return;
            }
        }

        let scrollIsAtBottom = this.getScrollIsAtBottom();
        this.appendMessage(lastMessage, message);

        // Scroll the chat to the bottom if they were at the bottom before
        if (scrollIsAtBottom) {
            // Remove messages that go over max of 40 in display
            this.removeOldestMessages($(ElementIdentifiers.ChatSection.list).children().length-40);
            this.scrollToBottom();
        }
    }

    /**
     * Remove the oldest n messages from the discussion message list
     */
    public removeOldestMessages(amount: number): void {
        if (amount < 0) {
            amount = 0;
        }
        $(ElementIdentifiers.ChatSection.list).children().slice(0, amount).remove();
    }

    /**
     * Returns the width and height of an image after it loads
     * 
     * @param image The image to track for loading
     * @param callback The function to call when the image has loaded
     */
    private onImageLoad(image: any, callback: (width: number, height: number) => void): void {
        let isDone = false;
        let onLoad = () => {
            done(image.width(), image.height());
        };
        image.on('load', onLoad);

        function done(width: number, height: number) {
            if (isDone) {
                return;
            }
            
            isDone = true;
            image.off('load', onLoad);
            
            callback(width, height);
        }
    }

    /**
     * Get whether scroll is at bottom
     */
    public getScrollIsAtBottom(): boolean {
        let chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        let maximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
        let currentScroll = chatElement[0].scrollTop;
        let scrollIsAtBottom = currentScroll == maximumScroll;

        return scrollIsAtBottom;
    }

    /**
     * Scroll the message list by the specified amount
     */
    public scrollBy(amount: number): void {
        let chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        chatElement[0].scrollTop += amount;
    }

    /**
     * Scroll the message list to the bottom
     */
    public scrollToBottom(): void {
        let chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        let maximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
        chatElement[0].scrollTop = maximumScroll;
    }

    /**
     * Displays live typing messages for the specified discussion
     * 
     * @param discussion The discussion to display live typing messages for
     */
    public displayLiveTyping(discussion: Discussion): void {
        let liveTypingMessages = discussion.getLiveTypingMessages();

        let message: Message;
        for (let key in liveTypingMessages) {
            message = <Message>liveTypingMessages[key];
            $(ElementIdentifiers.ChatSection.list).append(Templates.LiveTypingMessage(this._client, discussion, message));
        }

        this.scrollToBottom();
    }

    /**
     * Changes last message and current input field message to the last stored
     * 
     * @param discussion The discussion to get our live typing message from
     */
    public updateOurLiveTyping(discussion: Discussion): void {
        let message = discussion.getOurLiveTypingMessage();
        this.lastMessageInput = message || "";

        $(ElementIdentifiers.ChatInput.textInput).val(message || "");
    }
    
    /**
     * Creates a live typing element at the bottom of the message list
     * 
     * @param message The message to put in the live typing preview list
     */
    public createLiveTyping(message: Message): void {
        let discussion = this._client.getCurrentDiscussion();

        if (typeof discussion !== 'undefined') {
            let scrollWasAtBottom = this.getScrollIsAtBottom();
            $(ElementIdentifiers.ChatSection.list).append(Templates.LiveTypingMessage(this._client, discussion, message));
            
            // Scroll the chat to the bottom if they were at the bottom before
            if (scrollWasAtBottom) {
                this.scrollToBottom();
            }
        }
    }
    
    /**
     * Updates the content of an existing live typing element
     */
    public updateLiveTyping(message: Message): void {
        let scrollWasAtBottom = this.getScrollIsAtBottom();
        $(ElementIdentifiers.LiveMessage.identifier(message.getUserId())).find(ElementIdentifiers.LiveMessage.content).html(message.getContentStyled());

        // Scroll the chat to the bottom if they were at the bottom before
        if (scrollWasAtBottom) {
            this.scrollToBottom();
        }
    }
    
    /**
     * Removes an existing live typing element based on userId
     * 
     * @param userId The user id of the user to remove live typing preview for
     */
    public removeLiveTyping(userId: number): void {
        $(ElementIdentifiers.LiveMessage.identifier(userId)).remove();
    }

    /**
     * Removes all currently displayed live typing elements
     */
    public clearLiveTyping(): void {
        $(ElementIdentifiers.ChatSection.liveTyping).children().remove();
    }

    /**
     * Updates the displayed status of chat from an in-game user
     */
    public updateTerrariaUserStatus(name: string, online: boolean, tagColor?: string): void {
        if (online && tagColor) {
            $(`.chat-terraria-${Hash(name)}`).removeClass(ElementIdentifiers.Message.terrariaOffline.substr(1)).addClass(ElementIdentifiers.Message.terrariaOnline.substr(1)).css('background', tagColor);
        } else {
            $(`.chat-terraria-${Hash(name)}`).removeClass(ElementIdentifiers.Message.terrariaOnline.substr(1)).addClass(ElementIdentifiers.Message.terrariaOffline.substr(1)).css('background', '');
        }
    }

    /**
     * Updates the chat input username color to match their rank
     */
    public updateOurChatColor(): void {
        let currentDiscussion = this._client.getCurrentDiscussion();

        if (currentDiscussion) {
            let isCreator = this._client.getId() === currentDiscussion.getCreator();
            let isMod = currentDiscussion.getModerators()[this._client.getId()];
            let creatorClass = ElementIdentifiers.Message.creator.substr(1);
            let modClass = ElementIdentifiers.Message.moderator.substr(1);


            let nameElement = $(ElementIdentifiers.ChatInput.main).find(ElementIdentifiers.ChatInput.username);
            if (isCreator) {
                nameElement.addClass(creatorClass).removeClass(modClass);
            } else if (isMod) {
                nameElement.removeClass(creatorClass).addClass(modClass);
            } else {
                nameElement.removeClass(creatorClass).removeClass(modClass);
            }
        }
    }

    /**
     * Updates the displayed username in the chat input section
     * 
     * @param name The name to display ours as
     */
    public updateOurDisplayedName(name: string): void {
        $(ElementIdentifiers.ChatInput.main).find(ElementIdentifiers.ChatInput.username).text(name);
    }

    /**
     * Changes the thumbnail image of a video into the youtube video player
     */
    private displayYoutubeVideo(elem: any): void {
      let videoID = elem.attr('data-id');
      elem.empty();
      elem.append('<iframe class="youtube-iframe" src="https://www.youtube.com/embed/' + videoID + '?modestbranding=1&rel=0&autoplay=1&wmode=transparent&theme=light&color=white" frameborder="0" allowfullscreen></iframe>');
    }    

    /**
     * Shows the loading icon in the messages section
     */
    public showMessageLoading(): void {
        $(ElementIdentifiers.ChatSection.loading).show();
        $(ElementIdentifiers.ChatSection.scrollSection).fadeTo(300, 0.3);
    }

    /**
     * Hides the loading icon in the messages section
     */
    public hideMessageLoading(): void {
        $(ElementIdentifiers.ChatSection.loading).hide();
        $(ElementIdentifiers.ChatSection.scrollSection).fadeTo(300, 1);;
    }

    /**
     * Fades the messages section from 0.3 to 1
     */
    public fadeInMessages(): void {
        $(ElementIdentifiers.ChatSection.scrollSection)
            .stop(true)
            .fadeTo(100, 1);
    }

    /**
     * Fades the messages section from 1 to 0.6
     */
    public fadeOutMessages(): void {
        $(ElementIdentifiers.ChatSection.scrollSection)
            .stop(true)
            .fadeTo(0, 0.6);
    }

    /**
     * Moves the chat input back to the bottom of the chat area
     */
    private moveChatInputToBottom(): void {
        $(ElementIdentifiers.ChatInput.main).detach().appendTo($(ElementIdentifiers.ChatSection.main));
        $(ElementIdentifiers.ChatInput.textInput).focus();
        $(ElementIdentifiers.ChatInput.main).css('padding-left', '5px');
    }

    /**
     * Moves the chat input into the message list with the other messages
     */
    private moveChatInputToMessageList(): void {
        $(ElementIdentifiers.ChatInput.main).detach().appendTo($(ElementIdentifiers.ChatSection.list));
        $(ElementIdentifiers.ChatInput.textInput).focus();
        $(ElementIdentifiers.ChatInput.main).css('padding-left', '15px');
    }

    private hideContextMenu(): void {
        $(ElementIdentifiers.ChatSection.contextMenu).offset({
            left: -500,
            top: -500
        });
    }

    /**********
     * EVENTS *
     **********/

    public registerEvents(): void {
        this.registerPageClick(); 
        this.registerMessageSend();
        this.registerTextInput();
        this.registerVideoThumbnailClick();
        this.registerMessageContextMenu();
        this.registerContextMenuItemClick();
    }

    /**
     * Clears the context menu when the page is clicked
     */
    private registerPageClick(): void {
        $('body').on('click', () => {
            this.hideContextMenu();
        });
    }

    /**
     * Tells the client to take the necessary steps to send the message
     */
    private handleMessageSend(context: any): void {
        let chatText = $(context).val();
        this._client.sendChatMessage(chatText);
        $(context).val('');
        this.lastMessageInput = "";
    }

    /**
     * Registers the submit event of the chat message form for sending a message
     */
    private registerMessageSend(): void {
        let self = this;
        $(ElementIdentifiers.ChatInput.textInput).on('keydown', function(event) {
            if (event.keyCode == 13 && !event.shiftKey) {
                if ($(this).val().length > 0) {
                    let scrollIsAtBottom = self.getScrollIsAtBottom();
                    self.handleMessageSend(this);
                    $(this).text('');
                    this.style.height = '0px';
                    this.style.height = (this.scrollHeight) + 'px';
                    self.moveChatInputToBottom();
                    event.preventDefault();

                    if (scrollIsAtBottom) {
                        self.scrollToBottom();
                    }
                }
            }
        });
    }

    private registerTextInput(): void {
        let self = this;
        $(ElementIdentifiers.ChatInput.textInput).on('input', function(event) {
            let scrollIsAtBottom = self.getScrollIsAtBottom();
            let currentMessage = $(this).val();

            if (currentMessage.length === 0) {
                self.moveChatInputToBottom();
            } else if (self.lastMessageInput.length === 0) {
                self.moveChatInputToMessageList();
            }

            let queue: EditQueueEntry[] | null = null;
            if (currentMessage.indexOf('/') === 0) {
                if (!self._messageInputHadCommandPrefix) {
                    queue = TextDifference.getEditQueue(self.lastMessageInput, '');
                }
            } else {
                if (self._messageInputHadCommandPrefix) {
                    self._messageInputHadCommandPrefix = false;
                    self.lastMessageInput = "";
                }
                
                queue = TextDifference.getEditQueue(self.lastMessageInput, currentMessage);
            }

            self.lastMessageInput = currentMessage;

            if (queue != null) {
                self._client.sendEditQueue(queue);
            }
            this.style.height = '0px';
            this.style.height = (this.scrollHeight) + 'px';

            if (scrollIsAtBottom) {
                self.scrollToBottom();  
            }
        });
    }

    private registerVideoThumbnailClick(): void {
        let self = this;
        $(ElementIdentifiers.ChatSection.list).on('click', ElementIdentifiers.ChatSection.youtubePlayer, function() {
            self.displayYoutubeVideo($(this));
        });
    }

    /**
     * Binds the context menu appearing to right clicking a message entry
     */
    private registerMessageContextMenu(): void {
        let self = this;

        $(`${ElementIdentifiers.ChatSection.list}`).on('contextmenu', 'li', function(e) {
            let selection = window.getSelection().toString();
            if (!$(this).hasClass('in-progress') && selection.length === 0) {
                e.preventDefault();
                $(ElementIdentifiers.ChatSection.contextMenu)
                    .offset({
                        left: e.pageX,
                        top: e.pageY
                    });
                
                self._contextMenuMessageId = parseInt($(this).attr('id'));
            }
        });
    }

    /**
     * Translates text when the context menu is clicked
     */
    private registerContextMenuItemClick(): void {
        $('body').on('click', ElementIdentifiers.ChatSection.contextMenu, (e) => {
            let element = $(`#${this._contextMenuMessageId}`).find(ElementIdentifiers.Message.content);
            let firstLine = element.contents().first().text();
            let otherLines = $.map(element.children(), function(elem) {
                return $(elem).text();
            }).join('\n');

            let messageId = this._contextMenuMessageId;
            this._translator.translate(firstLine+'\n'+otherLines, 'en')
                .then((translatedMessage: string) => {
                    $(`#${messageId}`).find(ElementIdentifiers.Message.content).text(translatedMessage);
                })
                .catch((e) => {
                    console.log(e);
                });
        });
    }
}

export default MessageSection;