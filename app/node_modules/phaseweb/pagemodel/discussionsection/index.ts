import $ from "jquery";
import Discussion from "phaseclient/discussion";
import SafeString from "phaseclient/safestring";
import Client from "phaseweb/client";
import ElementIdentifiers from "phaseweb/elementidentifiers";
import DiscussionSectionEvents from "phaseweb/pagemodel/discussionsection/events";
import { ScrollElement } from "phaseweb/scroller";
import Scroller from "phaseweb/scroller";
import Templates from "phaseweb/templates";
import DiscussionPreview from "phaseweb/templates/discussionpreview";

class DiscussionSection {
    public mouseHovered: boolean = false;
    private _discusionListScroller: Scroller;
    private _client: Client;
    private _liveTypingBarTimeouts: { [discussionId: string]: any };
    private _events: DiscussionSectionEvents;
    private _orderTimeout: number;
    private _listAddTimeout: number;
    private _queuedToAdd: Discussion[] = [];
    private _mouseHoverTimeout: number | null = null;

    constructor(client: Client) {
        this._client = client;
        this._liveTypingBarTimeouts = {};
    }

    /**
     * Registers the events for the discussion section
     */
    public registerEvents(): void {
        this._events = new DiscussionSectionEvents(this, this._client);
    }

    /**
     * Updates the filter being used in the discussion list
     */
    public updateFilter(filter: string): void {
        if (filter.length === 0) {
            this._discusionListScroller.removeFilter();
            return;
        }

        if (filter.startsWith(" ")) {
            this._discusionListScroller.setFilter(e => {
                const name = (e.instance as Discussion).name.replace(/\<span .*?\>(.*?)\<\/span\>/g, "$1");
                if (filter.substr(1).startsWith("/")) {
                    const regex = new RegExp(filter.substr(2));
                    return name.toLowerCase().match(regex) !== null;
                }

                return name.toLowerCase().startsWith(filter.substr(1));
            });
        } else {
            this._discusionListScroller.setFilter(e => (e.instance as Discussion).name.toLowerCase().indexOf(filter.toLowerCase()) > -1);
        }
    }

    /**
     * Reorders the view by timestamp
     */
    public orderByTimestamp(): void {
        if (this._orderTimeout) {
            clearTimeout(this._orderTimeout);
        }

        this._orderTimeout = setTimeout(() => {
            this._discusionListScroller.elements.sort((a, b) => {
                return (b.instance as Discussion).recentMessage.timestamp - (a.instance as Discussion).recentMessage.timestamp;
            });
            this._discusionListScroller.redraw();
        }, 200);
    }

    /**
     * Adds a discussion to the top of the discussions list
     *
     * @param discussion The discussion to add to the discussion list
     */
    public prependDiscussionsList(discussion: Discussion): void {
        this._discusionListScroller.prependElement({
            element: new Templates.DiscussionListEntry(this._client, discussion),
            instance: discussion
        });
    }

    /**
     * Adds a discussion to the bottom of the discussions list
     *
     * @param discussion The discussion to add to the discussion list
     */
    public appendDiscussionList(discussion: Discussion): void {
        this._discusionListScroller.appendElement({
            element: new Templates.DiscussionListEntry(this._client, discussion),
            instance: discussion,
        }, true);
    }

    /**
     * Puts in a starting list of discussions in the display
     *
     * @param discussions The list of discussions to put in the display
     */
    public setDiscussionsList(discussions: Discussion[]): void {
        const elements: ScrollElement[] = [];
        for (const discussion of discussions) {
            elements.unshift({
                element: new Templates.DiscussionListEntry(this._client, discussion),
                instance: discussion
            });
        }

        this._discusionListScroller.elements = elements;
    }

    /**
     * Moves a discussion to the top of the displayed list. Specifically because it just received a message.
     * Used in any other way, this will cause unintended re-ordering of the list.
     *
     * @param discussion The discussion to move to the top of the list
     */
    public moveDiscussionToTopOfList(discussion: Discussion): void {

        if (!this.mouseHovered) {
            if (this._mouseHoverTimeout !== null) {
                clearTimeout(this._mouseHoverTimeout);
                this._mouseHoverTimeout = null;
                this.orderByTimestamp();
                return;
            }

            this._discusionListScroller.moveElementToFront(discussion, `#disc${discussion.id}`);
            this._discusionListScroller.onScroll();
        } else {
            if (this._mouseHoverTimeout !== null) {
                clearTimeout(this._mouseHoverTimeout);
                this._mouseHoverTimeout = null;
            }
            this._mouseHoverTimeout = setTimeout(() => {
                this.orderByTimestamp();
            }, 1000);
        }
    }

    /**
     * Updates the selected class to the newly switched discussion
     *
     * @param elem The element that was clicked to switch discussion
     */
    public switchSelectedDiscussion(discussionId: string): void {
        $(ElementIdentifiers.DiscussionSection.selected).removeClass(ElementIdentifiers.DiscussionSection.selected.substr(1));
        $(ElementIdentifiers.DiscussionSection.identifier(discussionId)).addClass(ElementIdentifiers.DiscussionSection.selected.substr(1));
    }

    /**
     * Remove unread style to discussion div
     */
    public setDiscussionRead(discussion: Discussion): void {
        $(ElementIdentifiers.DiscussionSection.identifier(discussion.id))
            .removeClass("unread");
    }

    /**
     * Apply unread style to discussion div
     *
     * @param discussion The discussion to set as unread
     */
    public setDiscussionUnread(discussion: Discussion): void {
        $(ElementIdentifiers.DiscussionSection.identifier(discussion.id))
            .addClass("unread");
    }

    /**
     * Update the preview of the discussion div in the discussion list
     *
     * @param discussion The discussion to update preview for
     */
    public updateDiscussionEntryMessagePreview(discussion: Discussion): void {
        const messageContent = discussion.recentMessage.content as SafeString;
        $(ElementIdentifiers.DiscussionSection.identifier(discussion.id))
            .children(ElementIdentifiers.DiscussionSection.preview)
            .html(DiscussionPreview(this._client, discussion, discussion.recentMessage));
    }

    /**
     * Ensures the live typing display bar is active for a discussion in the list
     *
     * @param discussion The discussion to update the bar for
     */
    public updateDiscussionLiveTypingBar(discussion: Discussion): void {
        const discussionElement = $(ElementIdentifiers.DiscussionSection.identifier(discussion.id));
        const unreadInprogressClass = ElementIdentifiers.DiscussionSection.unreadInprogress.substr(1);
        if (!discussionElement.hasClass(unreadInprogressClass)) {
            discussionElement.addClass(unreadInprogressClass);
        }

        if (this._liveTypingBarTimeouts[discussion.id]) {
            clearTimeout(this._liveTypingBarTimeouts[discussion.id]);
        }

        this.setLiveTypingBarTimeout(discussion);
    }

    /**
     * Ensures the live typing display bar is inactive for a discussion in the list
     *
     * @param discussion The discussion to remove the bar for
     */
    public removeDiscussionLiveTypingBar(discussion: Discussion): void {
        $(ElementIdentifiers.DiscussionSection.identifier(discussion.id))
            .removeClass(ElementIdentifiers.DiscussionSection.unreadInprogress.substr(1));

        // Clear existing timeout
        if (this._liveTypingBarTimeouts[discussion.id]) {
            clearTimeout(this._liveTypingBarTimeouts[discussion.id]);
        }
    }

    /**
     * Sets a timeout for the display of the live typing bar
     *
     * @param discussion The discussion to set the timeout for
     */
    private setLiveTypingBarTimeout(discussion: Discussion): void {
        this._liveTypingBarTimeouts[discussion.id] = setTimeout(() => {
            this.removeDiscussionLiveTypingBar(discussion);
        }, 1000);
    }

    /**
     * Updates the displayed discussion name
     *
     * @param discussion The discussion to update the name for
     */
    public updateDiscussionName(discussion: Discussion): void {
        $(ElementIdentifiers.DiscussionSection.identifier(discussion.id)).children(".discussion-name").text(discussion.name);
    }

    /**
     * Updates the scroller by forcing a redraw
     */
    public updateScroller(): void {
        this._discusionListScroller.onScroll();
    }

    /**
     * Sets up the discussion list scroller with default values and adds the scroll event handler
     */
    public setupScroller(): void {
        this._discusionListScroller = new Scroller($(ElementIdentifiers.DiscussionSection.list),
            $(ElementIdentifiers.DiscussionSection.list),
            [],
            70);
        $(ElementIdentifiers.DiscussionSection.list).on("scroll", () => {
            this._discusionListScroller.onScroll();
        });
    }
}

export default DiscussionSection;
