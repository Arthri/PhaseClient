import * as $ from "jquery";
import DeepHistory from "phaseclient/deephistory";
import Discussion from "phaseclient/discussion";
import Message from "phaseclient/message";
import SafeString from "phaseclient/safestring";
import Search from "phaseclient/search";
import System from "phasecore/system";
import Client from "phaseweb/client";
import ElementIdentifiers from "phaseweb/elementidentifiers";
import Hash from "phaseweb/hash";
import MessageSectionEvents from "phaseweb/pagemodel/messagesection/events";
import Templates from "phaseweb/templates";

// Padding used to get around anomolies with scroll not being exactly at the bottom
const SCROLL_DETECTION_PADDING = 10;

class MessageSection {
    public lastMessageInput: string = "";
    public messageInputHadCommandPrefix: boolean = false;
    public contextMenuMessageId: number;
    public displayedMessagesCount: number = 0;
    private _client: Client;
    private _events: MessageSectionEvents;

    constructor(client: Client) {
        this._client = client;
        this.hideMessageLoading();
        this.hideContextMenu();
    }

    /**
     * Registers the events for the message section
     */
    public registerEvents(): void {
        this._events = new MessageSectionEvents(this, this._client);
    }

    public getLastMessageInput(): string {
        return this.lastMessageInput;
    }

    /**
     * Updates the title displayed in the GUI
     *
     * @param name The title of the messages (such as discussion name)
     */
    public updateDisplayedTitle(name: string): void {
        $(ElementIdentifiers.ChatSection.title).text(name);
    }

    /**
     * Updates the alert bell icon to reflect the current status of alerts for the current discussion
     *
     * @param on Whether the alerts are enabled or not
     */
    public updateAlertBellStatus(on: boolean): void {
        if (on) {
            $(ElementIdentifiers.ChatSection.alertBell)
                .addClass(ElementIdentifiers.ChatSection.alertBellActive.substr(1))
                .removeClass(ElementIdentifiers.ChatSection.alertBellInactive.substr(1));
        } else {
            $(ElementIdentifiers.ChatSection.alertBell)
                .addClass(ElementIdentifiers.ChatSection.alertBellInactive.substr(1))
                .removeClass(ElementIdentifiers.ChatSection.alertBellActive.substr(1));
        }
    }

    /**
     * Clears the messages diplayed in the message list
     */
    public clearMessages(): void {
        $(ElementIdentifiers.ChatSection.list).empty();
        this.hideContextMenu();
        this.displayedMessagesCount = 0;
    }

    /**
     * Displays 40 messages in the chat list from the specified discussion
     *
     * @param discussion The discussion to display messages for
     */
    public displayMessages(discussion: Discussion): void {
        const messages = discussion.messages;
        const minIndex = messages.length - 41 < 0 ? 0 : messages.length - 41;
        for (let i = minIndex; i < messages.length; i++) {
            this.appendMessage(i >= 0 ? messages[i - 1] as Message : undefined, messages[i] as Message);
        }

        this.scrollToBottom();
    }

    /**
     * Gets whether a message should be combined with the last message
     *
     * @param message The message
     * @param lastMessage The last message
     */
    private messageShouldBeCombined(message: Message, lastMessage: Message): boolean {
        return lastMessage.userId === message.userId
                    && Math.abs(lastMessage.timestamp - message.timestamp) <= 60
                    && lastMessage.tag === message.tag
                    && ((lastMessage.username.asIs().length > 0 && lastMessage.username.asIs() === message.username.asIs())
                        || (lastMessage.guestName.asIs().length > 0 && lastMessage.guestName.asIs() === message.guestName.asIs()));
    }

    private getActiveDiscussion(): Discussion | undefined {
        const search = this._client.discussionSearch;
        const searchDiscussion = search !== null ? search.discussion : undefined;
        const deepHistory = this._client.deepHistory;
        const deephistoryDiscussion = deepHistory !== null ? deepHistory.discussion : undefined;
        const discussion = this._client.currentDiscussion || searchDiscussion || deephistoryDiscussion;

        return discussion;
    }

    /**
     * Adds a message to the message display at the end (bottom)
     *
     * @param lastMessage The last message displayed
     * @param message The message to add to the message display
     */
    private appendMessage(lastMessage: Message | undefined, message: Message) {
        const discussion = this.getActiveDiscussion();

        // If join/leave message and config setting is not to display these, do not handle the message
        if (!this._client.configuration.useAndDisplayJoinLeaveMessages && message.userId === -2 && message.tag.length !== 0) {
            return;
        } else if (typeof discussion === "undefined") {
            return;
        }

        let addedMessage: JQuery | null = null;

        // If the config has it set that messages are to be combined then checks need to be done
        if (this._client.configuration.combineMessages) {
            // If the first message or is a join/leave message (so it contains ip, origin, that must be kept in-tact etc)
            if (!lastMessage || message.userId === System.joinLeaveMessageUserId) {
                addedMessage = $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this._client, discussion, message));
            } else {
                // Combine messages that were sent by the same user consecutively, under a minute in difference
                if (this.messageShouldBeCombined(message, lastMessage)) {
                    addedMessage = this.combineMessage(message);
                } else {
                    const existingLiveTyping = $(ElementIdentifiers.LiveMessage.identifier(message.userId));
                    if (existingLiveTyping.length && this._client.configuration.mergeLiveTypingWithCompleteChatArea) {
                        addedMessage = existingLiveTyping.before(Templates.ChatMessage(this._client, discussion, message));
                    } else {
                        addedMessage = $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this._client, discussion, message));
                    }
                }
            }
        // Otherwise just append the message to the list
        } else {
            addedMessage = $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this._client, discussion, message));
        }

        if (addedMessage !== null) {
            this.scrollAfterImagesLoad(addedMessage);
        }
        this.displayedMessagesCount++;
    }

    /**
     * Combines a message with the last message in the list
     *
     * @param message The message to get new content from
     */
    private combineMessage(message: Message): JQuery {
        return $(`${ElementIdentifiers.ChatSection.list} li:not('.in-progress'):last`)
            .find(".chat-message-content")
            .append(`<div class="chat-line">${message.getContentStyled()}</div>`);
    }

    /**
     * Fixes the scroll position when an image loaded that caused it to change
     *
     * @param element The element with images that are loading
     */
    private scrollAfterImagesLoad(element: any): void {
        const _this = this;
        element.find(".autoLinkedImage").each(function() {
            _this.onImageLoad($(this), (width: number, height: number) => {
                _this.scrollBy(height);
            });
        });
    }

    /**
     * Adds a message to the message display at the beginning (top)
     *
     * @param message The message to add to the message display
     */
    private prependMessage(message: Message): void {
        const discussion = this.getActiveDiscussion();

        // If join/leave message and config setting is not to display these, do not handle the message
        if (!this._client.configuration.useAndDisplayJoinLeaveMessages && message.userId === -2 && message.tag.length !== 0) {
            return;
        } else if (typeof discussion === "undefined") {
            return;
        }

        let addedMessage: JQuery | null = null;

        // If the config has it set that messages are to be combined then checks need to be done
        // TODO: Fix this
        /*if (this._client.getConfiguration().combineMessages) {
            // If the first message or is a join/leave message (so it contains ip, origin, that must be kept in-tact etc)
            if (!lastMessage || message.getUserId() === System.joinLeaveMessageUserId) {
                addedMessage = $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this._client, discussion, message));
            } else {
                // Combine messages that were sent by the same user consecutively, under a minute in difference
                if (this.messageShouldBeCombined(message, lastMessage)) {
                    addedMessage = this.combineMessage(message);
                } else {
                    const existingLiveTyping = $(ElementIdentifiers.LiveMessage.identifier(message.getUserId()));
                    if (existingLiveTyping.length && this._client.getConfiguration().mergeLiveTypingWithCompleteChatArea) {
                        addedMessage = existingLiveTyping.before(Templates.ChatMessage(this._client, discussion, message));
                    } else {
                        addedMessage = $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this._client, discussion, message));
                    }
                }
            }
        // Otherwise just append the message to the list
        } else {*/
        addedMessage = $(ElementIdentifiers.ChatSection.list).prepend(Templates.ChatMessage(this._client, discussion, message));
        this.displayedMessagesCount++;
        // }
    }

    /**
     * Displays a message in the message list by appending it
     *
     * @param lastMessage The last message displayed
     * @param message The message to add to the message display
     */
    public displayMessage(lastMessage: Message | undefined, message: Message): void {
        if (message.userId === this._client.id && this._client.configuration.mergeLiveTypingWithCompleteChatArea) {
            if (message.content.asIs() === $(ElementIdentifiers.ChatInput.textInput).val()) {
                const discussion = this._client.currentDiscussion;
                if (discussion) {
                    if (this._client.configuration.mergeLiveTypingWithCompleteChatArea) {
                        $(ElementIdentifiers.ChatInput.main).after(Templates.ChatMessage(this._client, discussion, message));
                    }
                }
                return;
            }
        }

        const scrollIsAtBottom = this.getScrollIsAtBottom();
        this.appendMessage(lastMessage, message);

        // Scroll the chat to the bottom if they were at the bottom before
        if (scrollIsAtBottom) {
            // Remove messages that go over max of 40 in display
            if (this.displayedMessagesCount > 40) {
                this.removeOldestMessages(this.displayedMessagesCount - 40);
            }
            this.scrollToBottom();
        }
    }

    /**
     * Remove the oldest n messages from the discussion message list
     */
    public removeOldestMessages(amount: number): void {
        if (amount < 0) {
            amount = 0;
        }

        $(ElementIdentifiers.ChatSection.list).children().each((index, elem) => {
            if (index <= amount - 1) {
                $(elem).remove();
                this.displayedMessagesCount -= $(elem).find(".chat-message-right").find(".chat-message-content").children().length + 1;
            }
        });
        // .slice(0, amount).remove();
    }

    /**
     * Returns the width and height of an image after it loads
     *
     * @param image The image to track for loading
     * @param callback The function to call when the image has loaded
     */
    private onImageLoad(image: any, callback: (width: number, height: number) => void): void {
        let isDone = false;
        const onLoad = () => {
            done(image.width(), image.height());
        };
        image.on("load", onLoad);

        function done(width: number, height: number) {
            if (isDone) {
                return;
            }

            isDone = true;
            image.off("load", onLoad);

            callback(width, height);
        }
    }

    /**
     * Get whether scroll is at bottom
     */
    public getScrollIsAtBottom(): boolean {
        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        const maximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
        const currentScroll = chatElement[0].scrollTop;
        const scrollIsAtBottom = currentScroll >= Math.ceil(maximumScroll) - SCROLL_DETECTION_PADDING;

        return scrollIsAtBottom;
    }

    /**
     * Scroll the message list by the specified amount
     */
    public scrollBy(amount: number): void {
        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        chatElement[0].scrollTop += amount;
    }

    /**
     * Scrolls to the given height from the top
     *
     * @param height The height to set scroll top to
     */
    public scrollTo(height: number): void {
        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        chatElement[0].scrollTop = height;
    }

    /**
     * Scroll the message list to the bottom
     */
    public scrollToBottom(): void {
        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        const maximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
        chatElement[0].scrollTop = maximumScroll;
    }

    /**
     * Displays live typing messages for the specified discussion
     *
     * @param discussion The discussion to display live typing messages for
     */
    public displayLiveTyping(discussion: Discussion): void {
        const liveTypingMessages = discussion.liveTypingMessages;

        let message: Message;
        for (const key in liveTypingMessages) {
            if (liveTypingMessages.hasOwnProperty(key)) {
                message = liveTypingMessages[key] as Message;
                if (this._client.configuration.mergeLiveTypingWithCompleteChatArea) {
                    $(ElementIdentifiers.ChatSection.list).append(Templates.LiveTypingMessage(this._client, discussion, message));
                } else {
                    $(ElementIdentifiers.ChatSection.liveTyping).append(Templates.LiveTypingMessage(this._client, discussion, message));
                }
            }
        }

        this.scrollToBottom();
    }

    /**
     * Changes last message and current input field message to the last stored
     *
     * @param discussion The discussion to get our live typing message from
     */
    public updateOurLiveTyping(discussion: Discussion): void {
        const message = discussion.ourLiveTypingMessage;
        this.lastMessageInput = message || "";

        $(ElementIdentifiers.ChatInput.textInput).val(message || "");
    }

    /**
     * Creates a live typing element at the bottom of the message list
     *
     * @param message The message to put in the live typing preview list
     */
    public createLiveTyping(message: Message): void {
        const discussion = this._client.currentDiscussion;

        if (typeof discussion !== "undefined") {
            this.removeLiveTyping(message.userId);
            const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
            const maximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
            const currentScroll = chatElement[0].scrollTop;

            const scrollWasAtBottom = this.getScrollIsAtBottom();
            if (this._client.configuration.mergeLiveTypingWithCompleteChatArea) {
                $(ElementIdentifiers.ChatSection.list).append(Templates.LiveTypingMessage(this._client, discussion, message));
            } else {
                $(ElementIdentifiers.ChatSection.liveTyping).append(Templates.LiveTypingMessage(this._client, discussion, message));
            }

            // Scroll the chat to the bottom if they were at the bottom before
            if (scrollWasAtBottom) {
                this.scrollToBottom();
            }
        }
    }

    /**
     * Updates the content of an existing live typing element
     */
    public updateLiveTyping(message: Message): void {
        const scrollWasAtBottom = this.getScrollIsAtBottom();
        $(ElementIdentifiers.LiveMessage.identifier(message.userId))
            .find(ElementIdentifiers.LiveMessage.content)
            .html(message.getContentStyled());

        // Scroll the chat to the bottom if they were at the bottom before
        if (scrollWasAtBottom) {
            this.scrollToBottom();
        }
    }

    /**
     * Removes an existing live typing element based on userId
     *
     * @param userId The user id of the user to remove live typing preview for
     */
    public removeLiveTyping(userId: number): void {
        $(ElementIdentifiers.LiveMessage.identifier(userId)).remove();
    }

    /**
     * Removes all currently displayed live typing elements
     */
    public clearLiveTyping(): void {
        $(ElementIdentifiers.ChatSection.liveTyping).children().remove();
    }

    /**
     * Updates the displayed status of chat from an in-game user
     */
    public updateTerrariaUserStatus(name: string, online: boolean, tagColor?: string): void {
        if (online && tagColor) {
            $(`.chat-terraria-${Hash(name)}`)
                .removeClass(ElementIdentifiers.Message.terrariaOffline.substr(1))
                .addClass(ElementIdentifiers.Message.terrariaOnline.substr(1))
                .css("background", tagColor);
        } else {
            $(`.chat-terraria-${Hash(name)}`)
                .removeClass(ElementIdentifiers.Message.terrariaOnline.substr(1))
                .addClass(ElementIdentifiers.Message.terrariaOffline.substr(1))
                .css("background", "");
        }
    }

    /**
     * Updates the chat input username color to match their rank
     */
    public updateOurChatColor(): void {
        const currentDiscussion = this._client.currentDiscussion;

        if (currentDiscussion) {
            const isCreator = this._client.id === currentDiscussion.creator;
            const isMod = currentDiscussion.moderators[this._client.id];
            const creatorClass = ElementIdentifiers.Message.creator.substr(1);
            const modClass = ElementIdentifiers.Message.moderator.substr(1);

            const nameElement = $(ElementIdentifiers.ChatInput.main).find(ElementIdentifiers.ChatInput.username);
            if (isCreator) {
                nameElement.addClass(creatorClass).removeClass(modClass);
            } else if (isMod) {
                nameElement.removeClass(creatorClass).addClass(modClass);
            } else {
                nameElement.removeClass(creatorClass).removeClass(modClass);
            }
        }
    }

    /**
     * Updates the displayed username in the chat input section
     *
     * @param name The name to display ours as
     */
    public updateOurDisplayedName(name: string): void {
        $(ElementIdentifiers.ChatInput.main).find(ElementIdentifiers.ChatInput.username).text(name);
    }

    /**
     * Changes the thumbnail image of a video into the youtube video player
     */
    public displayYoutubeVideo(elem: any): void {
      const videoID = elem.attr("data-id");
      elem.empty();
      elem.append(`<iframe class="youtube-iframe"
                           src="https://www.youtube.com/embed/${videoID}?modestbranding=1&rel=0&autoplay=1&wmode=transparent&theme=light&color=white"
                           frameborder="0" allowfullscreen></iframe>`);
    }

    /**
     * Shows the loading icon in the messages section
     */
    public showMessageLoading(): void {
        $(ElementIdentifiers.ChatSection.loading).show();
        $(ElementIdentifiers.ChatSection.scrollSection).fadeTo(300, 0.3);
    }

    /**
     * Hides the loading icon in the messages section
     */
    public hideMessageLoading(): void {
        $(ElementIdentifiers.ChatSection.loading).hide();
        $(ElementIdentifiers.ChatSection.scrollSection).fadeTo(300, 1);
    }

    /**
     * Fades the messages section from 0.3 to 1
     */
    public fadeInMessages(): void {
        $(ElementIdentifiers.ChatSection.scrollSection)
            .stop(true)
            .fadeTo(100, 1);
    }

    /**
     * Fades the messages section from 1 to 0.6
     */
    public fadeOutMessages(): void {
        $(ElementIdentifiers.ChatSection.scrollSection)
            .stop(true)
            .fadeTo(0, 0.6);
    }

    /**
     * Moves the chat input back to the bottom of the chat area
     */
    public moveChatInputToBottom(): void {
        $(ElementIdentifiers.ChatInput.main).detach().appendTo($(ElementIdentifiers.ChatSection.main));
        $(ElementIdentifiers.ChatInput.textInput).focus();
        $(ElementIdentifiers.ChatInput.main).css("padding-left", "5px");
    }

    /**
     * Moves the chat input into the message list with the other messages
     */
    public moveChatInputToMessageList(): void {
        $(ElementIdentifiers.ChatInput.main).detach().appendTo($(ElementIdentifiers.ChatSection.list));
        $(ElementIdentifiers.ChatInput.textInput).focus();
        $(ElementIdentifiers.ChatInput.main).css("padding-left", "15px");
    }

    public hideContextMenu(): void {
        $(ElementIdentifiers.ChatSection.contextMenu).offset({
            left: -500,
            top: -500
        });
    }

    public onHistoryReceived(discussion: Discussion): void {
        if (discussion === this._client.currentDiscussion) {
            this.displayOlderMessages();
        }
    }

    public displayOlderMessages(): void {
        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        const discussion = this._client.currentDiscussion as Discussion;
        const messages = discussion.messages;
        const oldMaximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;

        // If there are more messages available to display, then they will be prepended
        if (messages.length > 40 && this.displayedMessagesCount !== messages.length) {
            const startIndex = messages.length - this.displayedMessagesCount - 1;
            let minIndex = startIndex - 40;
            if (minIndex < 0) {
                minIndex = 0;
            }

            for (let i = startIndex; i >= minIndex; i--) {
                this.prependMessage(messages[i] as Message);
            }

            // If scroll top is 0 this means the elements caused the other messages to go further down the screen
            if (chatElement[0].scrollTop === 0) {
                const newMaximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
                this.scrollTo(newMaximumScroll - oldMaximumScroll);
            }
        }
    }

    /**
     * Removes a message that exists only locally identified by a local id
     *
     * @param localMessageId The local message id of the message
     */
    public removeLocalMessage(localMessageId: number): void {
        $(ElementIdentifiers.Message.local(localMessageId)).remove();
    }

    /**
     * Displays the messages from the search results
     *
     * @param messages The list of messages from the search results
     */
    public displaySearchResults(terms: string, messages: Message[]): void {
        const search = this._client.discussionSearch as Search;
        const discussion = search.discussion as Discussion;
        const discussionName = new SafeString(discussion.name).getContentWithHtmlEscaped();
        const searchTerm = new SafeString(terms).getContentWithHtmlEscaped();
        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        const oldMaximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
        const oldMessageDisplayedCount = this.displayedMessagesCount;

        $(ElementIdentifiers.ChatSection.title).html(`Search results for <i>${searchTerm}</i> in <b>${discussionName}</b>`);
        for (const message of messages) {
            this.prependMessage(message);
        }

        // If scroll top is 0 this means the elements caused the other messages to go further down the screen
        if (oldMessageDisplayedCount > 0) {
            if (chatElement[0].scrollTop === 0) {
                const newMaximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
                this.scrollTo(newMaximumScroll - oldMaximumScroll);
            }
        } else {
            this.scrollToBottom();
        }
    }

    /**
     * Displays the deep history results for a paritcular message
     */
    public displayDeepHistory(): void {
        const deepHistory = this._client.deepHistory as DeepHistory;
        const messageContentEscaped = deepHistory.rootMessage.content.getContentWithHtmlEscaped();
        const titleMessageContent = messageContentEscaped.length > 15
            ? `${messageContentEscaped.substr(0, 13)}...`
            : messageContentEscaped;
        const discussionName = (this._client.deepHistory as DeepHistory).discussion.name;
        $(ElementIdentifiers.ChatSection.title).html(`Deep History for <i>${titleMessageContent}</i> in <b>${discussionName}</b>`);

        let previousMessage: Message | undefined;
        for (const message of deepHistory.messages) {
            this.appendMessage(previousMessage, message);
            previousMessage = message;
        }

        $(ElementIdentifiers.ChatSection.list).find(`#${deepHistory.rootMessage.id}`).addClass("root-message");
        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        const maximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
        this.scrollTo(maximumScroll / 2);
    }

    /**
     * Displays the older deep history results for a paritcular message
     *
     * @param messages The messages
     */
    public displayDeepHistoryOlder(messages: Message[]): void {
        const deepHistory = this._client.deepHistory as DeepHistory;

        for (const message of deepHistory.messages) {
            this.prependMessage(message);
        }

        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        const oldMaximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
        if (chatElement[0].scrollTop === 0) {
            const newMaximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
            this.scrollTo(newMaximumScroll - oldMaximumScroll);
        }
    }

    /**
     * Displays the newer deep history results for a paritcular message
     *
     * @param messages The messages
     */
    public displayDeepHistoryNewer(messages: Message[]): void {
        const deepHistory = this._client.deepHistory as DeepHistory;

        let previousMessage: Message | undefined;
        for (const message of deepHistory.messages) {
            this.appendMessage(previousMessage, message);
            previousMessage = message;
        }
    }
}

export default MessageSection;
