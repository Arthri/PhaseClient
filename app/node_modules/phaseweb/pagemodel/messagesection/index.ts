import * as $ from "jquery";
import DeepHistory from "phaseclient/deephistory";
import Discussion from "phaseclient/discussion";
import Message from "phaseclient/message";
import SafeString from "phaseclient/safestring";
import Search from "phaseclient/search";
import System from "phasecore/system";
import Client from "phaseweb/client";
import ElementIdentifiers from "phaseweb/elementidentifiers";
import Hash from "phaseweb/hash";
import ContextMenu from "phaseweb/pagemodel/messagesection/contextmenu";
import MessageSectionEvents from "phaseweb/pagemodel/messagesection/events";
import Templates from "phaseweb/templates";

// Padding used to get around anomolies with scroll not being exactly at the bottom
const SCROLL_DETECTION_PADDING = 10;

class MessageSection {
    public lastMessageInput: string = "";
    public messageInputHadCommandPrefix: boolean = false;
    private _displayedMessages: Message[] = [];
    private _lastMessageCombined: Message | null = null;
    private _firstMessageCombined: Message | null = null;
    private _client: Client;
    private _events: MessageSectionEvents;
    private _contextMenu: ContextMenu;

    constructor(client: Client) {
        this._client = client;
        this.hideMessageLoading();
        this._contextMenu = new ContextMenu(this._client);
        this._contextMenu.hide();
    }

    public get displayedMessagesCount(): number {
        return this._displayedMessages.length;
    }

    /**
     * Registers the events for the message section
     */
    public registerEvents(): void {
        this._events = new MessageSectionEvents(this, this._client);
        this._contextMenu.registerEvents();
    }

    public getLastMessageInput(): string {
        return this.lastMessageInput;
    }

    /**
     * Updates the title displayed in the GUI
     *
     * @param name The title of the messages (such as discussion name)
     */
    public updateDisplayedTitle(name: string): void {
        $(ElementIdentifiers.ChatSection.title).text(name);
    }

    /**
     * Updates the alert bell icon to reflect the current status of alerts for the current discussion
     *
     * @param on Whether the alerts are enabled or not
     */
    public updateAlertBellStatus(on: boolean): void {
        if (on) {
            $(ElementIdentifiers.ChatSection.alertBell)
                .addClass(ElementIdentifiers.ChatSection.alertBellActive.substr(1))
                .removeClass(ElementIdentifiers.ChatSection.alertBellInactive.substr(1));
        } else {
            $(ElementIdentifiers.ChatSection.alertBell)
                .addClass(ElementIdentifiers.ChatSection.alertBellInactive.substr(1))
                .removeClass(ElementIdentifiers.ChatSection.alertBellActive.substr(1));
        }
    }

    /**
     * Clears the messages diplayed in the message list
     */
    public clearMessages(): void {
        $(ElementIdentifiers.ChatSection.list).empty();
        this._contextMenu.hide();
        this._displayedMessages = [];
        this._firstMessageCombined = null;
        this._lastMessageCombined = null;
    }

    /**
     * Displays 40 messages in the chat list from the specified discussion
     *
     * @param discussion The discussion to display messages for
     */
    public displayMessages(discussion: Discussion): void {
        const messages = discussion.messages;
        const minIndex = messages.length - 41 < 0 ? 0 : messages.length - 41;
        for (let i = minIndex; i < messages.length; i++) {
            this.appendMessage(messages[i] as Message);
        }

        this.scrollToBottom();
    }

    private messagesAreCombinable(message: Message, lastMessage: Message): boolean {
        return lastMessage.userId === message.userId
            && Math.abs(lastMessage.timestamp - message.timestamp) <= 60
            && lastMessage.tag === message.tag
            && ((lastMessage.username.asIs().length > 0 && lastMessage.username.asIs() === message.username.asIs())
                || (lastMessage.guestName.asIs().length > 0 && lastMessage.guestName.asIs() === message.guestName.asIs()));
    }

    private getActiveDiscussion(): Discussion | undefined {
        const search = this._client.discussionSearch;
        const searchDiscussion = search !== null ? search.discussion : undefined;
        const deepHistory = this._client.deepHistory;
        const deephistoryDiscussion = deepHistory !== null && deepHistory.discussion !== null ? deepHistory.discussion : undefined;
        const discussion = this._client.currentDiscussion || searchDiscussion || deephistoryDiscussion;

        return discussion;
    }

    /**
     * Adds a message to the message display at the end (bottom)
     *
     * @param lastMessage The last message displayed
     * @param message The message to add to the message display
     */
    private appendMessage(message: Message, scrollAfterImageLoad = true) {
        const discussion = this.getActiveDiscussion();
        const lastMessage = this._displayedMessages.length ? this._displayedMessages[this._displayedMessages.length - 1] : null;

        // If join/leave message and config setting is not to display these, do not handle the message
        if (!this._client.configuration.useAndDisplayJoinLeaveMessages && message.userId === -2 && message.tag.length !== 0) {
            return;
        } else if (typeof discussion === "undefined") {
            return;
        }

        let addedMessage: JQuery | null = null;

        // If the config has it set that messages are to be combined then checks need to be done
        if (this._client.configuration.combineMessages) {
            // If the first message or is a join/leave message (so it contains ip, origin, that must be kept in-tact etc)
            if (lastMessage === null || message.userId === System.joinLeaveMessageUserId) {
                addedMessage = $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this._client, discussion, message));
            } else {
                // Combine messages that were sent by the same user consecutively, under a minute in difference
                if (this._lastMessageCombined !== null && this.messagesAreCombinable(message, this._lastMessageCombined)) {
                    addedMessage = this.appendToLastMessage(message);
                } else if (this._lastMessageCombined === null && this.messagesAreCombinable(message, lastMessage)) {
                    this._lastMessageCombined = lastMessage;
                    addedMessage = this.appendToLastMessage(message);
                } else {
                    const existingLiveTyping = $(ElementIdentifiers.LiveMessage.identifier(message.userId));
                    if (existingLiveTyping.length && this._client.configuration.mergeLiveTypingWithCompleteChatArea) {
                        addedMessage = existingLiveTyping.before(Templates.ChatMessage(this._client, discussion, message));
                    } else {
                        addedMessage = $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this._client, discussion, message));
                    }

                    this._lastMessageCombined = null;
                }
            }
        // Otherwise just append the message to the list
        } else {
            addedMessage = $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this._client, discussion, message));
        }

        if (addedMessage !== null && scrollAfterImageLoad) {
            this.scrollAfterImagesLoad(addedMessage);
        }

        this._displayedMessages.push(message);
    }

    /**
     * Combines a message with the last message in the list
     *
     * @param message The message to get new content from
     */
    private appendToLastMessage(message: Message, last = true): JQuery {
        return $(`${ElementIdentifiers.ChatSection.list} li:not('.in-progress'):last`)
            .find(".chat-message-content")
            .append(`<div class="chat-line">${message.getContentStyled()}</div>`);
    }

    /**
     * Combines a message with the last message in the list
     *
     * @param message The message to get new content from
     */
    private prependToFirstMessage(message: Message, last = true): JQuery {
        return $(`${ElementIdentifiers.ChatSection.list} li:not('.in-progress'):first`)
            .find(".chat-message-content")
            .prepend(`<div class="chat-line">${message.getContentStyled()}</div>`);
    }

    /**
     * Fixes the scroll position when an image loaded that caused it to change
     *
     * @param element The element with images that are loading
     */
    private scrollAfterImagesLoad(element: any): void {
        const self = this;
        element.find(".autoLinkedImage").each(function() {
            $(this).removeClass("autoLinkedImage");
            self.onImageLoad($(this), (width: number, height: number) => {
                const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
                const offset = $(this).offset();
                if (offset && offset.top > 0) {
                    self.scrollBy(height);
                }
            });
        });
    }

    /**
     * Adds a message to the message display at the beginning (top)
     *
     * @param message The message to add to the message display
     */
    private prependMessage(message: Message): void {
        const discussion = this.getActiveDiscussion();
        const nextMessage = this._displayedMessages[0] || null;

        // If join/leave message and config setting is not to display these, do not handle the message
        if (!this._client.configuration.useAndDisplayJoinLeaveMessages && message.userId === -2 && message.tag.length !== 0) {
            return;
        } else if (typeof discussion === "undefined") {
            return;
        }

        let addedMessage: JQuery | null = null;

        // If the config has it set that messages are to be combined then checks need to be done
        if (this._client.configuration.combineMessages) {
            // If the first message or is a join/leave message (so it contains ip, origin, that must be kept in-tact etc)
            if (nextMessage === null || message.userId === System.joinLeaveMessageUserId) {
                addedMessage = $(ElementIdentifiers.ChatSection.list).prepend(Templates.ChatMessage(this._client, discussion, message));
            } else {
                // Combine messages that were sent by the same user consecutively, under a minute in difference
                if (this._firstMessageCombined !== null && this.messagesAreCombinable(message, this._firstMessageCombined)) {
                    addedMessage = this.prependToFirstMessage(message);
                } else if (this._firstMessageCombined === null && this.messagesAreCombinable(message, nextMessage)) {
                    this._firstMessageCombined = nextMessage;
                    addedMessage = this.prependToFirstMessage(message);
                } else {
                    const existingLiveTyping = $(ElementIdentifiers.LiveMessage.identifier(message.userId));
                    if (existingLiveTyping.length && this._client.configuration.mergeLiveTypingWithCompleteChatArea) {
                        addedMessage = existingLiveTyping.before(Templates.ChatMessage(this._client, discussion, message));
                    } else {
                        addedMessage = $(ElementIdentifiers.ChatSection.list).prepend(Templates.ChatMessage(this._client, discussion, message));
                    }
                }
            }
        // Otherwise just append the message to the list
        } else {
            addedMessage = $(ElementIdentifiers.ChatSection.list).prepend(Templates.ChatMessage(this._client, discussion, message));
        }

        this._displayedMessages.unshift(message);
    }

    /**
     * Displays a message in the message list by appending it
     *
     * @param lastMessage The last message displayed
     * @param message The message to add to the message display
     */
    public displayMessage(message: Message): void {
        if (message.userId === this._client.id && this._client.configuration.mergeLiveTypingWithCompleteChatArea) {
            if (message.content.asIs() === $(ElementIdentifiers.ChatInput.textInput).val()) {
                const discussion = this._client.currentDiscussion;
                if (discussion) {
                    if (this._client.configuration.mergeLiveTypingWithCompleteChatArea) {
                        $(ElementIdentifiers.ChatInput.main).after(Templates.ChatMessage(this._client, discussion, message));
                    }
                }
                return;
            }
        }

        const scrollIsAtBottom = this.getScrollIsAtBottom();
        this.appendMessage(message);

        // Scroll the chat to the bottom if they were at the bottom before
        if (scrollIsAtBottom) {
            // Remove messages that go over max of 40 in display
            if (this._displayedMessages.length > 40) {
                this.removeOldestMessages(this._displayedMessages.length - 40);
            }
            this.scrollToBottom();
        }
    }

    /**
     * Remove the oldest n messages from the discussion message list
     */
    public removeOldestMessages(amount: number): void {
        if (amount < 0) {
            amount = 0;
        }

        $(ElementIdentifiers.ChatSection.list).children().each((index, elem) => {
            if (index <= amount - 1) {
                const removedAmount = $(elem).find(".chat-message-right").find(".chat-message-content").children().length;
                this._displayedMessages.splice(0, removedAmount);
                $(elem).remove();
            }
        });
        // .slice(0, amount).remove();
    }

    /**
     * Returns the width and height of an image after it loads
     *
     * @param image The image to track for loading
     * @param callback The function to call when the image has loaded
     */
    private onImageLoad(image: any, callback: (width: number, height: number) => void): void {
        let isDone = false;
        const onLoad = () => {
            done(image.width(), image.height());
        };
        image.on("load", onLoad);

        function done(width: number, height: number) {
            if (isDone) {
                return;
            }

            isDone = true;
            image.off("load", onLoad);

            callback(width, height);
        }
    }

    /**
     * Get whether scroll is at bottom
     */
    public getScrollIsAtBottom(): boolean {
        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        const maximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
        const currentScroll = chatElement[0].scrollTop;
        const scrollIsAtBottom = currentScroll >= Math.ceil(maximumScroll) - SCROLL_DETECTION_PADDING;

        return scrollIsAtBottom;
    }

    /**
     * Scroll the message list by the specified amount
     */
    public scrollBy(amount: number): void {
        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        chatElement[0].scrollTop += amount;
    }

    /**
     * Scrolls to the given height from the top
     *
     * @param height The height to set scroll top to
     */
    public scrollTo(height: number): void {
        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        chatElement[0].scrollTop = height;
    }

    /**
     * Scroll the message list to the bottom
     */
    public scrollToBottom(): void {
        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        const maximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
        chatElement[0].scrollTop = maximumScroll;
    }

    /**
     * Displays live typing messages for the specified discussion
     *
     * @param discussion The discussion to display live typing messages for
     */
    public displayLiveTyping(discussion: Discussion): void {
        const liveTypingMessages = discussion.liveTypingMessages;

        let message: Message;
        for (const key in liveTypingMessages) {
            if (liveTypingMessages.hasOwnProperty(key)) {
                message = liveTypingMessages[key] as Message;
                if (this._client.configuration.mergeLiveTypingWithCompleteChatArea) {
                    $(ElementIdentifiers.ChatSection.list).append(Templates.LiveTypingMessage(this._client, discussion, message));
                } else {
                    $(ElementIdentifiers.ChatSection.liveTyping).append(Templates.LiveTypingMessage(this._client, discussion, message));
                }
            }
        }

        this.scrollToBottom();
    }

    /**
     * Changes last message and current input field message to the last stored
     *
     * @param discussion The discussion to get our live typing message from
     */
    public updateOurLiveTyping(discussion: Discussion): void {
        const message = discussion.ourLiveTypingMessage;
        this.lastMessageInput = message || "";

        $(ElementIdentifiers.ChatInput.textInput).val(message || "");
        const textInputElem = $(ElementIdentifiers.ChatInput.textInput)[0];
        textInputElem.style.height = "0px";
        textInputElem.style.height = (textInputElem.scrollHeight) + "px";
    }

    /**
     * Creates a live typing element at the bottom of the message list
     *
     * @param message The message to put in the live typing preview list
     */
    public createLiveTyping(message: Message): void {
        const discussion = this._client.currentDiscussion;

        if (typeof discussion !== "undefined") {
            this.removeLiveTyping(message.userId);
            const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
            const maximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
            const currentScroll = chatElement[0].scrollTop;

            const scrollWasAtBottom = this.getScrollIsAtBottom();
            if (this._client.configuration.mergeLiveTypingWithCompleteChatArea) {
                $(ElementIdentifiers.ChatSection.list).append(Templates.LiveTypingMessage(this._client, discussion, message));
            } else {
                $(ElementIdentifiers.ChatSection.liveTyping).append(Templates.LiveTypingMessage(this._client, discussion, message));
            }

            // Scroll the chat to the bottom if they were at the bottom before
            if (scrollWasAtBottom) {
                this.scrollToBottom();
            }
        }
    }

    /**
     * Updates the content of an existing live typing element
     */
    public updateLiveTyping(message: Message): void {
        const scrollWasAtBottom = this.getScrollIsAtBottom();
        $(ElementIdentifiers.LiveMessage.identifier(message.userId))
            .find(ElementIdentifiers.LiveMessage.content)
            .html(message.getContentStyled());

        // Scroll the chat to the bottom if they were at the bottom before
        if (scrollWasAtBottom) {
            this.scrollToBottom();
        }
    }

    /**
     * Removes an existing live typing element based on userId
     *
     * @param userId The user id of the user to remove live typing preview for
     */
    public removeLiveTyping(userId: number): void {
        $(ElementIdentifiers.LiveMessage.identifier(userId)).remove();
    }

    /**
     * Removes all currently displayed live typing elements
     */
    public clearLiveTyping(): void {
        $(ElementIdentifiers.ChatSection.liveTyping).children().remove();
    }

    /**
     * Updates the displayed status of chat from an in-game user
     */
    public updateTerrariaUserStatus(name: string, online: boolean, tagColor?: string): void {
        if (online && tagColor) {
            $(`.chat-terraria-${Hash(name)}`)
                .removeClass(ElementIdentifiers.Message.terrariaOffline.substr(1))
                .addClass(ElementIdentifiers.Message.terrariaOnline.substr(1))
                .css("background", tagColor);
        } else {
            $(`.chat-terraria-${Hash(name)}`)
                .removeClass(ElementIdentifiers.Message.terrariaOnline.substr(1))
                .addClass(ElementIdentifiers.Message.terrariaOffline.substr(1))
                .css("background", "");
        }
    }

    /**
     * Updates the chat input username color to match their rank
     */
    public updateOurChatColor(): void {
        const currentDiscussion = this._client.currentDiscussion;

        if (currentDiscussion) {
            const isCreator = this._client.id === currentDiscussion.creator;
            const isMod = currentDiscussion.moderators[this._client.id];
            const creatorClass = ElementIdentifiers.Message.creator.substr(1);
            const modClass = ElementIdentifiers.Message.moderator.substr(1);

            const nameElement = $(ElementIdentifiers.ChatInput.main).find(ElementIdentifiers.ChatInput.username);
            if (isCreator) {
                nameElement.addClass(creatorClass).removeClass(modClass);
            } else if (isMod) {
                nameElement.removeClass(creatorClass).addClass(modClass);
            } else {
                nameElement.removeClass(creatorClass).removeClass(modClass);
            }
        }
    }

    /**
     * Updates the displayed username in the chat input section
     *
     * @param name The name to display ours as
     */
    public updateOurDisplayedName(name: string): void {
        $(ElementIdentifiers.ChatInput.main).find(ElementIdentifiers.ChatInput.username).text(name);
    }

    /**
     * Changes the thumbnail image of a video into the youtube video player
     */
    public displayYoutubeVideo(elem: any): void {
      const videoID = elem.attr("data-id");
      elem.empty();
      elem.append(`<iframe class="youtube-iframe"
                           src="https://www.youtube.com/embed/${videoID}?modestbranding=1&rel=0&autoplay=1&wmode=transparent&theme=light&color=white"
                           frameborder="0" allowfullscreen></iframe>`);
    }

    /**
     * Shows the loading icon in the messages section
     */
    public showMessageLoading(): void {
        $(ElementIdentifiers.ChatSection.loading).show();
        $(ElementIdentifiers.ChatSection.scrollSection).fadeTo(300, 0.3);
    }

    /**
     * Hides the loading icon in the messages section
     */
    public hideMessageLoading(): void {
        $(ElementIdentifiers.ChatSection.loading).hide();
        $(ElementIdentifiers.ChatSection.scrollSection).fadeTo(300, 1);
    }

    /**
     * Fades the messages section from 0.3 to 1
     */
    public fadeInMessages(): void {
        $(ElementIdentifiers.ChatSection.scrollSection)
            .stop(true)
            .fadeTo(100, 1);
    }

    /**
     * Fades the messages section from 1 to 0.6
     */
    public fadeOutMessages(): void {
        $(ElementIdentifiers.ChatSection.scrollSection)
            .stop(true)
            .fadeTo(0, 0.6);
    }

    /**
     * Moves the chat input back to the bottom of the chat area
     */
    public moveChatInputToBottom(): void {
        $(ElementIdentifiers.ChatInput.main).detach().appendTo($(ElementIdentifiers.ChatSection.main));
        $(ElementIdentifiers.ChatInput.textInput).focus();
        $(ElementIdentifiers.ChatInput.main).css("padding-left", "5px");
    }

    /**
     * Moves the chat input into the message list with the other messages
     */
    public moveChatInputToMessageList(): void {
        $(ElementIdentifiers.ChatInput.main).detach().appendTo($(ElementIdentifiers.ChatSection.list));
        $(ElementIdentifiers.ChatInput.textInput).focus();
        $(ElementIdentifiers.ChatInput.main).css("padding-left", "15px");
    }

    public onHistoryReceived(discussion: Discussion): void {
        if (discussion === this._client.currentDiscussion) {
            this.displayOlderMessages();
        }
    }

    public displayOlderMessages(): void {
        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        const discussion = this._client.currentDiscussion as Discussion;
        const messages = discussion.messages;
        const oldMaximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;

        // If there are more messages available to display, then they will be prepended
        if (messages.length > 40 && this._displayedMessages.length !== messages.length) {
            const startIndex = messages.length - this._displayedMessages.length - 1;
            let minIndex = startIndex - 40;
            if (minIndex < 0) {
                minIndex = 0;
            }

            for (let i = startIndex; i >= minIndex; i--) {
                this.prependMessage(messages[i] as Message);
            }

            // If scroll top is 0 this means the elements caused the other messages to go further down the screen
            if (chatElement[0].scrollTop === 0) {
                const newMaximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
                this.scrollTo(newMaximumScroll - oldMaximumScroll);
            }
        }
    }

    /**
     * Removes a message that exists only locally identified by a local id
     *
     * @param localMessageId The local message id of the message
     */
    public removeLocalMessage(localMessageId: number): void {
        $(ElementIdentifiers.Message.local(localMessageId)).remove();
    }

    /**
     * Displays the messages from the search results
     *
     * @param messages The list of messages from the search results
     */
    public displaySearchResults(terms: string, messages: Message[]): void {
        const search = this._client.discussionSearch as Search;
        const discussion = search.discussion as Discussion;
        const discussionName = new SafeString(discussion.name).getContentWithHtmlEscaped();
        const searchTerm = new SafeString(terms).getContentWithHtmlEscaped();
        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        const oldMaximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
        const oldMessageDisplayedCount = this._displayedMessages.length;

        $(ElementIdentifiers.ChatSection.title).html(`Search results for <i>${searchTerm}</i> in <b>${discussionName}</b>`);
        for (const message of messages.reverse()) {
            this.appendMessage(message);
        }

        // If scroll top is 0 this means the elements caused the other messages to go further down the screen
        if (oldMessageDisplayedCount > 0) {
            if (chatElement[0].scrollTop === 0) {
                const newMaximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
                this.scrollTo(newMaximumScroll - oldMaximumScroll);
            }
        } else {
            this.scrollToBottom();
        }
    }

    /**
     * Displays the deep history results for a paritcular message
     */
    public displayDeepHistory(): void {
        const deepHistory = this._client.deepHistory as DeepHistory;
        const discussionName = ((this._client.deepHistory as DeepHistory).discussion as Discussion).name;

        for (const message of deepHistory.messages) {
            this.appendMessage(message, false);
        }

        const rootMessage = $(ElementIdentifiers.ChatSection.list).find(`#${deepHistory.rootMessageId}`);
        rootMessage.addClass("root-message");

        const rootMessageContent = rootMessage.find(ElementIdentifiers.Message.content).text();
        const titleMessageContent = rootMessageContent.length > 35
            ? `${rootMessageContent.substr(0, 33)}...`
            : rootMessageContent;
        $(ElementIdentifiers.ChatSection.title).html(`Deep History for <i>${titleMessageContent}</i> in <b>${discussionName}</b>`);

        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        const maximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
        const offset = rootMessage.offset() as JQueryCoordinates;
        this.scrollBy(offset.top - chatElement[0].clientHeight / 2);
        (window as any).messageSection = this;
    }

    /**
     * Displays the older deep history results for a paritcular message
     *
     * @param messages The messages
     */
    public displayDeepHistoryOlder(messages: Message[]): void {
        for (const message of messages) {
            this.prependMessage(message);
        }

        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        const oldMaximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
        if (chatElement[0].scrollTop === 0) {
            const newMaximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
            this.scrollTo(newMaximumScroll - oldMaximumScroll);
        }
    }

    /**
     * Displays the newer deep history results for a paritcular message
     *
     * @param messages The messages
     */
    public displayDeepHistoryNewer(messages: Message[]): void {
        for (const message of messages) {
            this.appendMessage(message, false);
        }
    }

    public enableDiscussionTitleEditMode(clearTitle = false): void {
        const title = $(ElementIdentifiers.ChatSection.title);
        const currentTitle = title.text();
        title.html(`<input type="text"/>`);
        const input = title.children().first();
        if (!clearTitle) {
            input.val(currentTitle);
        }
        input.focus();

        const inputHtmlElem = input.get(0) as HTMLInputElement | any;
        if (inputHtmlElem.setSelectionRange) {
            inputHtmlElem.focus();
            inputHtmlElem.setSelectionRange(currentTitle.length, currentTitle.length);
        } else if (inputHtmlElem.createTextRange) {
            const range = inputHtmlElem.createTextRange();
            range.collapse(true);
            range.moveEnd("character", currentTitle.length);
            range.moveStart("character", currentTitle.length);
            range.select();
        }

        /**
         * Only works when current discussion is not undefined. So that when adding
         * a new discussion
         */
        $(input).on("keydown", (e) => {
            if (e.keyCode === 13) {
                this.saveTitleChanges();
            }
        });
    }

    /**
     * Saves the changes to the title by passing the info to the client object
     */
    public saveTitleChanges(): void {
        const title = $(ElementIdentifiers.ChatSection.title);
        if (title.children.length > 0) {
            const newTitle = title.children().first().val().trim();
            const currentDiscussion = this._client.currentDiscussion;
            if (typeof currentDiscussion !== "undefined") {
                if (newTitle !== currentDiscussion.name) {
                    title.text(newTitle);
                    this._client.updateDiscussionName(currentDiscussion, newTitle);
                }
            } else if (this._client.creatingNewDiscussion) {
                this._client.createDiscussion(newTitle);
            }
        }
    }
}

export default MessageSection;
