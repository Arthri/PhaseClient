import $ from "jquery";
import User from "phaseclient/user";
import SearchUserResults from "phasecore/messagetypes/searchuserresults";
import TerrariaUsersOnline, { TerrariaUser } from "phasecore/messagetypes/terrariausersonline";
import UserStatus from "phasecore/userstatus";
import Client from "phaseweb/client";
import ElementIdentifiers from "phaseweb/elementidentifiers";
import Hash from "phaseweb/hash";
import PeopleSectionEvents from "phaseweb/pagemodel/peoplesection/events";
import { ScrollElement } from "phaseweb/scroller";
import Scroller from "phaseweb/scroller";
import Templates from "phaseweb/templates";

class PeopleSection {
    private _client: Client;
    private _discussionUsersScroller: Scroller;
    private _events: PeopleSectionEvents;

    constructor(client: Client) {
        this._client = client;
    }

    /**
     * Registers the events for the people section
     */
    public registerEvents(): void {
        this._events = new PeopleSectionEvents(this, this._client);
    }

    /**
     * Clears the existing displayed list and puts in an updated one
     */
    public refreshUsersOnlineList(): void {
        const sectionList = $(ElementIdentifiers.PeopleSection.phaseUsers).children(ElementIdentifiers.PeopleSection.list).children("ul");
        sectionList.html("");

        const onlineUsers = this._client.onlineUsers;
        onlineUsers.sort((a, b): number => {
            if (a.lowerCaseName > b.lowerCaseName) {
                return 1;
            } else {
                return -1;
            }
        });

        let user: User;
        for (let i = 0; i < onlineUsers.length; i++) {
            user = onlineUsers[i];
            sectionList.append(new Templates.PeopleEntry(this._client, user, null).getContent());
        }

        $(ElementIdentifiers.PeopleSection.onlineUsersCount).text(onlineUsers.length);
    }

    /**
     * Updates the discussion users list
     *
     * @param resetScrollTop Whether to put the scroll bar back to the top
     */
    public updateDiscussionUsersList(resetScrollTop = false): void {
        const currentDiscussion = this._client.currentDiscussion;
        if (currentDiscussion !== undefined) {
            const onlineUserElements: ScrollElement[] = [];
            const staffOnlineElements: ScrollElement[] = [];
            const busyUserElements: ScrollElement[] = [];
            const offlineUserElements: ScrollElement[] = [];
            const members = currentDiscussion.members as User[];
            const staffSection = {
                element: new Templates.PeopleSectionStaff,
                instance: null
            };
            const onlineSection = {
                element: new Templates.PeopleSectionOnline,
                instance: null
            };
            const offlineSection = {
                element: new Templates.PeopleSectionOffline,
                instance: null
            };
            let onlineUsers = 0;

            members.sort((a, b): number => {
                const aIsMod = currentDiscussion.moderators[a.id];
                const bIsMod = currentDiscussion.moderators[b.id];
                if (aIsMod === bIsMod) {
                    return a.lowerCaseName.localeCompare(b.lowerCaseName);
                }

                return aIsMod ? -1 : 1;
            });

            // seperate users into online/offline lists
            for (const member of members) {
                if (member.status !== UserStatus.Offline && currentDiscussion.moderators[member.id]) {
                    staffOnlineElements.push({
                        element: new Templates.PeopleEntry(this._client, member as User, currentDiscussion),
                        instance: member as User
                    });
                    onlineUsers++;
                } else if (member.status === UserStatus.Online) {
                    onlineUserElements.push({
                        element: new Templates.PeopleEntry(this._client, member as User, currentDiscussion),
                        instance: member as User
                    });
                    onlineUsers++;
                } else if (member.status === UserStatus.Busy) {
                    busyUserElements.push({
                        element: new Templates.PeopleEntry(this._client, member as User, currentDiscussion),
                        instance: member as User
                    });
                    onlineUsers++;
                } else {
                    offlineUserElements.push({
                        element: new Templates.PeopleEntry(this._client, member as User, currentDiscussion),
                        instance: member
                    });
                }
            }

            this._discussionUsersScroller.elements = [].concat(
                staffOnlineElements.length ? [staffSection] : [],
                staffOnlineElements, 
                onlineUserElements.length ? [onlineSection] : [], 
                onlineUserElements, 
                busyUserElements, 
                offlineUserElements.length ? [offlineSection] : [], 
                offlineUserElements);

            $(ElementIdentifiers.PeopleSection.discussionUsersCount).text(`${onlineUsers} / ${members.length}`);

            if (resetScrollTop) {
                this._discussionUsersScroller.scrollTop = 0;
            }

        }
    }

    public setupScrollers(): void {
        this.setupDiscussionUsersScroller();
    }

    private setupDiscussionUsersScroller(): void {
        const discussionUsersSection = $(ElementIdentifiers.PeopleSection.discussionUsers);
        const discussionUsersScroller = discussionUsersSection.find(ElementIdentifiers.PeopleSection.list).first();
        const discussionUsersList = discussionUsersSection.find(ElementIdentifiers.PeopleSection.list).first().find("ul").first();
        this._discussionUsersScroller = new Scroller(discussionUsersList, discussionUsersScroller, [], 25, 80);
        this.hookDiscusionUsersScroll(discussionUsersScroller);
    }

    private hookDiscusionUsersScroll(element: JQuery): void {
        element.on("scroll", () => {
            this._discussionUsersScroller.onScroll();
        });
    }

    /**
     * Displays the latest user search results
     *
     * @param searchUserResults The search results
     */
    public handleSearchUserResults(searchUserResults: SearchUserResults): void {
        const resultList = $(ElementIdentifiers.PeopleSection.addDiscussionUserSearchResults);
        if (resultList.length > 0) {
            resultList.children().remove();

            let count = 0;
            for (const result of searchUserResults.results.reverse()) {
                if (++count <= 5) {
                    resultList.append(Templates.SearchUserResult(this._client.systemName, result.Username, result.SystemName, result.Avatar));
                }
            }
        }
    }

    public setInGameUsersList(users: TerrariaUsersOnline): void {
        $(ElementIdentifiers.PeopleSection.terrariaUsersCount).text(users.length);
        const terrariaUsersSection = $(ElementIdentifiers.PeopleSection.terrariaUsers);
        const terrariaUsersList = terrariaUsersSection.find(ElementIdentifiers.PeopleSection.list).first();
        terrariaUsersList.html("");
        const usersGrouped = new Map<string, TerrariaUser[]>();
        for (const user of users) {
            if (!usersGrouped.has(user.tagColour)) {
                usersGrouped.set(user.tagColour, []);
            }

            (usersGrouped.get(user.tagColour) as TerrariaUser[]).push(user);
        }

        const groups = Array.from(usersGrouped.values());
        for (const groupedUsers of groups) {
            let str = `<div id="ingame-server-${Hash(groupedUsers[0].tagName)}" class="people-section-ingame-sub">\
                        <div class="people-section-ingame-sub-head">
                            <div class="people-section-ingame-circle" style="background-color: ${groupedUsers[0].tagColour}"></div>\
                            ${groupedUsers[0].tagName}
                        </div>
                        <ul>`;
            for (const user of groupedUsers) {
                str += `<li id="ingame-user-${Hash(user.name)}">${user.name}</li>`;
            }

            terrariaUsersList.append(str + "</ul></div>");
        }
    }

    public removeUserFromInGameList(user: TerrariaUser): void {
        $(`#ingame-user-${Hash(user.name)}`).remove();
        const count = $(ElementIdentifiers.PeopleSection.terrariaUsersCount);
        count.text(parseInt(count.text()) - 1);
    }

    public addUserToInGameList(user: TerrariaUser): void {
        let gameList = $(`#ingame-server-${Hash(user.tagName)}`);
        if (!gameList.length) {
            this.createInGameList(user.tagName, user.tagColour);
            gameList = $(`#ingame-server-${Hash(user.tagName)}`);
        }

        gameList.find("ul").append(`<li id="ingame-user-${Hash(user.name)}">${user.name}</li>`);
        const count = $(ElementIdentifiers.PeopleSection.terrariaUsersCount);
        count.text(parseInt(count.text()) + 1);
    }

    public createInGameList(tagName: string, tagColour: string): void {
        const terrariaUsersSection = $(ElementIdentifiers.PeopleSection.terrariaUsers);
        const terrariaUsersList = terrariaUsersSection.find(ElementIdentifiers.PeopleSection.list).first();
        terrariaUsersList.append(`<div id="ingame-server-${Hash(tagName)}" class="people-section-ingame-sub">\
                    <div class="people-section-ingame-sub-head">
                        <div class="people-section-ingame-circle" style="background-color: ${tagColour}"></div>\
                        ${tagName}
                    </div>
                    <ul>`);
    }
}

export default PeopleSection;
