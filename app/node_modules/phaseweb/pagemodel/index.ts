import $ from "jquery";
import Cookie from "phaseclient/cookie";
import Discussion from "phaseclient/discussion";
import Message from "phaseclient/message";
import User from "phaseclient/user";
import Client from "phaseweb/client";
import ElementIdentifiers from "phaseweb/elementidentifiers";
import Hash from "phaseweb/hash";
import AvatarUpload from "phaseweb/pagemodel/avatarupload";
import DiscussionSection from "phaseweb/pagemodel/discussionsection";
import MessageSection from "phaseweb/pagemodel/messagesection";
import PeopleSection from "phaseweb/pagemodel/peoplesection";
import SettingsSection from "phaseweb/pagemodel/settings";
import Shortcuts from "phaseweb/pagemodel/shortcuts";

declare var Notification;
declare var process;

class PageModel {
    private _client: Client;
    private _loginLoadingTimeout: any;
    private _windowHasFocus: boolean;
    private _lastNotification: Notification | null;
    private _notificationSound: HTMLAudioElement;
    private _shortcuts: Shortcuts;
    private _avatarUpload: AvatarUpload;
    private _settingsSection: SettingsSection;
    public peopleSection: PeopleSection;
    public discussionSection: DiscussionSection;
    public messageSection: MessageSection;

    constructor(client: Client) {
        this._client = client;
        this.peopleSection = new PeopleSection(client);
        this.messageSection = new MessageSection(client);
        this.discussionSection = new DiscussionSection(client);
        this._settingsSection = new SettingsSection(client);
        this._avatarUpload = new AvatarUpload(client);
        this._windowHasFocus = true;
        this._lastNotification = null;
        this.registerEvents();
        this.setupScrollers();
        this._notificationSound = new Audio("https://t.dark-gaming.com:3001/sounds/sonar.wav");
        this._shortcuts = new Shortcuts(client);

        Notification.requestPermission((result) => 0);
    }

    public get windowHasFocus(): boolean {
        return this._windowHasFocus;
    }

    private isElectron(): boolean {
        const _window: any = window;
        // Renderer process
        if (typeof _window !== "undefined" && typeof _window.process === "object" && _window.process.type === "renderer") {
            return true;
        }

        // Main process
        if (typeof process !== "undefined" && typeof process.versions === "object" && !!process.versions.electron) {
            return true;
        }

        // Detect the user agent when the `nodeIntegration` option is set to true
        if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) {
            return true;
        }

        return false;
    }

    private async getElectronSession(): Promise<string> {
        return new Promise<string>((resolve, reject) => {
            let session = "";

            // Bypass webpack trying to resolve electron
            const cookieList = eval("require")("electron").remote.getCurrentWindow().webContents.session.cookies;
            cookieList.get({}, (err, cookies) => {
                for (const cookie of cookies) {
                    if (cookie.name === "_phasesession") {
                        session = cookie.value;
                    }
                }

                resolve(session);
            });
        });
    }

    private async getSession(): Promise<string> {
        let session = "";
        if (this.isElectron()) {
            session = await this.getElectronSession();
        } else {
            session = Cookie.getCookie("_phasesession") || "";
        }

        return session;
    }

    /**
     * Checks to see if a session is available to skip login page
     */
    public async checkSession(): Promise<void> {
        const session = await this.getSession();
        if (session.length > 0) {
            this.handleLoginSuccess(session);
        } else {
            $(ElementIdentifiers.Login.loading).hide();
            $(ElementIdentifiers.Login.container).removeClass("inactive");
        }

        const navigate = navigator as any;
        navigate.serviceWorker.register("sw.js");
    }

    /**
     * Displays a notification to the user
     *
     * @param text The text body of the notification
     */
    public showNotification(discussion: Discussion, text: string): void {
        if (!Notification) {
            alert("Notifications are supported in modern versions of Chrome, Firefox, Opera and IE.");
            return;
        }

        if (Notification.permission !== "granted") {
            Notification.requestPermission();
        }

        if (this._lastNotification !== null) {
            this._lastNotification.close();
        }

        const notification = new Notification(discussion.name, {
            icon: "https://t.dark-gaming.com:3001/img/128.png",
            body: text,
            id: "darkgamingphase",
            silent: true
        });

        this._lastNotification = notification;
        notification.onclick = () => {
            window.focus();
            this._client.switchDiscussion(discussion.id);
            this._lastNotification = null;
        };

        this.playNotificationSound();
    }

    /**
     * Plays the notification sound
     */
    private playNotificationSound(): void {
        this._notificationSound.play();
    }

    /**
     * Updates the client username in the DOM
     *
     * @param username The username of the current user
     */
    public updateUsername(username: string): void {
        $(ElementIdentifiers.clientUsername).text(username);
        this.messageSection.updateOurDisplayedName(username);
    }

    /**
     * Updates the client avatar in the DOM
     *
     * @param avatar The avatar of the current user
     */
    public updateAvatar(avatar: string): void {
        $(ElementIdentifiers.ChatInput.avatar).html(`<img src="${avatar}" />`);
    }

    public updateUserAvatar(user: User): void {
        $(`.avatar_${user.id}`).attr("src", user.avatar);
        $(`.avatar_hash${Hash(user.formatNameNoBbcode)}`).attr("src", user.avatar);
    }

    /**********
     * EVENTS *
     **********/

    /**
     * Registers the necessary events for interactivity
     */
    protected registerEvents(): void {
        this.messageSection.registerEvents();
        this.discussionSection.registerEvents();
        this.peopleSection.registerEvents();
        this._avatarUpload.registerEvents();
        this.registerLogin();
        this.registerWindowFocus();
        this.registerDropdownClick();
        this.registerLogoutClick();
    }

    /**
     * Sends an ajax request using the login details provided when the login form is submitted
     */
    private registerLogin(): void {
        $("#login_form").submit((e) => {
            e.preventDefault();
            this.setLoadingTimeout();

            $.ajax({
                method: "POST",
                url: "https://t.dark-gaming.com:3001/login",
                data: {
                username: $("#username").val(),
                password: $("#password").val(),
                server: $("#servername").find(":selected").text()
                },
                success: (data, textStatus, request) => {
                    this.handleLoginResponse(data, textStatus, request);
                }
            });
            return false;
        });
    }

    /**
     * Sets a timeout to remove the loading icon
     */
    private setLoadingTimeout(): void {
        this._loginLoadingTimeout = setTimeout(() => {
            $(ElementIdentifiers.Login.loading).show();
            $(ElementIdentifiers.Login.container).addClass("inactive");
        }, 300);
    }

    /**
     * Displays a message when there was an error or closes the login form if it was successful
     *
     * @param data The response state and session token
     * @param textStatus
     * @param request
     */
    private handleLoginResponse(data: {state: string, session: string}, textStatus: string, request: any): void {
        switch (data.state) {
            case "success":
                this.handleLoginSuccess(data.session);
                break;
            case "failure":
                $(ElementIdentifiers.Login.information).html('<span style="color: Red;">Invalid User/Pass Combination.</span>');
                break;
            case "no-body":
                $(ElementIdentifiers.Login.information).html('<span style="color: Red;">This form is invalid. Refresh the page.</span>');
                break;
            case "timeout":
                $(ElementIdentifiers.Login.information).html('<span style="color: Red;">The server selected is currently unresponsive.</span>');
                break;
            default:
                $(ElementIdentifiers.Login.information).html('<span style="color: Red;">Unknown error.</span>');
                break;
        }

        if (data.state !== "success") {
            clearTimeout(this._loginLoadingTimeout);
            $(ElementIdentifiers.Login.container).removeClass("inactive");
            $(ElementIdentifiers.Login.loading).hide();

            setTimeout(() => {
                $(ElementIdentifiers.Login.information).empty();
            }, 4000);
        }
    }

    public displayLoginPage(): void {
        $("#phase").css("display", "none");
        $(ElementIdentifiers.Login.main).css("display", "block");
    }

    /**
     * Hides the login form and sends off an information request through the network
     *
     * @param session The session token received from the login request
     */
    private handleLoginSuccess(session: string): void {
        $("#phase").css("display", "block");
        $(ElementIdentifiers.Login.main).css("display", "none");
        this._client.sendInformationRequest(session);
    }

    /**
     * Stores whether the window is in focus
     */
    private registerWindowFocus(): void {
        $(window).focus(() => {
            this._windowHasFocus = true;
        }).blur(() => {
            this._windowHasFocus = false;
        });
    }

    /**
     * Registers the click on the dropdown icon to open/close the dropdown menu
     */
    private registerDropdownClick(): void {
        const dropDown = $(ElementIdentifiers.NavigationBar.dropDown);
        const menu = $(ElementIdentifiers.NavigationBar.dropDownMenu);
        dropDown.on("click", (e) => {
            if (menu.css("display") === "none") {
                menu.css("display", "block");
            } else {
                menu.css("display", "none");
            }
            e.stopPropagation();
        });

        $("body").on("click", (e) => {
            if ($(e.target).parents(ElementIdentifiers.NavigationBar.dropDownMenu).length === 0
                && !$(e.target).hasClass(ElementIdentifiers.NavigationBar.dropDownMenu.substr(1))) {
                menu.css("display", "none");
            }
        });
    }

    /**
     * Registers the click on the logout button to log the user out
     */
    private registerLogoutClick(): void {
        $(ElementIdentifiers.NavigationBar.logout).on("click", (e) => {
            document.cookie = `_phasesession=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;`;
            window.location.reload();
            e.preventDefault();
        });
    }

    /*******************
    * Custom Scrollers *
    ********************/
    private setupScrollers() {
        this.discussionSection.setupScroller();
        this.peopleSection.setupScrollers();
    }
}

export default PageModel;
