import ElementIdentifiers from 'phaseweb/elementidentifiers';
import Templates from 'phaseweb/templates';
import * as $ from 'jquery';
import Client from 'phaseweb/client';
import Discussion from 'phase/discussion';
import Message from 'phase/message';
import Cookie from 'phase/cookie';
import TextDifference from 'phase/textdifference';
import System from 'phase/system';
import Scroller from 'phaseweb/scroller';
import UserStatus from 'phase/userstatus';

declare var Notification;

class PageModel {
    private client: Client;
    private loginLoadingTimeout: number;
    private windowHasFocus: boolean;
    private lastMessageInput: string;
    private discusionListScroller: Scroller;
    private messageListScroller: Scroller;
    private discussionUsersScroller: Scroller;

    constructor(client: Client) {
        this.client = client;
        this.windowHasFocus = true;
        this.lastMessageInput = "";
        this.registerEvents();
        this.setupScrollers();
    }

    public getWindowHasFocus(): boolean {
        return this.windowHasFocus;
    }

    /**
     * Checks to see if a session is available to skip login page
     */
    public checkSession(): void {
        let session = Cookie.getCookie('_phasesession');
        if (session) {
            this.handleLoginSuccess(session);
        } else {
            $(ElementIdentifiers.Login.loading).hide();
            $(ElementIdentifiers.Login.container).removeClass("inactive");
        }

        let navigate = <any>navigator;
        navigate.serviceWorker.register('sw.js');
    }

    /**
     * Displays a notification to the user
     * 
     * @param text The text body of the notification
     */
    public showNotification(text: string): void {
        console.log("Attempting to show notification for "+text);
        Notification.requestPermission(function(result) {
        let navigate = <any>navigator;
            if (result === 'granted') {
                navigate.serviceWorker.getRegistration().then(function(registration) {
                    registration.showNotification('Phase', {
                        body: text,
                        icon: 'https://t.dark-gaming.com:3001/img/128.png',
                        vibrate: [200, 100, 200, 100, 200, 100, 200],
                        tag: 'vibration-sample'
                    });
                });
            }
        });
    }

    /** 
     * Updates the client username in the DOM
     * 
     * @param username The username of the current user
     */
    public updateUsername(username: string): void {
        $(ElementIdentifiers.clientUsername).text(username);
    }

    /**
     * Updates the client avatar in the DOM
     * 
     * @param avatar The avatar of the current user
     */
    public updateAvatar(avatar: string): void {
        $(ElementIdentifiers.ChatInput.avatar).html(`<img src="${avatar}" />`);
    }

    /******************
     * People Section *
     ******************/

    /**
     * Clears the existing displayed list and puts in an updated one
     */
    public refreshUsersOnlineList(): void {
        let sectionList = $(ElementIdentifiers.PeopleSection.main).children(ElementIdentifiers.PeopleSection.list).children('ul');
        sectionList.html('');

        let user;
        let onlineUsers = this.client.getOnlineUsers();
        onlineUsers.sort((a, b): number => {
            if (a.getName().toLowerCase() > b.getName().toLowerCase()) {
                return 1;
            } else {
                return -1;
            }
        });
        for (let i = 0; i < onlineUsers.length; i++) {
            user = onlineUsers[i];
            sectionList.append(Templates.PeopleEntry(user));
        }

        $(ElementIdentifiers.PeopleSection.onlineUsersCount).text(onlineUsers.length);
    }

    /**
     * Updates the discussion users list
     */
    public updateDiscussionUsersList(resetScrollTop = false): void {
        let currentDiscussion = this.client.getCurrentDiscussion();
        if (currentDiscussion !== undefined) {
            let onlineUserElements: string[] = [];
            let offlineUserElements: string[] = [];
            let members = currentDiscussion.getMembers();
            let onlineUsers = 0;

            members.sort((a, b): number => {
                if (a.getName().toLowerCase() > b.getName().toLowerCase()) {
                    return 1;
                } else {
                    return -1;
                }
            });

            // seperate users into online/offline lists
            for (let i = 0; i < members.length; i++) {
                if (members[i].getStatus() === UserStatus.Online) {
                    onlineUserElements.push(Templates.PeopleEntry(members[i]));
                    onlineUsers++;
                } else {
                    offlineUserElements.push(Templates.PeopleEntry(members[i]));
                }
            }


            this.discussionUsersScroller.setElements(onlineUserElements.concat(offlineUserElements));

            $(ElementIdentifiers.PeopleSection.discussionUsersCount).text(`${onlineUsers} / ${members.length}`);
            
            if (resetScrollTop) {
                this.discussionUsersScroller.elementScroller[0].scrollTop = 0;
            }

        }
    }

    /***************************
     * Chat Section / Messages *
     ***************************/

    /**
     * Updates the title displayed in the GUI
     * 
     * @param name The title of the messages (such as discussion name)
     */
    public updateDisplayedTitle(name: string): void {
        $(ElementIdentifiers.ChatSection.title).text(name);
    }

    /**
     * Clears the messages diplayed in the message list
     */
    public clearMessages(): void {
        $(ElementIdentifiers.ChatSection.list).children().remove();
    }

    /**
     * Displays 40 messages in the chat list from the specified discussion
     * 
     * @param discussion The discussion to display messages for
     */
    public displayMessages(discussion: Discussion): void {
        let messages = discussion.getMessages();
        let minIndex = messages.length-41 < 0 ? 0 : messages.length-41;
        for (let i = minIndex; i < messages.length; i++) {
            this.appendMessage(i >= 0 ? messages[i-1] : null, messages[i]);
        }
    }

    /**
     * Adds a message to the message display at the end (bottom)
     * 
     * @param lastMessage The last message displayed
     * @param message The message to add to the message display
     */
    private appendMessage(lastMessage: Message | null, message: Message) {
        // If join/leave message and config setting is not to display these, do not handle the message
        if (!this.client.getConfiguration().useAndDisplayJoinLeaveMessages && message.getUserId() == -2 && message.getTag().length !== 0) {
            return;
        }

        // If the config has it set that messages are to be combined then checks need to be done
        if (this.client.getConfiguration().combineMessages) {
            // If the first message or is a join/leave message (so it contains ip, origin, that must be kept in-tact etc)
            if (lastMessage == null || message.getUserId() == System.joinLeaveMessageUserId) {
                $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this.client, message));
            } else {                
                // Combine messages that were sent by the same user consecutively, under a minute in difference
                if (lastMessage.getUserId() === message.getUserId()
                    && Math.abs(lastMessage.getTimestamp()-message.getTimestamp()) <= 60
                    && lastMessage.getTag() == message.getTag()) {
                    $(ElementIdentifiers.ChatSection.list).children('li').last().find('.chat-message-content').append("<br>"+message.getContentStyled());
                } else {
                    $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this.client, message));
                }
            }
        // Otherwise just append the message to the list
        } else {
            $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this.client, message));
        }   
    }

    /**
     * Displays a message in the message list by appending it
     * 
     */
    public displayMessage(lastMessage: Message | null, message: Message): void {
        let scrollIsAtBottom = this.getScrollIsAtBottom();
        this.appendMessage(lastMessage, message); 

        // Scroll the chat to the bottom if they were at the bottom before
        if (scrollIsAtBottom) {
            // Remove messages that go over max of 40 in display
            this.removeOldestMessages($(ElementIdentifiers.ChatSection.list).children().length-40);
            this.scrollToBottom();
        }
    }

    /**
     * Remove the oldest n messages from the discussion message list
     */
    public removeOldestMessages(amount: number): void {
        if (amount < 0) {
            amount = 0;
        }
        $(ElementIdentifiers.ChatSection.list).children().slice(0, amount).remove();
    }

    /**
     * Get whether scroll is at bottom
     */
    public getScrollIsAtBottom(): boolean {
        let chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        let maximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
        let currentScroll = chatElement[0].scrollTop;
        let scrollIsAtBottom = currentScroll == maximumScroll;

        return scrollIsAtBottom;
    }

    /**
     * Scroll the message list to the bottom
     */
    public scrollToBottom(): void {
        let chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        let maximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
        chatElement[0].scrollTop = maximumScroll;
    }

    /**
     * Displays live typing messages for the specified discussion
     * 
     * @param discussion The discussion to display live typing messages for
     */
    public displayLiveTyping(discussion: Discussion): void {
        let liveTypingMessages = discussion.getLiveTypingMessages();

        let message: Message;
        for (let key in liveTypingMessages) {
            message = liveTypingMessages[key];
            $(ElementIdentifiers.ChatSection.liveTyping).append(Templates.LiveTypingMessage(this.client, message));
        }

        this.scrollToBottom();
    }
    
    /**
     * Creates a live typing element at the bottom of the message list
     * 
     * @param message The message to put in the live typing preview list
     */
    public createLiveTyping(message: Message): void {
        let scrollIsAtBottom = this.getScrollIsAtBottom();
        $(ElementIdentifiers.ChatSection.liveTyping).append(Templates.LiveTypingMessage(this.client, message));
        
        // Scroll the chat to the bottom if they were at the bottom before
        if (scrollIsAtBottom) {
            this.scrollToBottom();
        }
    }
    
    /**
     * Updates the content of an existing live typing element
     */
    public updateLiveTyping(message: Message): void {
        let scrollIsAtBottom = this.getScrollIsAtBottom();
        $(ElementIdentifiers.LiveMessage.identifier(message.getUserId())).find(ElementIdentifiers.LiveMessage.content).text(message.getContentStyled());

        // Scroll the chat to the bottom if they were at the bottom before
        if (scrollIsAtBottom) {
            this.scrollToBottom();
        }
    }
    
    /**
     * Removes an existing live typing element based on userId
     * 
     * @param userId The user id of the user to remove live typing preview for
     */
    public removeLiveTyping(userId: number): void {
        $(ElementIdentifiers.LiveMessage.identifier(userId)).remove();
    }

    /**
     * Removes all currently displayed live typing elements
     */
    public clearLiveTyping(): void {
        $(ElementIdentifiers.ChatSection.liveTyping).children().remove();
    }

    /*******************
     * Discussion List *
     *******************/

    /**
     * Adds a discussion to the top of the discussions list
     * 
     * @param discussion The discussion to add to the discussion list
     */
    public prependDiscussionsList(discussion: Discussion): void {
        //$(ElementIdentifiers.DiscussionSection.list).prepend(Templates.DiscussionListEntry(discussion));
        this.discusionListScroller.prependElement(Templates.DiscussionListEntry(discussion));
    }

    /**
     * Updates the selected class to the newly switched discussion
     * 
     * @param elem The element that was clicked to switch discussion
     */
    public switchSelectedDiscussion(elem: any): void {
        $('.selected').removeClass('selected');
        elem.addClass('selected');
    }

    /**
     * Remove unread style to discussion div
     */
    public setDiscussionRead(discussion: Discussion): void {
        $(`#disc${discussion.getId()}`)
            .removeClass('unread');
    }

    /**
     * Apply unread style to discussion div
     * 
     * @param discussion The discussion to set as unread
     */
    public setDiscussionUnread(discussion: Discussion): void {
        $(`#disc${discussion.getId()}`)
            .addClass('unread');
    }

    /**
     * Update the preview of the discussion div in the discussion list
     * 
     * @param discussion The discussion to update preview for
     */
    public updateDiscussionEntryMessagePreview(discussion: Discussion): void {
        $(`#disc${discussion.getId()}`)
            .children(ElementIdentifiers.DiscussionSection.preview)
            .text(`${discussion.getRecentMessage().getDisplayName().asIs()}: ${discussion.getRecentMessage().getContent().withBbcodeStripped()}`);
    }

    /**********
     * EVENTS *
     **********/

    /**
     * Registers the necessary events for interactivity
     */
    protected registerEvents(): void {
        this.registerDiscussionListClick();
        this.registerUsersInDiscussionClick();
        this.registerPhaseUsersOnlineClick();
        this.registerMessageSend();
        this.registerLogin();
        this.registerWindowFocus();
        this.registerTextInput();
    } 

    /**
     * Registers a click on a discussion list element for switching discussions
     */
    private registerDiscussionListClick(): void {
        let self = this;
        $(ElementIdentifiers.DiscussionSection.list).on('mousedown', ElementIdentifiers.DiscussionSection.discussion, function() {
            self.client.switchDiscussion(+$(this).attr('id').substr(4), $(this));
        });
    }

    private registerUsersInDiscussionClick(): void {
        $(ElementIdentifiers.PeopleSection.discussionUsers).on('mousedown', function() {
            let list = $(this).children(ElementIdentifiers.PeopleSection.list).first();
            if (list.css('display') === "none") {
                list.css('display', 'block');
            } else {
                list.css('display', 'none');
            }
        });
    }

    private registerPhaseUsersOnlineClick(): void {
        $(ElementIdentifiers.PeopleSection.phaseUsers).on('mousedown', function() {
            let list = $(this).children(ElementIdentifiers.PeopleSection.list).first();
            if (list.css('display') === "none") {
                list.css('display', 'block');
            } else {
                list.css('display', 'none');
            }
        });
    }

    /**
     * Registers the submit event of the chat message form for sending a message
     */
    private registerMessageSend(): void {
        let self = this;
        $(ElementIdentifiers.ChatInput.textInput).on('keydown', function(event) {
            if (event.keyCode == 13) {
                self.handleMessageSend(this);
            }
        });
    }

    /**
     * Tells the client to take the nessary steps to send the message
     */
    private handleMessageSend(context: any): void {
        let chatText = $(context).val();
        this.client.sendChatMessage(chatText);
        $(context).val('');
    }

    /** 
     * Sends an ajax request using the login details provided when the login form is submitted
     */
    private registerLogin(): void {
        $('#login_form').submit((e) => {
            e.preventDefault();
            this.setLoadingTimeout();
            
            $.ajax({
                method: "POST",
                url: "https://t.dark-gaming.com:3001/login",
                data: {
                username: $('#username').val(),
                password: $('#password').val(),
                server: $('#servername').find(':selected').text()
                },
                success: (data, textStatus, request) => {
                    this.handleLoginResponse(data, textStatus, request);
                }
            });
            return false;
        });
    }

    /**
     * Sets a timeout to remove the loading icon
     */ 
    private setLoadingTimeout(): void {
        this.loginLoadingTimeout = setTimeout(() => {
            $(ElementIdentifiers.Login.loading).show();
            $(ElementIdentifiers.Login.container).addClass('inactive');
        }, 300);
    }

    /**
     * Displays a message when there was an error or closes the login form if it was successful
     * 
     * @param data The response state and session token
     * @param textStatus 
     * @param request 
     */
    private handleLoginResponse(data: {state: string, session:string}, textStatus: string, request: any): void {
        switch (data.state) {
            case "success":
                this.handleLoginSuccess(data.session);
                break;
            case "failure":
                $(ElementIdentifiers.Login.information).html('<span style="color: Red;">Invalid User/Pass Combination.</span>');
                break;
            case "no-body":
                $(ElementIdentifiers.Login.information).html('<span style="color: Red;">This form is invalid. Refresh the page.</span>');
                break;
            case "timeout":
                $(ElementIdentifiers.Login.information).html('<span style="color: Red;">The server selected is currently unresponsive.</span>');
                break;
            default:
                $(ElementIdentifiers.Login.information).html('<span style="color: Red;">Unknown error.</span>');
                break;
        }

        if (data.state !== 'success') {
            clearTimeout(this.loginLoadingTimeout);
            $(ElementIdentifiers.Login.container).removeClass('inactive');
            $(ElementIdentifiers.Login.loading).hide();

            setTimeout(() => {
                $(ElementIdentifiers.Login.information).html('');
            }, 4000);
        }
    }

    /**
     * Hides the login form and sends off an information request through the network
     * 
     * @param session The session token received from the login request
     */
    private handleLoginSuccess(session: string): void {
        $('#phase').css("display", "block");
        $(ElementIdentifiers.Login.main).css("display", "none");
        this.client.sendInformationRequest(session);
    }

    /**
     * Stores whether the window is in focus
     */
    private registerWindowFocus(): void {
        $(window).focus(() => {
            this.windowHasFocus = true;
        }).blur(() => {
            this.windowHasFocus = false;
        });
    }

    private registerTextInput(): void {
        let self = this;
        $(ElementIdentifiers.ChatInput.textInput).on('input', function(event) {
            let currentMessage = $(this).val();
            let queue = TextDifference.getEditQueue(self.lastMessageInput, currentMessage);
            self.lastMessageInput = currentMessage;

            self.client.sendEditQueue(queue);
        });
    }

    /*******************
    * Custom Scrollers *
    ********************/
    private setupScrollers() {
        this.setupDiscussionListScroller();
        this.setupDiscussionUsersScroller();
    }

    private setupDiscussionListScroller(): void {
        this.discusionListScroller = new Scroller($(ElementIdentifiers.DiscussionSection.list), $(ElementIdentifiers.DiscussionSection.list), [], 70);
        $(ElementIdentifiers.DiscussionSection.list).on('scroll', () => {
            this.discusionListScroller.onScroll();
        });
    }

    private setupDiscussionUsersScroller(): void {
        let discussionUsersSection = $(ElementIdentifiers.PeopleSection.discussionUsers);
        let discussionUsersScroller = discussionUsersSection.find(ElementIdentifiers.PeopleSection.list).first();
        let discussionUsersList = discussionUsersSection.find(ElementIdentifiers.PeopleSection.list).first().find('ul').first();
        this.discussionUsersScroller = new Scroller(discussionUsersList, discussionUsersScroller, [], 25, 80);
        $(discussionUsersScroller).on('scroll', () => {
            this.discussionUsersScroller.onScroll();
        });
    }
}

export default PageModel;