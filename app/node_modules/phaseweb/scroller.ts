import {$, JQuery} from 'jquery';
import Discussion from 'phaseclient/discussion';
import ElementIdentifiers from 'phaseweb/elementidentifiers';
import Templates from 'phaseweb/templates';
import { DiscussionHash } from 'phaseclient/hash';

interface ContentElement {
    getContent(): string;
}

export interface ScrollElement {
    element: ContentElement;
    instance: any;
}

/* Used for a performant list scroll controller. Allows thousands of elements to be scrolled in a list
 * without causing major delays in writing the elements to it */
class Scroller {
    elementList: JQuery;
    elementScroller: JQuery;
    elements: ScrollElement[];
    elementHeight: number;
    elementsToDisplay: number;
    startIndex: number;
    endIndex: number;
    trueScrollPosition: number;

    constructor(elementList: JQuery, elementScroller: JQuery, elements: ScrollElement[], elementHeight: number, elementsToDisplay: number = 40) {
        this.elementList = elementList;
        this.elementScroller = elementScroller;
        this.elements = elements;
        this.elementHeight = elementList.children().first().outerHeight();
        this.elementsToDisplay = elementsToDisplay;
        this.startIndex = 0;
        this.endIndex = elementsToDisplay;
        this.displayElements();
    }

    public getElementList(): JQuery {
        return this.elementList
    }
    
    public getElements(): ScrollElement[] {
        return this.elements;
    }

    public getElementHeight(): number {
        return this.elementHeight;
    }

    public getElementsToDisplay(): number { 
        return this.elementsToDisplay;
    }

    public getStartIndex(): number {
        return this.startIndex;
    }

    public getEndIndex(): number {
        return this.endIndex;
    }

    public getTrueScrollPosition(): number {
        return this.trueScrollPosition;
    }

    public setElements(elements: ScrollElement[]): void {
        this.elements = elements;
        this.redraw(this.startIndex, this.endIndex);
    }

    public moveElementToFront(elementInstance: any, elementId: string): void {
        let index = -1;
        for (let i = 0; i < this.elements.length; i++) {
            if (this.elements[i].instance === elementInstance) {
                index = i;
                break;
            }
        }

        if (index > -1) {
            let element = this.elements.splice(index, 1)[0];
            this.elements.unshift(element);
            this.elementList.prepend($(elementId));
        }
    }

    public reset(): void {
        this.startIndex = 0;
        this.endIndex = this.elementsToDisplay;
        this.elementScroller[0].scrollTop = 0;
    }

    public prependElement(element: ScrollElement): void {
        this.elements.unshift(element);
        this.redraw(this.startIndex, this.endIndex);
    }
    
    // Updates the current display of elements in the list element
    private displayElements(): void {
        this.elementList.empty();
        
        let elementsString = "";
        let elem: ScrollElement;
        for (let i = this.startIndex; i <= this.endIndex; i++) {
            elem = this.elements[i];
            if (elem) {
                elementsString += elem.element.getContent();
            }
        }

        this.elementList.append(elementsString);
    }

    // Called when a scroll event is trigger on the list element    
    public onScroll(): void {
        // Find scroll positions
        var scrollPosition: number = this.elementScroller[0].scrollTop;
        var trueScrollPosition: number = this.startIndex*this.elementHeight + scrollPosition;
        var maxScrollPosition: number = this.elementScroller[0].scrollHeight - this.elementScroller[0].offsetHeight;

        // Set new true scroll position
        this.trueScrollPosition = trueScrollPosition;

        // Calculate start/end indexes for idsplay
        var start = Math.floor((trueScrollPosition/this.elementHeight)-(this.elementsToDisplay/2));
        var end = Math.floor((trueScrollPosition/this.elementHeight)+(this.elementsToDisplay/2));
        
        // Check whether an update to the display is necessary (close to boundaries)
        if (this.startIndex > 0 && start < this.startIndex && scrollPosition < this.elementHeight) {
            this.redraw(start, end);
        } else if (this.endIndex+1 < this.elements.length && scrollPosition > maxScrollPosition-this.elementHeight) {
            this.redraw(start, end);
        }
    }
    
    // Updates the display of elements and corrects the scroll position
    private redraw(start: number, end: number): void {
        if (!this.elementHeight) {
            this.elementHeight = this.elementList.children().first().outerHeight();
        }

        var oldStart = this.startIndex;
        var oldEnd = this.endIndex;
        
        // Ensure start is no lower than the lowest
        if (start < 0) {
            start = 0;
            end = start+this.elementsToDisplay;
        }
    
        this.startIndex = start;
        this.endIndex = end;
        this.displayElements();
        this.elementScroller[0].scrollTop = this.getTrueScrollPosition()-((this.startIndex)*this.elementHeight);
    }
}

export default Scroller;