import * as $ from "jquery";
import Discussion from "phaseclient/discussion";
import { DiscussionHash } from "phaseclient/hash";
import ElementIdentifiers from "phaseweb/elementidentifiers";
import Templates from "phaseweb/templates";

interface ContentElement {
    getContent(): string;
}

export interface ScrollElement {
    element: ContentElement;
    instance: any;
}

/* Used for a performant list scroll controller. Allows thousands of elements to be scrolled in a list
 * without causing major delays in writing the elements to it */
class Scroller {
    private elementList: JQuery;
    private elementScroller: JQuery;
    private elements: ScrollElement[];
    private elementHeight: number;
    private elementsToDisplay: number;
    private startIndex: number;
    private endIndex: number;
    private trueScrollPosition: number;

    constructor(elementList: JQuery, elementScroller: JQuery, elements: ScrollElement[], elementHeight: number, elementsToDisplay: number = 40) {
        this.elementList = elementList;
        this.elementScroller = elementScroller;
        this.elements = elements;
        this.elementHeight = elementList.children().first().outerHeight();
        this.elementsToDisplay = elementsToDisplay;
        this.startIndex = 0;
        this.endIndex = elementsToDisplay;
        this.displayElements();
    }

    public getElementList(): JQuery {
        return this.elementList;
    }

    public getElements(): ScrollElement[] {
        return this.elements;
    }

    public getElementHeight(): number {
        return this.elementHeight;
    }

    public getElementsToDisplay(): number {
        return this.elementsToDisplay;
    }

    public getStartIndex(): number {
        return this.startIndex;
    }

    public getEndIndex(): number {
        return this.endIndex;
    }

    public getTrueScrollPosition(): number {
        return this.trueScrollPosition;
    }

    public setElements(elements: ScrollElement[]): void {
        this.elements = elements;
        this._redraw(this.startIndex, this.endIndex);
    }

    public setScrollTop(scrollTop: number): void {
        this.elementScroller[0].scrollTop = scrollTop;
    }

    public moveElementToFront(elementInstance: any, elementId: string): void {
        let index = -1;
        for (let i = 0; i < this.elements.length; i++) {
            if (this.elements[i].instance === elementInstance) {
                index = i;
                break;
            }
        }

        if (index > -1) {
            const element = this.elements.splice(index, 1)[0];
            this.elements.unshift(element);

            // Element is in view then it can be moved
            if (this.startIndex <= index && this.endIndex >= index) {
                this.elementList.prepend($(elementId));
            } else {
                // Element is not in the viewable list, so it must be redrawn
                this._redraw(this.startIndex, this.endIndex);
            }
        }
    }

    public reset(): void {
        this.startIndex = 0;
        this.endIndex = this.elementsToDisplay;
        this.elementScroller[0].scrollTop = 0;
    }

    public prependElement(element: ScrollElement): void {
        this.elements.unshift(element);
        this._redraw(this.startIndex, this.endIndex);
    }

    // Updates the current display of elements in the list element
    private displayElements(): void {
        this.elementList.empty();

        let elementsString = "";
        let elem: ScrollElement;
        for (let i = this.startIndex; i <= this.endIndex; i++) {
            elem = this.elements[i];
            if (elem) {
                elementsString += elem.element.getContent();
            }
        }

        this.elementList.append(elementsString);
    }

    // Called when a scroll event is trigger on the list element
    public onScroll(): void {
        // Find scroll positions
        const scrollPosition: number = this.elementScroller[0].scrollTop;
        const trueScrollPosition: number = this.startIndex * this.elementHeight + scrollPosition;
        const maxScrollPosition: number = this.elementScroller[0].scrollHeight - this.elementScroller[0].offsetHeight;

        // Set new true scroll position
        this.trueScrollPosition = trueScrollPosition;

        // Calculate start/end indexes for idsplay
        const start = Math.floor((trueScrollPosition / this.elementHeight) - (this.elementsToDisplay / 2));
        const end = Math.floor((trueScrollPosition / this.elementHeight) + (this.elementsToDisplay / 2));

        // Check whether an update to the display is necessary (close to boundaries)
        if (this.startIndex > 0 && start < this.startIndex && scrollPosition < this.elementHeight) {
            this._redraw(start, end);
        } else if (this.endIndex + 1 < this.elements.length && scrollPosition > maxScrollPosition - this.elementHeight) {
            this._redraw(start, end);
        }
    }

    /**
     * Re-inserts the elements and sets the scroll of the scroll area
     */
    public redraw(): void {
        this._redraw(this.startIndex, this.endIndex);
    }

    /**
     * Updates the display of elements and corrects the scroll position
     */
    private _redraw(start: number, end: number): void {
        if (!this.elementHeight) {
            this.elementHeight = this.elementList.children().first().outerHeight();
        }

        const oldStart = this.startIndex;
        const oldEnd = this.endIndex;

        // Ensure start is no lower than the lowest
        if (start < 0) {
            start = 0;
            end = start + this.elementsToDisplay;
        }

        this.startIndex = start;
        this.endIndex = end;
        this.displayElements();
        this.elementScroller[0].scrollTop = this.getTrueScrollPosition() - ((this.startIndex) * this.elementHeight);
    }
}

export default Scroller;
