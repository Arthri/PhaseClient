import * as SocketCluster from 'socketcluster-client';
import Client from 'phase/client';
import Socket from 'phase/network/socket';
import Channel from 'phase/network/channel';
import RawMessage from 'phase/network/rawmessage';
import SetInformation from 'phase/messagetypes/setinformation';
import {Discussions, Discussion as ReceivedDiscussion} from 'phase/messagetypes/discussions';
import DiscussionUsers from 'phase/messagetypes/discussionusers';
import { DiscussionMessages, DiscussionMessage } from 'phase/messagetypes/discussionmessages';
import ChatMessage from 'phase/messagetypes/chatmessage';
import EditQueue from 'phase/messagetypes/editqueue';
import UsersOnline from 'phase/messagetypes/usersonline';
import UserOnline from 'phase/messagetypes/useronline';
import UserOffline from 'phase/messagetypes/useroffline';
import Discussion from 'phase/discussion';
import Message from 'phase/message';
import User from 'phase/user';
import { UserHash, BooleanHash } from 'phase/hash';
import ChatEditQueue from 'phase/editqueue';
import System from 'phase/system';
import UserStatus from 'phase/userstatus';

class Network {
    private socket: Socket;
    private client: Client;
    private userChannel: Channel;
    private systemChannel: Channel;
    private globalChannel: Channel;

    // Used to identify which message was rejected
    private chatSequenceId: number;

    constructor(client: Client, options: Object) {
        this.client = client;
        this.socket = SocketCluster.connect(options);
        this.socket.on('connect', () => {
            
        });
        this.socket.on('error', (error) => {
            this.onError(error);
        });

        // Server Messages
        this.socket.on('set information', (info) => {
            this.handleSetInformation(info);
        });

        this.socket.on('discussions list', (discussions) => {
            this.handleDiscussionsList(JSON.parse(discussions));
        });

        this.socket.on('discussion users', (discussionUsers) => {
            this.handleDiscussionUsers(discussionUsers);
        })

        this.socket.on('discussion messages', (discussionMessages) => {
            this.handleDiscussionMessages(discussionMessages);
        });

        this.socket.on('users online', (usersOnline) => {
            this.handleUsersOnline(JSON.parse(usersOnline));
        });
    }

    private onError(error: string): void {
        console.log(`Error with connection ${error}`);
    }

    public sendInformationRequest(session: string): void {
        this.socket.emit('session', session);
    }

    private handleMessage(data: RawMessage | any): void {
        if (data.socketID && data.socketID == this.socket.id)
            return;

        switch (data.msgType) {
            /*// A list of usernames pertaining to an add-discussion-user input field (auto-complete)
            case 'search_results:names':
                handleSearchResults_names(JSON.parse(data));
                break;

            // A list of messages pertaining to a search request
            case 'search results':
                handleSearchResults(JSON.parse(data));
                break;
            */
            // An addition to a discussions list of messages
            case 'chat message':
                this.handleChatMessage(data);
                break;

            /*// A removal of a client-added message
            case 'chat message revoked':
                chatMessageRevoked(data);
                break;*/

             // A queue of changes to an exising in-progress message
            case 'chat edit queue':
                this.handleChatEditQueue(data);
                break;

            // An addition to the Phase Users online list
            case "user online":
                this.handleUserOnline(data);
                break;
            
            // A removal from the Phase Users online list
            case "user offline":
                this.handleUserOffline(data);
                break;

            /*// A response to a new discussion request
            case "new discussion:response":
                newDiscussionResponse(data);
                break;


            // An addition of a discussions listing on the client
            case "new discussion":
                newDiscussion(data);
                break;

            // A removal of a discussions listing on the client
            case "remove discussion":
                removeDiscussion(data);
                break;

            // An addition of a user to the list of users in
            // a discussion
            case "discussion user add":
                discussionUserAdd(data);
                break;

            // A removal of a user from the list of users
            // in a discussion
            case "discussion user remove":
                discussionUserRemove(data);
                break;

            // An addition of mod status to a user in
            // a discussion
            case "discussion user mod":
                discussionUserMod(data);
                break;

            // A removal of mod status from a user in
            // a discussion
            case "discussion user demote":
                discussionUserDemote(data);
                break;

            // A rename to a discussion
            case "discussion rename":
                renameDiscussion(data);
                break;

            // An addition of an item in the
            // Terraria Users List
            case "terraria join":
                terrariaJoin(data);
                break;

            // A removal of an item in the 
            // Terraria Users list
            case "terraria leave":
                terrariaLeave(data);
                break;

            // A name change to a item in the
            // Terraria Users list
            case "terraria changename":
                terrariaChangename(data);
                break;

            // A user avatar update
            case "user avatar":
                userAvatar(data);
                break;

            // User has been requested to join
            // a call
            case "call join request":
                callJoinRequest(data);
                break;

            // Response to accept/denying call
            case "call join response":
                callJoinResponse(data);
                break;

            // User joined call group
            case "call group user add":
                callGroupUserAdd(data);
                break;

            // User left call group
            case "call group user remove":
                callGroupUserRemove(data);
                break;*/
        }
    }

    /* Message Handlers */

    private handleSetInformation(info: SetInformation) {
        this.client.setId(info.userID);
        this.client.setUsername(info.name);
        this.client.setSystemName(info.systemName);
        this.client.setAvatar(info.avatar);

        // Setup channels for listening now that we have auth'ed with Server
        this.userChannel = this.socket.subscribe(info.userID);
        this.userChannel.watch((data) => {
            this.handleMessage(data); 
        });

        this.systemChannel = this.socket.subscribe(`System:${info.systemName}`);
        this.systemChannel.watch((data) => {
            this.handleMessage(data);
        });

        this.globalChannel = this.socket.subscribe(`global`);
        this.globalChannel.watch((data) => {
            this.handleMessage(data);
        });
    }

    private handleDiscussionsList(discussions: Discussions): void {
        let discussion: ReceivedDiscussion;
        let message: Message;
        for (let i = discussions.length-1; i >= 0; i--) {
            discussion = discussions[i];
            message = new Message(0, "", discussion.Username || "", discussion.GuestName || "", discussion.Message || "[No Content]", discussion.timestamp, this.client.getSystemName(), "", "");
            this.client.addDiscussion(new Discussion(discussion.ID, discussion.Name, discussion.Creator, [], message));
        }
    }

    private handleDiscussionUsers(discussionUsers: DiscussionUsers): void {
        let discussionID = discussionUsers.discID;
        let users = discussionUsers.users[1];
        let userList: Array<User> = [];
        let modList: BooleanHash = {};
        
        let user: User;
        for (let i = 0; i < users.length; i++) {
            if (this.client.getPhaseUsers()[users[i].userID]) {
                user = this.client.getPhaseUsers()[users[i].userID];
            } else {
                user = new User(users[i].userID, users[i].name, users[i].systemName, users[i].avatar, this.client.getSystemName(), UserStatus.Offline);
                this.client.addPhaseUser(user);
            }
            
            userList.push(user);

            if (users[i].mod) {
                modList[user.getId()] = true;
            }
        }

        let discussion = this.client.getDiscussions()[discussionID];
        this.client.handleDiscussionUsers(discussion, userList, modList);
    }

    private handleDiscussionMessages(discussionMessages: DiscussionMessages): void {
        let discussionID = discussionMessages.discID;
        let messages: DiscussionMessage[] = JSON.parse(discussionMessages.messages);
        let oldestId = discussionMessages.oldestID;
        let messageList: Array<Message> = [];
        let discussion = this.client.getDiscussions()[discussionID];

        if (!discussion)
            return;

        let user: User | null = null;
        let username: string;
        let guestname: string;
        for (let i = 0; i < messages.length; i++) {
            if (this.client.getPhaseUsers()[messages[i].userID]) {
                user = this.client.getPhaseUsers()[messages[i].userID];
            } else {
                if (!messages[i].guest) {
                    user = new User(messages[i].userID, messages[i].username, messages[i].systemName, messages[i].avatar, this.client.getSystemName(), UserStatus.Offline);
                    this.client.addPhaseUser(user);
                }
            }

            // Server doesn't send message ID so for now it has to be set to a default
            if (messages[i].guest) {
                username = "";
                guestname = messages[i].username;
            } else {
                username = messages[i].username;
                guestname = "";
            }

            if (this.client.getConfiguration().useAndDisplayJoinLeaveMessages || messages[i].userID !== System.joinLeaveMessageUserId || messages[i].tag == null) {
                messageList.push(new Message(messages[i].userID, messages[i].avatar, username, guestname, messages[i].content, messages[i].timestamp, messages[i].systemName, messages[i].tag || "", messages[i].tagcolour || ""));
            }
            user = null;
        }

        discussion.setMessages(messageList);
        this.client.handleDiscussionMessagesReceived(discussion);
    }

    private handleChatMessage(message: ChatMessage): void {
        let discussionId = message.discID;
        let user: User | null = null;
        let username: string;
        let guestname: string;
        let discussion = this.client.getDiscussions()[discussionId];

        if (!discussion)
            return;

        if (this.client.getPhaseUsers()[message.userID]) {
            user = this.client.getPhaseUsers()[message.userID];
        } else {
            if (!message.guest) {
                user = new User(message.userID, message.username, message.systemName, message.avatar, this.client.getSystemName(), UserStatus.Offline);
                this.client.addPhaseUser(user);
            }
        }

        // Server doesn't send message ID so for now it has to be set to a default
        if (message.guest) {
            username = "";
            guestname = message.username;
        } else {
            username = message.username;
            guestname = "";
        }

        let chatMessage = new Message(message.userID, message.avatar, username, guestname, message.msg, message.timestamp, message.systemName, message.tag || "", message.tagcolour || "");
        this.client.handleChatMessage(discussion, chatMessage);
    }

    private handleChatEditQueue(editQueue: EditQueue): void {
        let discussionId = editQueue.discID;
        let edits = editQueue.queue;
        let userId = editQueue.userID;
        let username = editQueue.username;
        let systemName = editQueue.systemName;
        let discussion = this.client.getDiscussions()[discussionId];

        if (!discussion) {
            return;
        }

        let messageContent = "";
        let chatUser: User = this.client.getPhaseUser(userId);
        let storedLiveTyping = discussion.getLiveTypingMessage(userId);
        
        // If existing content stored, used that
        if (typeof storedLiveTyping !== 'undefined') {
            messageContent = storedLiveTyping.getContent().asIs();
        }

        // Apply edits
        for (var i = 0; i < edits.length; i++) {
            let item = edits[i];
            if (item.t) {
                messageContent = messageContent.slice(0, item.pos) + item.text + messageContent.slice(item.pos);
            } else {
                messageContent = messageContent.slice(0, item.pos) + messageContent.slice(item.pos + item.len);
            }
        }

        // Create a new message if none stored, or update existing
        if (typeof storedLiveTyping === 'undefined') {
            if (messageContent.trim().length > 0) {
                discussion.setLiveTypingMessages(userId, new Message(userId, chatUser.getAvatar(), chatUser.getName(), "", messageContent, Date.now()/1000, systemName, "", ""));
                
                if (discussion.getIsBeingViewed()) {
                    this.client.handleNewLiveTyping(discussion.getLiveTypingMessages()[userId]);
                }
            }
        } else {
            if (messageContent.trim().length > 0) {
                discussion.updateLiveTypingMessageContent(userId, messageContent);
                
                if (discussion.getIsBeingViewed()) {
                    this.client.handleUpdateLiveTyping(discussion.getLiveTypingMessages()[userId]);
                }
            } else {
                discussion.removeLiveTypingMessage(userId);
                
                if (discussion.getIsBeingViewed()) {
                    this.client.handleRemoveLiveTyping(userId);
                }
            }
        }
    }
  
    /**
     * Handles when a user comes online
     * 
     * @param userOnline The user who has come online
     */
    private handleUserOnline(userOnline: UserOnline): void {
        let phaseUser = this.client.getPhaseUser(userOnline.userID);
        if (!phaseUser) {
            phaseUser = new User(userOnline.userID, userOnline.name, userOnline.systemName, userOnline.avatar, this.client.getSystemName(), UserStatus.Online);
        } else if(phaseUser.getAvatar().length === 0) {
            phaseUser.setAvatar(userOnline.avatar);
        }

        this.client.handleUserOnline(phaseUser);
    }

    /**
     * Handles when a user goes offline
     * 
     * @param userOffline The user who has gone offline
     */
    private handleUserOffline(userOffline: UserOffline): void {
        let phaseUser = this.client.getPhaseUser(userOffline.userID);
        if (!phaseUser) {
            phaseUser = new User(userOffline.userID, userOffline.name, userOffline.systemName, "", this.client.getSystemName(), UserStatus.Online);
        }

        this.client.handleUserOffline(phaseUser);
    }
    
    /* Puts the users online into the display list and adds them to the client list */
    private handleUsersOnline(usersOnline: UsersOnline): void {
        let users: User[] = [];
        let phaseUsers = this.client.getPhaseUsers();
        for (let i = 0; i < usersOnline.length; i++) {
            let user = usersOnline[i];
            users.push(new User(user.UserID, user.name, user.systemName, user.Avatar, this.client.getSystemName(), UserStatus.Online));
        }

        this.client.handleUsersOnline(users);
    }

    /* Message Requests */

    public requestDiscussionDetails(discussionId: number): void {
        this.socket.emit('discussion users', `${discussionId}`);
        this.socket.emit('discussion messages', `${discussionId}`);
    }

    public sendChatMessage(discussionId: number, text: string): number {
        this.socket.emit('chat message', {
            ID: this.chatSequenceId,
            discID: discussionId,
            msg: text
        });

        return this.chatSequenceId++;
    }

    public sendEditQueue(discussionId: number, editQueue: ChatEditQueue): void {
        this.socket.emit('chat edit queue', {
            queue: editQueue,
            discID: discussionId
        });
    }
}

export default Network;