import Network from 'phase/network';
import User from 'phase/user';
import Discussion from 'phase/discussion';
import { DiscussionHash, UserHash, BooleanHash } from 'phase/hash';
import Message from 'phase/message';
import Cookie from 'phase/cookie';
import EditQueue from 'phase/editqueue';
import Config from 'phase/config';
import System from 'phase/system';
import UserStatus from 'phase/userstatus';

/**
 * The barebones client. It can be used to connect to the Phase server and has methods for interacting
 * but does not actually do anything useful on its own.
 */
class Client {
    protected id: number;
    protected username: string;
    protected systemName: string;
    protected onlineUsers: Array<User>;
    protected avatar: string;
    protected network: Network;
    protected discussions: DiscussionHash;
    protected phaseUsers: UserHash;
    protected currentDiscussion: Discussion | undefined;
    protected configuration: Config;
    protected session: string;

    constructor(configuration: Config) {
        this.discussions = {};
        this.onlineUsers = [];
        this.phaseUsers = {};
        this.configuration = configuration;
        this.session = "";
    }

    public setupNetwork(network: Network): void {
        if (!this.network) {
            this.network = network;
        }
    }

    public setId(id: number): void {
        this.id = id;
    }

    public getId(): number {
        return this.id;
    }

    public setUsername(username: string): void {
        this.username = username;
    }

    public getUsername(): string {
        return this.username;
    }

    public setSystemName(systemName: string): void {
        this.systemName = systemName;
    }

    public getSystemName(): string {
        return this.systemName;
    }

    public getOnlineUsers(): Array<User> {
        return this.onlineUsers;
    }

    public getAvatar(): string {
        return this.avatar;
    }
    
    public getDiscussions(): DiscussionHash {
        return this.discussions;
    }

    public getCurrentDiscussion(): Discussion | undefined {
        return this.currentDiscussion;
    }

    public getPhaseUsers(): UserHash {
        return this.phaseUsers;
    }

    public getPhaseUser(userId: number): User {
        return this.getPhaseUsers()[userId.toString()];
    }

    public getConfiguration(): Config {
        return this.configuration;
    }

    public getSession(): string {
        return this.session;
    }

    /* Updates the users avatar in the chat input area */
    public setAvatar(avatar: string): void {
        this.avatar = avatar;
    }

    /* Adds a phase users information to the clients phase users object */
    public addPhaseUser(user: User): void {
        this.getPhaseUsers()[user.getId()] = user;
    }

    /* Appends a discussion to the clients list of discussions and updates page */
    public addDiscussion(discussion: Discussion): void {
        this.discussions[discussion.getId()] = discussion;
    }

    /**
     * Switches current discussion
     * @param discussionId The id of the discussion to switch to
     */
    public switchDiscussion(discussionId: number): void {
        let discussion = this.getDiscussions()[discussionId];

        if (!discussion)
            return;

        if (discussion.getMembers().length === 0) {
            this.network.requestDiscussionDetails(discussionId);
        }

        if (this.currentDiscussion) {
            this.currentDiscussion.setIsBeingViewed(false);
        }

        discussion.setIsBeingViewed(true);
        this.currentDiscussion = discussion;
    }

    public clearDiscussions(): void {
        this.discussions = {};
    }

    /**
     * Sends a queue of edits to the server
     * 
     * @param editQueue The queue of edits to send
     */
    public sendEditQueue(editQueue: EditQueue): void {
        if (this.currentDiscussion == null) {
            return;
        }

        this.network.sendEditQueue(this.currentDiscussion.getId(), editQueue);
    }

    /* When a chat message is to be displayed it will go through this function.
     * It must be decided whether the message is allowed to be displayed according
     * to the configuration. */
    public handleChatMessage(discussion: Discussion, message: Message): void {
        if (!this.getConfiguration().useAndDisplayJoinLeaveMessages && message.getUserId() == System.joinLeaveMessageUserId && message.getTag().length > 0) {
            return;
        }

        discussion.appendMessage(message);
        discussion.removeLiveTypingMessage(message.getUserId());

        discussion.setRecentMessage(message);
    }

    /* When the user sends a chat message, it is sent to the server, and a new one put into and is displayed
     * in the discussion list */
    public sendChatMessage(text: string): void {
        if (this.currentDiscussion == null) {
            return;
        }

        let chatMessageId = this.network.sendChatMessage(this.currentDiscussion.getId(), text);
        let message = new Message(this.getId(), this.getAvatar(), this.getUsername(), "", text, Math.round(Date.now()/1000), this.getSystemName(), "", "");
        this.handleChatMessage(this.currentDiscussion, message);
    }

    /* Use the session to get client information (userId, username etc) necessary */
    public sendInformationRequest(session: string): void {
        Cookie.setCookie('_phasesession', session, 3);
        if (session) {
            this.session = session;
            this.network.sendInformationRequest(session);
        }
    }

    /**
     * Handles when the discussion messages requested were received or when the local messages were already there and need loading
     * 
     * @param discussion The discussion that the messages received are in or the discussion with the local messages already
     */
    public completeDiscussionSwitch(discussion: Discussion): void {}

    /**
     * Handles when a user comes online
     * 
     * @param user The user who has come online
     */
    public handleUserOnline(user: User): void {
        if (this.onlineUsers.indexOf(user) === -1) {
            this.onlineUsers.push(user);
        }
        user.setStatus(UserStatus.Online);
    }

    /**
     * Handles when a user goes offline
     * 
     * @param user The user who has gone offline
     */
    public handleUserOffline(user: User): void {
        let index = this.onlineUsers.indexOf(user);
        if (index > -1) {
            this.onlineUsers.splice(index, 1);
        }

        user.setStatus(UserStatus.Offline);
    }

    /**
     * Handles when the list of users online are received
     * 
     * @param userList The users who are online
     */
    public handleUsersOnline(userList: User[]): void {
        this.onlineUsers = [];
        let phaseUsers = this.getPhaseUsers();
        for (let i = 0; i < userList.length; i++) {
            let user = userList[i];
            if (!phaseUsers[user.getId()]) {
                this.addPhaseUser(user);
            }
            this.onlineUsers.push(user);
        }
    }

    /**
     * Handles when the discussion users list has been received
     * 
     * @param discussion The discussion that the users are from
     * @param userList The list of users in the discussion
     * @param modList The moderators of that discussion
     */
     public handleDiscussionUsers(discussion: Discussion, userList: User[], modList: BooleanHash): void {
         discussion.setMembers(userList);
         discussion.setModerators(modList);
     }

    /**
     * Handles when a new live typing message is received
     * 
     * @param message The live typing message
     */
    public handleNewLiveTyping(message: Message): void {}

    /**
     * Handles when an update to an existing live typing message is received
     * 
     * @param message The live typing message
     */
    public handleUpdateLiveTyping(message: Message): void {}

    /**
     * Handles when a removal of an existing live typing message is received
     * 
     * @param userId The user id of the live typing message to remove
     */
    public handleRemoveLiveTyping(userId: number): void {}
}

export default Client;