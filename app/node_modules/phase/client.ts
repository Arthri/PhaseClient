import Network from 'phase/network';
import User from 'phase/user';
import Discussion from 'phase/discussion';
import { DiscussionHash, UserHash } from 'phase/hash';
import Message from 'phase/message';
import Cookie from 'phase/cookie';
import EditQueue from 'phase/editqueue';
import Config from 'phase/config';
import System from 'phase/system';

/**
 * The barebones client. It can be used to connect to the Phase server and has methods for interacting
 * but does not actually do anything useful on its own.
 */
class Client {
    protected id: number;
    protected username: string;
    protected systemName: string;
    protected onlineUsers: Array<User>;
    protected avatar: string;
    protected network: Network;
    protected discussions: DiscussionHash;
    protected phaseUsers: UserHash;
    protected currentDiscussion: Discussion | undefined;
    protected configuration: Config;

    constructor(configuration: Config) {
        this.discussions = {};
        this.onlineUsers = [];
        this.phaseUsers = {};
        this.configuration = configuration;
    }

    public setupNetwork(network: Network): void {
        if (!this.network) {
            this.network = network;
        }
    }

    public setId(id: number): void {
        this.id = id;
    }

    public getId(): number {
        return this.id;
    }

    public setUsername(username: string): void {
        this.username = username;
    }

    public getUsername(): string {
        return this.username;
    }

    public setSystemName(systemName: string): void {
        this.systemName = systemName;
    }

    public getSystemName(): string {
        return this.systemName;
    }

    public getOnlineUsers(): Array<User> {
        return this.onlineUsers;
    }

    public getAvatar(): string {
        return this.avatar;
    }
    
    public getDiscussions(): DiscussionHash {
        return this.discussions;
    }

    public getPhaseUsers(): UserHash {
        return this.phaseUsers;
    }

    public getPhaseUser(userId: number): User {
        return this.getPhaseUsers()[userId.toString()];
    }

    public getConfiguration(): Config {
        return this.configuration;
    }

    /* Updates the users avatar in the chat input area */
    public setAvatar(avatar: string): void {
        this.avatar = avatar;
    }

    /* Adds a phase users information to the clients phase users object */
    public addPhaseUser(user: User): void {
        this.getPhaseUsers()[user.getId().toString()] = user;
    }

    /* Appends a discussion to the clients list of discussions and updates page */
    public addDiscussion(discussion: Discussion): void {
        this.discussions[discussion.getId().toString()] = discussion;
    }

    public switchDiscussion(discussionId: number): void;
    /**
     * Switches current discussion
     * @param discussionId The id of the discussion to switch to
     */
    public switchDiscussion(discussionId: number): void {
        let discussion = this.getDiscussions()[discussionId];

        if (!discussion)
            return;

        if (discussion.getMembers().length === 0) {
            this.network.requestDiscussionDetails(discussionId);
        }

        if (this.currentDiscussion) {
            this.currentDiscussion.setIsBeingViewed(false);
        }

        discussion.setIsBeingViewed(true);
        this.currentDiscussion = discussion;
    }

    public sendEditQueue(editQueue: EditQueue): void {
        if (this.currentDiscussion == null) {
            return;
        }

        this.network.sendEditQueue(this.currentDiscussion.getId(), editQueue);
    }

    /* When a chat message is to be displayed it will go through this function.
     * It must be decided whether the message is allowed to be displayed according
     * to the configuration. */
    public handleChatMessage(discussion: Discussion, message: Message): void {
        if (!this.getConfiguration().useAndDisplayJoinLeaveMessages && message.getUserId() == System.joinLeaveMessageUserId && message.getTag().length > 0) {
            return;
        }

        discussion.appendMessage(message);
        discussion.removeLiveTypingMessage(message.getUserId());

        discussion.setRecentMessage(message);
    }

    /* When the user sends a chat message, it is sent to the server, and a new one put into and is displayed
     * in the discussion list */
    public sendChatMessage(text: string): void {
        if (this.currentDiscussion == null) {
            return;
        }

        let chatMessageId = this.network.sendChatMessage(this.currentDiscussion.getId(), text);
        let message = new Message(this.getId(), this.getAvatar(), this.getUsername(), "", text, Math.round(Date.now()/1000), this.getSystemName(), "", "");
        this.handleChatMessage(this.currentDiscussion, message);
    }

    /* Use the session to get client information (userId, username etc) necessary */
    public sendInformationRequest(session: string): void {
        Cookie.setCookie('_phasesession', session, 3);
        console.log("cookie: "+session);
        if (session) {
            this.network.sendInformationRequest(session);
        }
    }

    /**
     * Handles when the discussion messages requested were received
     * 
     * @param discussion The discussion that the messages received are in
     */
    public handleDiscussionMessagesReceived(discussion: Discussion): void {}

    /**
     * Handles when a new live typing message is received
     * 
     * @param message The live typing message
     */
    public handleNewLiveTyping(message: Message): void {}

    /**
     * Handles when an update to an existing live typing message is received
     * 
     * @param message The live typing message
     */
    public handleUpdateLiveTyping(message: Message): void {}

    /**
     * Handles when a removal of an existing live typing message is received
     * 
     * @param userId The user id of the live typing message to remove
     */
    public handleRemoveLiveTyping(userId: number): void {}
}

export default Client;