import Network from 'phase/network';
import User from 'phase/user';
import ElementIdentifiers from 'phase/elementidentifiers';
import PageModel from 'phase/pagemodel';
import Discussion from 'phase/discussion';
import { DiscussionHash, UserHash } from 'phase/hash';
import Message from 'phase/message';
import Cookie from 'phase/cookie';
import EditQueue from 'phase/editqueue';
import Config from 'phase/config';
import System from 'phase/system';

class Client {
    protected id: number;
    protected username: string;
    protected systemName: string;
    protected onlineUsers: Array<User>;
    protected avatar: string;
    protected network: Network;
    protected pageModel: PageModel;
    protected discussions: DiscussionHash;
    protected phaseUsers: UserHash;
    protected currentDiscussion: Discussion | undefined;
    protected configuration: Config;

    constructor(configuration: Config) {
        this.discussions = {};
        this.onlineUsers = [];
        this.phaseUsers = {};
        this.configuration = configuration;
    }

    public setup(network: Network, pageModel: PageModel): void {
        if (!this.network) {
            this.network = network;
        }

        if (!this.pageModel) {
            this.pageModel = pageModel;
            this.pageModel.checkSession();
        }
    }

    public setId(id: number): void {
        this.id = id;
    }

    public getId(): number {
        return this.id;
    }

    public setUsername(username: string): void {
        this.username = username;
        this.pageModel.updateUsername(username);
    }

    public getUsername(): string {
        return this.username;
    }

    public setSystemName(systemName: string): void {
        this.systemName = systemName;
    }

    public getSystemName(): string {
        return this.systemName;
    }

    public getOnlineUsers(): Array<User> {
        return this.onlineUsers;
    }

    public getAvatar(): string {
        return this.avatar;
    }

    public getPageModel(): PageModel {
        return this.pageModel;
    }
    
    public getDiscussions(): DiscussionHash {
        return this.discussions;
    }

    public getPhaseUsers(): UserHash {
        return this.phaseUsers;
    }

    public getPhaseUser(userId: number): User {
        return this.getPhaseUsers()[userId.toString()];
    }

    public getConfiguration(): Config {
        return this.configuration;
    }

    /* Updates the users avatar in the chat input area */
    public setAvatar(avatar: string): void {
        this.avatar = avatar;
        this.pageModel.updateAvatar(avatar);
        this.pageModel.refreshUsersOnlineList();
    }

    /* Adds a phase users information to the clients phase users object */
    public addPhaseUser(user: User): void {
        this.getPhaseUsers()[user.getId().toString()] = user;
    }

    /* Appends a discussion to the clients list of discussions and updates page */
    public addDiscussion(discussion: Discussion): void {
        this.discussions[discussion.getId().toString()] = discussion;
        this.pageModel.prependDiscussionsList(discussion);
    }

    /* Switches current discussion
       @param discussionId
            The id of the discussion to switch to
       @param eventElem
            The $(element) that was clicked to cause this event
     */
    public switchDiscussion(discussionId: number, eventElem: any): void {
        let discussion = this.getDiscussions()[discussionId];

        if (!discussion)
            return;

        if (discussion.getMembers().length === 0) {
            this.network.requestDiscussionDetails(discussionId);
        } else {
            this.getPageModel().clearMessages();
            this.getPageModel().displayMessages(discussion);
        }

        if (this.currentDiscussion) {
            this.currentDiscussion.setIsBeingViewed(false);
        }

        discussion.setIsBeingViewed(true);
        this.currentDiscussion = discussion;
        this.getPageModel().switchSelectedDiscussion(eventElem);
        this.getPageModel().setDiscussionRead(discussion);
        this.getPageModel().updateDisplayedTitle(discussion.getName());
    }

    public sendEditQueue(editQueue: EditQueue): void {
        if (this.currentDiscussion == null) {
            return;
        }

        this.network.sendEditQueue(this.currentDiscussion.getId(), editQueue);
    }

    /* When a chat message is to be displayed it will go through this function.
     * It must be decided whether the message is allowed to be displayed according
     * to the configuration. */
    public handleChatMessage(discussion: Discussion, message: Message): void {
        if (!this.getConfiguration().useAndDisplayJoinLeaveMessages && message.getUserId() == System.joinLeaveMessageUserId && message.getTag().length > 0) {
            return;
        }

        discussion.appendMessage(message);
        discussion.removeLiveTypingMessage(message.getUserId());

        if (discussion.getIsBeingViewed()) {
            let lastMessage: Message | null = discussion.getMessages().length > 1 ? discussion.getMessages()[discussion.getMessages().length-2] : null;
            this.getPageModel().appendMessage(lastMessage, message);
            this.getPageModel().removeLiveTyping(message.getUserId());
        } else {
            this.getPageModel().setDiscussionUnread(discussion);

            // Doesn't work for mobile
            if (!this.getPageModel().getWindowHasFocus() && message.getContent().withBbcodeStripped().indexOf(this.getUsername()) > -1) {
                this.getPageModel().showNotification(message.getContent().withBbcodeStripped());
            }
        }

        discussion.setRecentMessage(message);
        this.getPageModel().updateDiscussionEntryMessagePreview(discussion);
    }

    /* When the user sends a chat message, it is sent to the server, and a new one put into and is displayed
     * in the discussion list */
    public sendChatMessage(text: string): void {
        if (this.currentDiscussion == null) {
            return;
        }

        let chatMessageId = this.network.sendChatMessage(this.currentDiscussion.getId(), text);
        let message = new Message(this.getId(), this.getAvatar(), this.getUsername(), "", text, Math.round(Date.now()/1000), this.getSystemName(), "", "");
        this.handleChatMessage(this.currentDiscussion, message);
    }

    /* Use the session to get client information (userId, username etc) necessary */
    public sendInformationRequest(session: string): void {
        Cookie.setCookie('_phasesession', session, 3);
        console.log("cookie: "+session);
        if (session) {
            this.network.sendInformationRequest(session);
        }
    }
}

export default Client;