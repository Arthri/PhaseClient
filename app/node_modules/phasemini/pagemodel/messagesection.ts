import $ from "jquery";
import Discussion from "phaseclient/discussion";
import Message from "phaseclient/message";
import TextDifference from "phaseclient/textdifference";
import { EditQueueEntry } from "phasecore/editqueue";
import System from "phasecore/system";
import Client from "phasemini/client";
import ElementIdentifiers from "phaseweb/elementidentifiers";
import Hash from "phaseweb/hash";
import ContextMenu from "phaseweb/pagemodel/messagesection/contextmenu";
import Templates from "phaseweb/templates";
import Translator from "phaseweb/translator";

class MessageSection {
    private _client: Client;
    private lastMessageInput: string;
    private _messageInputHadCommandPrefix: boolean;
    private _contextMenuMessageId: number;
    private _translator: Translator;
    private _contextMenu: ContextMenu;

    constructor(client: Client) {
        this._client = client;
        this._translator = new Translator();
        this.lastMessageInput = "";
        this._messageInputHadCommandPrefix = false;
        this.hideMessageLoading();
        this._contextMenu = new ContextMenu(this._client);
        this._contextMenu.hide();
    }

    public getLastMessageInput(): string {
        return this.lastMessageInput;
    }

    /**
     * Updates the title displayed in the GUI
     *
     * @param name The title of the messages (such as discussion name)
     */
    public updateDisplayedTitle(name: string): void {
        $(ElementIdentifiers.ChatSection.title).text(name);
    }

    /**
     * Clears the messages diplayed in the message list
     */
    public clearMessages(): void {
        $(ElementIdentifiers.ChatSection.list).empty();
        this._contextMenu.hide();
    }

    /**
     * Displays 40 messages in the chat list from the specified discussion
     *
     * @param discussion The discussion to display messages for
     */
    public displayMessages(discussion: Discussion): void {
        const messages = discussion.messages;
        const minIndex = messages.length - 41 < 0 ? 0 : messages.length - 41;
        for (let i = minIndex; i < messages.length; i++) {
            this.appendMessage(i >= 0 ? messages[i - 1] as Message : undefined, messages[i] as Message);
        }

        this.scrollToBottom();
    }

    /**
     * Gets whether a message should be combined with the last message
     *
     * @param message The message
     * @param lastMessage The last message
     */
    private messageShouldBeCombined(message: Message, lastMessage: Message): boolean {
        return lastMessage.userId === message.userId
                    && Math.abs(lastMessage.timestamp - message.timestamp) <= 60
                    && lastMessage.tag === message.tag
                    && ((lastMessage.username.asIs().length > 0 && lastMessage.username.asIs() === message.username.asIs())
                        || (lastMessage.guestName.asIs().length > 0 && lastMessage.guestName.asIs() === message.guestName.asIs()));
    }

    /**
     * Adds a message to the message display at the end (bottom)
     *
     * @param lastMessage The last message displayed
     * @param message The message to add to the message display
     */
    private appendMessage(lastMessage: Message | undefined, message: Message) {
        const discussion = this._client.currentDiscussion;

        // If join/leave message and config setting is not to display these, do not handle the message
        if (!this._client.configuration.useAndDisplayJoinLeaveMessages && message.userId === -2 && message.tag.length !== 0) {
            return;
        } else if (typeof discussion === "undefined") {
            return;
        }

        let addedMessage: JQuery | null = null;

        // If the config has it set that messages are to be combined then checks need to be done
        if (this._client.configuration.combineMessages) {
            // If the first message or is a join/leave message (so it contains ip, origin, that must be kept in-tact etc)
            if (!lastMessage || message.userId === System.joinLeaveMessageUserId) {
                addedMessage = $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this._client, discussion, message));
            } else {
                // Combine messages that were sent by the same user consecutively, under a minute in difference
                if (this.messageShouldBeCombined(message, lastMessage)) {
                    addedMessage = this.combineMessage(message);
                } else {
                    const existingLiveTyping = $(ElementIdentifiers.LiveMessage.identifier(message.userId));
                    if (existingLiveTyping.length) {
                        addedMessage = existingLiveTyping.before(Templates.ChatMessage(this._client, discussion, message));
                    } else {
                        addedMessage = $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this._client, discussion, message));
                    }
                }
            }
        // Otherwise just append the message to the list
        } else {
            addedMessage = $(ElementIdentifiers.ChatSection.list).append(Templates.ChatMessage(this._client, discussion, message));
        }

        if (addedMessage !== null) {
            this.scrollAfterImagesLoad(addedMessage);
        }
    }

    /**
     * Combines a message with the last message in the list
     *
     * @param message The message to get new content from
     */
    private combineMessage(message: Message): JQuery {
        return $(`${ElementIdentifiers.ChatSection.list} li:not('.in-progress'):last`)
            .find(".chat-message-content")
            .append(`<div class="chat-line">${message.getContentStyled(this._client.currentDiscussion as Discussion)}</div>`);
    }

    /**
     * Fixes the scroll position when an image loaded that caused it to change
     *
     * @param element The element with images that are loading
     */
    private scrollAfterImagesLoad(element: any): void {
        const _this = this;
        element.find(".autoLinkedImage").each(function() {
            _this.onImageLoad($(this), (width: number, height: number) => {
                _this.scrollBy(height);
            });
        });
    }

    /**
     * Displays a message in the message list by appending it
     *
     * @param lastMessage The last message displayed
     * @param message The message to add to the message display
     */
    public displayMessage(lastMessage: Message | undefined, message: Message): void {
        if (message.userId === this._client.id) {
            if (message.content.asIs() === $(ElementIdentifiers.ChatInput.textInput).val()) {
                const discussion = this._client.currentDiscussion;
                if (discussion) {
                    $(ElementIdentifiers.ChatInput.main).after(Templates.ChatMessage(this._client, discussion, message));
                }
                return;
            }
        }

        const scrollIsAtBottom = this.getScrollIsAtBottom();
        this.appendMessage(lastMessage, message);

        // Scroll the chat to the bottom if they were at the bottom before
        if (scrollIsAtBottom) {
            // Remove messages that go over max of 40 in display
            this.removeOldestMessages($(ElementIdentifiers.ChatSection.list).children().length - 40);
            this.scrollToBottom();
        }
    }

    /**
     * Remove the oldest n messages from the discussion message list
     */
    public removeOldestMessages(amount: number): void {
        if (amount < 0) {
            amount = 0;
        }
        $(ElementIdentifiers.ChatSection.list).children().slice(0, amount).remove();
    }

    /**
     * Returns the width and height of an image after it loads
     *
     * @param image The image to track for loading
     * @param callback The function to call when the image has loaded
     */
    private onImageLoad(image: any, callback: (width: number, height: number) => void): void {
        let isDone = false;
        const onLoad = () => {
            done(image.width(), image.height());
        };
        image.on("load", onLoad);

        function done(width: number, height: number) {
            if (isDone) {
                return;
            }

            isDone = true;
            image.off("load", onLoad);

            callback(width, height);
        }
    }

    /**
     * Get whether scroll is at bottom
     */
    public getScrollIsAtBottom(): boolean {
        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        const maximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
        const currentScroll = chatElement[0].scrollTop;
        const scrollIsAtBottom = currentScroll === maximumScroll;

        return scrollIsAtBottom;
    }

    /**
     * Scroll the message list by the specified amount
     */
    public scrollBy(amount: number): void {
        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        chatElement[0].scrollTop += amount;
    }

    /**
     * Scroll the message list to the bottom
     */
    public scrollToBottom(): void {
        const chatElement = $(ElementIdentifiers.ChatSection.scrollSection);
        const maximumScroll = chatElement[0].scrollHeight - chatElement[0].offsetHeight;
        chatElement[0].scrollTop = maximumScroll;
    }

    /**
     * Displays live typing messages for the specified discussion
     *
     * @param discussion The discussion to display live typing messages for
     */
    public displayLiveTyping(discussion: Discussion): void {
        const liveTypingMessages = discussion.liveTypingMessages;

        let message: Message;
        for (const key in liveTypingMessages) {
            if (liveTypingMessages.hasOwnProperty(key)) {
                message = liveTypingMessages[key] as Message;
                $(ElementIdentifiers.ChatSection.list).append(Templates.LiveTypingMessage(this._client, discussion, message));
            }
        }

        this.scrollToBottom();
    }

    /**
     * Changes last message and current input field message to the last stored
     *
     * @param discussion The discussion to get our live typing message from
     */
    public updateOurLiveTyping(discussion: Discussion): void {
        const message = discussion.ourLiveTypingMessage;
        this.lastMessageInput = message || "";

        $(ElementIdentifiers.ChatInput.textInput).val(message || "");
    }

    /**
     * Creates a live typing element at the bottom of the message list
     *
     * @param message The message to put in the live typing preview list
     */
    public createLiveTyping(message: Message): void {
        const discussion = this._client.currentDiscussion;

        if (typeof discussion !== "undefined") {
            const scrollWasAtBottom = this.getScrollIsAtBottom();
            $(ElementIdentifiers.ChatSection.list).append(Templates.LiveTypingMessage(this._client, discussion, message));

            // Scroll the chat to the bottom if they were at the bottom before
            if (scrollWasAtBottom) {
                this.scrollToBottom();
            }
        }
    }

    /**
     * Updates the content of an existing live typing element
     */
    public updateLiveTyping(message: Message): void {
        const scrollWasAtBottom = this.getScrollIsAtBottom();
        $(ElementIdentifiers.LiveMessage.identifier(message.userId))
            .find(ElementIdentifiers.LiveMessage.content)
            .html(message.getContentStyled(this._client.currentDiscussion as Discussion));

        // Scroll the chat to the bottom if they were at the bottom before
        if (scrollWasAtBottom) {
            this.scrollToBottom();
        }
    }

    /**
     * Removes an existing live typing element based on userId
     *
     * @param userId The user id of the user to remove live typing preview for
     */
    public removeLiveTyping(userId: number): void {
        $(ElementIdentifiers.LiveMessage.identifier(userId)).remove();
    }

    /**
     * Removes all currently displayed live typing elements
     */
    public clearLiveTyping(): void {
        $(ElementIdentifiers.ChatSection.liveTyping).children().remove();
    }

    /**
     * Updates the displayed status of chat from an in-game user
     */
    public updateTerrariaUserStatus(name: string, online: boolean, tagColor?: string): void {
        if (online && tagColor) {
            $(`.chat-terraria-${Hash(name)}`)
                .removeClass(ElementIdentifiers.Message.terrariaOffline.substr(1))
                .addClass(ElementIdentifiers.Message.terrariaOnline.substr(1))
                .css("background", tagColor);
        } else {
            $(`.chat-terraria-${Hash(name)}`)
                .removeClass(ElementIdentifiers.Message.terrariaOnline.substr(1))
                .addClass(ElementIdentifiers.Message.terrariaOffline.substr(1))
                .css("background", "");
        }
    }

    /**
     * Updates the chat input username color to match their rank
     */
    public updateOurChatColor(): void {
        const currentDiscussion = this._client.currentDiscussion;

        if (currentDiscussion) {
            const isCreator = this._client.id === currentDiscussion.creator;
            const isMod = currentDiscussion.moderators[this._client.id];
            const creatorClass = ElementIdentifiers.Message.creator.substr(1);
            const modClass = ElementIdentifiers.Message.moderator.substr(1);

            const nameElement = $(ElementIdentifiers.ChatInput.main).find(ElementIdentifiers.ChatInput.username);
            if (isCreator) {
                nameElement.addClass(creatorClass).removeClass(modClass);
            } else if (isMod) {
                nameElement.removeClass(creatorClass).addClass(modClass);
            } else {
                nameElement.removeClass(creatorClass).removeClass(modClass);
            }
        }
    }

    /**
     * Updates the displayed username in the chat input section
     *
     * @param name The name to display ours as
     */
    public updateOurDisplayedName(name: string): void {
        $(ElementIdentifiers.ChatInput.main).find(ElementIdentifiers.ChatInput.username).text(name);
    }

    /**
     * Changes the thumbnail image of a video into the youtube video player
     */
    private displayYoutubeVideo(elem: any): void {
      const videoID = elem.attr("data-id");
      elem.empty();
      elem.append(`<iframe class="youtube-iframe"
                           src="https://www.youtube.com/embed/${videoID}?modestbranding=1&rel=0&autoplay=1&wmode=transparent&theme=light&color=white"
                           frameborder="0" allowfullscreen></iframe>`);
    }

    /**
     * Shows the loading icon in the messages section
     */
    public showMessageLoading(): void {
        $(ElementIdentifiers.ChatSection.loading).show();
        $(ElementIdentifiers.ChatSection.scrollSection).fadeTo(300, 0.3);
    }

    /**
     * Hides the loading icon in the messages section
     */
    public hideMessageLoading(): void {
        $(ElementIdentifiers.ChatSection.loading).hide();
        $(ElementIdentifiers.ChatSection.scrollSection).fadeTo(300, 1);
    }

    /**
     * Fades the messages section from 0.3 to 1
     */
    public fadeInMessages(): void {
        $(ElementIdentifiers.ChatSection.scrollSection)
            .stop(true)
            .fadeTo(100, 1);
    }

    /**
     * Fades the messages section from 1 to 0.6
     */
    public fadeOutMessages(): void {
        $(ElementIdentifiers.ChatSection.scrollSection)
            .stop(true)
            .fadeTo(0, 0.6);
    }

    /**
     * Moves the chat input back to the bottom of the chat area
     */
    private moveChatInputToBottom(): void {
        $(ElementIdentifiers.ChatInput.main).detach().appendTo($(ElementIdentifiers.ChatSection.main));
        $(ElementIdentifiers.ChatInput.textInput).focus();
        $(ElementIdentifiers.ChatInput.main).css("padding-left", "5px");
    }

    /**
     * Moves the chat input into the message list with the other messages
     */
    private moveChatInputToMessageList(): void {
        $(ElementIdentifiers.ChatInput.main).detach().appendTo($(ElementIdentifiers.ChatSection.list));
        $(ElementIdentifiers.ChatInput.textInput).focus();
        $(ElementIdentifiers.ChatInput.main).css("padding-left", "15px");
    }

    /**********
     * EVENTS *
     **********/

    public registerEvents(): void {
        this.registerMessageSend();
        this.registerTextInput();
        this.registerVideoThumbnailClick();
    }

    /**
     * Tells the client to take the necessary steps to send the message
     */
    private handleMessageSend(context: any): void {
        const chatText = $(context).val();
        this._client.sendChatMessage(chatText);
        $(context).val("");
        this.lastMessageInput = "";
    }

    /**
     * Registers the submit event of the chat message form for sending a message
     */
    private registerMessageSend(): void {
        const self = this;
        $(ElementIdentifiers.ChatInput.textInput).on("keydown", function(event) {
            if (event.keyCode === 13 && !event.shiftKey) {
                if ($(this).val().length > 0) {
                    const scrollIsAtBottom = self.getScrollIsAtBottom();
                    self.handleMessageSend(this);
                    $(this).text("");
                    this.style.height = "0px";
                    this.style.height = (this.scrollHeight) + "px";
                    self.moveChatInputToBottom();
                    event.preventDefault();

                    if (scrollIsAtBottom) {
                        self.scrollToBottom();
                    }
                }
            }
        });
    }

    private registerTextInput(): void {
        const self = this;
        $(ElementIdentifiers.ChatInput.textInput).on("input", function(event) {
            const scrollIsAtBottom = self.getScrollIsAtBottom();
            const currentMessage = $(this).val();

            if (currentMessage.length === 0) {
                self.moveChatInputToBottom();
            } else if (self.lastMessageInput.length === 0) {
                self.moveChatInputToMessageList();
            }

            let queue: EditQueueEntry[] | null = null;
            if (currentMessage.indexOf("/") === 0) {
                if (!self._messageInputHadCommandPrefix) {
                    queue = TextDifference.getEditQueue(self.lastMessageInput, "");
                }
            } else {
                if (self._messageInputHadCommandPrefix) {
                    self._messageInputHadCommandPrefix = false;
                    self.lastMessageInput = "";
                }

                queue = TextDifference.getEditQueue(self.lastMessageInput, currentMessage);
            }

            self.lastMessageInput = currentMessage;

            if (queue !== null) {
                self._client.sendEditQueue(queue);
            }
            this.style.height = "0px";
            this.style.height = (this.scrollHeight) + "px";

            if (scrollIsAtBottom) {
                self.scrollToBottom();
            }
        });
    }

    private registerVideoThumbnailClick(): void {
        const self = this;
        $(ElementIdentifiers.ChatSection.list).on("click", ElementIdentifiers.ChatSection.youtubePlayer, function() {
            self.displayYoutubeVideo($(this));
        });
    }
}

export default MessageSection;
